<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>C++Primer读书笔记 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-06 19:55" pubdate>2021年3月6日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 95 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">C++Primer读书笔记</h1><div class="markdown-body" id="post-body"><p>最近重读了C++ Primer这本书，比较重要的知识点记录在此，也对其中一些知识点做了延伸。</p><p>主要来源：C++ Primer、stack overflow</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="变量与基本类型"><a href="#变量与基本类型" class="headerlink" title="变量与基本类型"></a>变量与基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p>C++的基本内置类型包括算数类型（arithmetic type）和空类型（void）。</p><p>算数类型中，short至少为16位，int至少为16位，long至少为32位，而long long至少为64位。</p><p>windows上一般int和long均为32位，而linux 64位机器上long和long long是64位，int是32位。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why is the sizeof(int) == sizeof(long)?">[1]</span></a></sup></p><h4 id="如何选择类型"><a href="#如何选择类型" class="headerlink" title="如何选择类型"></a>如何选择类型</h4><ol><li>数值不会为负时，选择无符号类型</li><li>若数值超过int，直接选用long long，因为如上所述，long也许会与int是同样大小</li><li>浮点数选double，因为精度高，且计算代价与float相差无几。</li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>当我们赋给无符号类型一个超出其范围的值时，结果是初始值对无符号类型可以表示的数目取模的余数。</li><li>当我们赋给带符号类型一个超出其范围的值时，结果是未定义的。</li></ol><p>因为C、C++对于数值的表示是与CPU一致的，在实际中，表示无符号的方式就只有一种：纯二进制表示；但表示有符号的类型却有多种，如反码、补码等，无法统一，因此在C++中结果未定义。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why is unsigned integer overflow defined behavior but signed integer overflow isn’t?">[2]</span></a></sup></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量：一个具名的、可供程序操作的存储空间</p></li><li><p>对象：一块能存储数据并具有某种类型的内存空间</p></li></ul><p>对于C++程序员而言，这两者一般可以互换使用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>初始化不是赋值。</strong>初始化是创建变量时赋予一个初始值，而赋值是把对象当前值擦除，以一个新值替代。</p><ul><li>列表初始化：C++11新标准，用花括号初始化变量。<strong>对于内置变量，若初始值存在丢失信息的风险，会报warning，其他初始化则不会。</strong></li><li><strong>默认初始化</strong>：当定义变量没给指定初始值时，变量会被默认初始化，其值由定义的位置决定。（<strong>任何</strong>）变量若在函数外，初始化为0；若是在函数内的<strong>内置类型变量</strong>，会不被初始化，其值未定义。而各个类自己决定初始化对象的方式，如常用的string，则会默认初始化为空串。</li></ul><h4 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h4><p>为了允许将程序拆分为多个部分来编写（模块化），C++支持<strong>分离式编译</strong>，该机制允许检查程序分割为多个文件，每个文件可以被独立编译。</p><p>由于拆分成了多个文件，需要有文件间共享代码的方法，因此C++将声明和定义分开来。声明可以有多次，但定义只能有一次。</p><p>容易弄错的声明与定义：</p><pre><code class="hljs cpp"><span class="hljs-comment">// declaration</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> bar;  <span class="hljs-comment">// extern说明该变量必须！是另一个编译单元的全局变量 但这一外部声明语句可以在本编译单元的任意处使用</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span>;</span>

<span class="hljs-comment">// definition</span>
<span class="hljs-keyword">int</span> bar;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span> &#123;</span>&#125;;

<span class="hljs-comment">// 这还是定义</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.1416</span>; <span class="hljs-comment">// 赋了初始值，抵消了extern的作用</span></code></pre><h4 id="typedef和-define"><a href="#typedef和-define" class="headerlink" title="typedef和#define"></a>typedef和#define</h4><p><code>#define</code>是预处理器的命令，只是进行字符的替换，编译器看不到其所定义的标识符。</p><p><code>typedef</code>是编译器的关键字，会进行类型的检查。</p><h4 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h4><p>（引用指的是“左值引用”，指针指的是“原始指针”）</p><p>引用是对绑定的<strong>对象</strong>（只能是对象，而不能是一个字面值）起的一个别名，它本身不是一个对象。引用必须初始化，且<strong>不能重新绑定到另外一个对象</strong>。引用的类型和与之绑定的对象要严格匹配。由于引用不是一个对象，所以不能定义引用的引用。</p><p>指针也实现了对其他对象的简介访问。但与引用相比也有许多不同点：</p><ol><li>指针本身是一个对象，允许拷贝与赋值，而且指针可以先后指向不同的对象</li><li>指针无需在定义时赋初始值，与其他内置类型一样，在块作用域内没被初始化则拥有一个不确定的值</li></ol><h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义包括一个<strong>基本数据类型</strong>（如int）和一组<strong>声明符</strong>（声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。如<code>i</code>，<code>*p</code>，<code>&amp;r</code>）。在同一条定义语句中，基本类型必须只有一个，但是声明符可以不同。如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1024</span>, *p = &amp;i, &amp;r = i;  <span class="hljs-comment">// i是整数，p是int指针，r是int引用</span></code></pre><p><code>*</code>和<code>&amp;</code>在这里是<strong>类型修饰符</strong>，作为<strong>声明符</strong>的一部分。</p><p>经常会有一种错误的观点认为，在定义语句中，类型修饰符会作用于定义的全部变量，实际并不是，仅仅作用于其后的第一个变量。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span>* p1, p2; <span class="hljs-comment">// p1是int的指针，但p2不是，p2是int类型</span>
<span class="hljs-keyword">int</span> *p1, *p2; <span class="hljs-comment">// p1, p2都是int的指针</span></code></pre><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const对象仅在文件内有效，若多个文件中出现了同名，其实等同于在不同文件中分别定义了独立的变量。如果想在文件间共享，则不管是声明还是定义都添加extern关键字。</p><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp 定义一个常量，允许被其他文件访问</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">100</span>;
<span class="hljs-comment">// file1.h</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize; <span class="hljs-comment">// 与file1.cpp是同一个</span></code></pre><h4 id="对常量的引用"><a href="#对常量的引用" class="headerlink" title="对常量的引用"></a>对常量的引用</h4><p>对常量的引用不能用于修改其绑定的对象，但其绑定的对象不一定是一个常量（只是引用“自以为是”罢了）。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> &amp;r1 = i;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i;
r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，i被修改为0</span>
r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//错误 不能通过r2修改i</span></code></pre><p>而如果是一个常量，那么引用只能是对常量的引用。</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">// 错误， 否则可以通过r2修改i</span></code></pre><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><ul><li>指向常量的指针，可以不初始化，不能用于改变其所指对象的值（与引用相同，也是“自以为是”）</li><li>常量指针，<strong>必须初始化</strong>，初始化后它的值（所存对象的地址）不能再改变</li></ul><h4 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h4><ul><li>顶层const：可以表示<strong>任意对象</strong>是常量</li><li>底层const：表示与指针和引用这类复合类型的<strong>基本类型部分</strong>是常量</li></ul><p>一般一个类型要么是顶层const，要么是底层const，但指针既可以是顶层const，也可以是底层const。</p><p>常量指针，指针本身是常量，是顶层const；而指向常量的指针，指针本身不是常量，但而指向的对象是常量（指针自以为是），所以是底层const。</p><p>这两个概念在拷贝与赋值时十分重要。</p><p>在拷贝时，顶层const不受影响：</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> i = ci; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> cp = &amp;i;
<span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// 正确</span></code></pre><p>因为拷贝操作并不会改变被拷贝对象的值，所以是不是常量都无所谓。</p><p>但是底层const的限制不能忽视。当执行对象的拷贝操作时，<strong>拷入和拷出的对象都必须具有相同的底层const资格，或者能够相互转换，一般来说只有非常量可以转换成常量。</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *cp = &amp;i;
<span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// 错误，因为cp是底层const，而p不是 有可能会通过p修改cp所指向的值</span>
cp = p; <span class="hljs-comment">// 正确， int*可以转成const int*</span></code></pre><h2 id="字符串与向量"><a href="#字符串与向量" class="headerlink" title="字符串与向量"></a>字符串与向量</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline参数是一个输入流和一个string对象，返回流参数。</p><p>每次读取一行，<strong>换行符会被读进来</strong>，所读的内容存入string对象，但是<strong>不存换行符</strong>。</p><p>所以我们一般输出时会自行加一个endl：</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line;
<span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>, line))
    <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h4 id="处理字符"><a href="#处理字符" class="headerlink" title="处理字符"></a>处理字符</h4><p>在<code>cctype</code>头文件中，常用的有：</p><ul><li>isalpha(c) 字母</li><li>isdigit(c) 数字</li><li>isalnum(c) 字母或数字</li><li>isspace(c) 空白</li><li>ispunct(c) 标点符号</li></ul><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p><code>operator+</code>是拷贝两个字符串，生成新的字符串，复杂度为<code>O(length(oldStr+newStr))</code>，<code>operator+=</code>是调用<code>append</code>函数，而<code>append</code>函数复杂度为<code>O(length(newStr))</code>。</p><p><code>append</code>的实现：根据文档，没有标准的复杂度保证，而实现是类似vector的insert函数。</p><h4 id="string和vector-lt-char-gt"><a href="#string和vector-lt-char-gt" class="headerlink" title="string和vector&lt;char&gt;"></a><code>string</code>和<code>vector&lt;char&gt;</code></h4><p>string是模板类<code>basic_string</code>的char特例，源码定义如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-built_in">string</span>;</code></pre><p>而basic_string类中，有三个主要的成员变量，分别是分配空间的首尾地址和当前最后一个元素的地址，这与vector是一样。因此，string和<code>vector&lt;char&gt;</code>在数据结构上是一致的，只不过string还提供了额外的对于字符串的操作，如转为c-style字符串的<code>data()</code>函数，还重载了输入输出运算符等等。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="reserve和resize"><a href="#reserve和resize" class="headerlink" title="reserve和resize"></a>reserve和resize</h4><p>resize分配内存，且调用对应的构造函数构造对象，会添加或删除元素达到对应的大小，会修改<code>size</code>，增加元素时会修改<code>capacity</code>。</p><p>reserve分配内存，不构造对象，只会影响<code>capacity</code>，不会影响<code>size</code>。</p><h4 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h4><p>如果只提供vector容纳的数量，而略去了初始值，那么库会给一个值初始化的初值赋给容器中所有元素。</p><p>如果元素是内置类型，会自动设为0，如果是某种类类型，则又类默认初始化。</p><h4 id="vcector和string的增长"><a href="#vcector和string的增长" class="headerlink" title="vcector和string的增长"></a>vcector和string的增长</h4><p>vector和string都是分配连续的内存空间，元素是连续存储的。因此当没有空间容纳新元素时，我们必须重新分配一片内存空间，将已有元素移到新空间，添加元素，然后释放旧空间。如果每次添加元素都分配新空间，效率会很低。因此，vector和string的实现通常会分配比新的空间需求更大的空间，预留这些空间作为备用。</p><p>c++标准其实并没有指定要扩展内容多少，是依赖于实现的。各个实现也只是为了实现标准中所说的push_back（vector的）要摊还O(1)，比如g++编译器是2倍，而vs的编译器是1.5倍。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们可以使用下标运算符来访问容器，但迭代器是一种更通用的访问机制。</p><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</p><p>在修改容器容量的循环中，不要使用迭代器，因为原本的迭代器会失效。</p><h4 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h4><p>支持加减一个整数，支持在同一个容器中的迭代器大小比较。</p><p><strong>支持同一个容器中两个迭代器的减法运算<code>iter1-iter2</code>，但不支持加法运算<code>iter1+iter2</code></strong>。</p><h4 id="样例：迭代器版本的二分搜索"><a href="#样例：迭代器版本的二分搜索" class="headerlink" title="样例：迭代器版本的二分搜索"></a>样例：迭代器版本的二分搜索</h4><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> beg = text.begin();
<span class="hljs-keyword">auto</span> end = text.end();
<span class="hljs-keyword">auto</span> mid = beg + (end - beg) / <span class="hljs-number">2</span>;
<span class="hljs-keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;
    <span class="hljs-keyword">if</span> (sought &lt; *mid) &#123;
        end = mid;
    &#125; <span class="hljs-keyword">else</span> &#123;
        beg = mid +<span class="hljs-number">1</span>;
    &#125;
    mid = beg + (end - beg) / <span class="hljs-number">2</span>;
&#125;</code></pre><p><strong>为什么求mid是beg + (end-beg)/2而不是(beg+end)/2？</strong></p><ol><li>如果是下标访问，beg+end或许会溢出</li><li>如果是迭代器版本，迭代器并不支持迭代器相加的运算</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的维度在编译时必须已知，即维度是常量表达式（字面值，常量表达式初始化的const对象，constexpr类型变量）</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>当使用字符串字面值初始化字符数组时，一定要注意<strong>字符串字面值</strong>的结尾还有一个空字符会被自动添加。</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> a1[] = &#123;<span class="hljs-string">'c'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'+'</span>&#125; <span class="hljs-comment">// 正确 字符字面值初始化，大小为3</span>
<span class="hljs-keyword">char</span> a2[] = <span class="hljs-string">"C++"</span>  <span class="hljs-comment">// 正确 字符串字面值初始化 大小为4</span>
<span class="hljs-keyword">char</span> a3[<span class="hljs-number">6</span>] = <span class="hljs-string">"Daniel"</span>  <span class="hljs-comment">// 错误，没位置存放空字符\0</span></code></pre><h4 id="不允许拷贝与赋值"><a href="#不允许拷贝与赋值" class="headerlink" title="不允许拷贝与赋值"></a>不允许拷贝与赋值</h4><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a1[] = a; <span class="hljs-comment">// 错误 不允许一个数组初始化另一个数组</span></code></pre><h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p>使用数组的时候编译器一般会把它转换为数组首元素的指针。</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> *p = strs; <span class="hljs-comment">// 等价于string *p = &amp;strs[0]</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testArr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> <span class="hljs-comment">// a等价于&amp;a[0]，是指针</span></span>
<span class="hljs-function"><span class="hljs-comment">// 但注意定义数组时，数组名的类型仍然是数组</span></span>
int a[3] = &#123;1, 2, 3&#125;; // a为数组类型
<span class="hljs-keyword">decltype</span>(a) a2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 正确</span>
a2 = p; <span class="hljs-comment">// 错误 不能将指针赋给数组</span></code></pre><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p><strong>除非必须，否则不用后置版本。</strong></p><p>前置版本是将运算对象加1（或减1），然后返回改变后的对象，是左值；而后置版本是先暂存当前对象，然后加1（或减1），返回暂存的对象，是右值。如果我们不需要修改前的值，那么暂存的对象就是一种浪费。</p><h4 id="混用解引用和递增运算符"><a href="#混用解引用和递增运算符" class="headerlink" title="混用解引用和递增运算符"></a>混用解引用和递增运算符</h4><p>这是一种常见的简洁写法，值得学习。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> beg = v.begin();
<span class="hljs-keyword">while</span> (beg != v.end() &amp;&amp; *beg &gt; <span class="hljs-number">0</span>)
    <span class="hljs-built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p><strong>后置递增运算符的优先级高于解引用运算符。</strong>因此<code>*beg++</code>等价于<code>*(beg++)</code>。最终，这条语句输出<code>beg</code>开始指向的那个元素，并将指针向前移动一个位置。</p><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>sizeof返回一个表达式或类型名所占的字节数，编译时计算，返回的是常量表达式。</p><p><strong>它并不实际计算其运算对象的值</strong>，如：</p><ol><li>sizeof(*p) p可以是一个无效的指针，因为无需真的解引用指针</li><li>sizeof(Sales_data::revenue) 可以使用作用域运算符获取类成员的大小，因为无需真的获取该成员</li></ol><p>注意：对于stl的容器，sizeof返回的是与容器类相关的一个常量值。比如：vector是24， unordered_set</p><p>是56。</p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used" target="_blank" rel="noopener">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></p><p>形式如下：</p><pre><code class="hljs cpp">cast-name&lt;type&gt;(expression);</code></pre><ul><li><p><code>static_cast</code>：只要不包含底层const，对于有明确定义的类型转换就可以使用。尤其是把一个较大的算术类型转换为较小的类型时，这会告诉编译器我们知道且不在乎该精度损失。</p></li><li><p><code>const_cast</code>：只能改变运算对象的底层const。</p></li><li><p><code>reinterpret_cast</code>（<strong>十分危险</strong>）：为运算对象的位模式提供重新的解释，如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip;
<span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);</code></pre></li><li><p><code>dynamic_cast</code>：</p></li></ul><h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>早期C++有两种强制类型转换的形式：</p><ul><li>函数形式：type(expr)</li><li>C语言风格：(type)expr</li></ul><p>旧式的强制类型转换包含现代显式类型转换的前三种形式，但是由于从形式上来说不那么清晰明了，一旦转换过程出现问题，追踪起来更为困难。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们作用在数组上的函数有影响：</p><ol><li>不能拷贝数组。因此我们无法以值传递的方式使用数组参数。</li><li>使用数组时常会将其转换为指针。因此我们为一个函数传递数组时，传递的实际是数组首元素的指针。</li></ol><p>对于一个数组参数，我们可以有多种形式</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 这里的维度只是期望，实际不一定是10</span></code></pre><p>虽然有不同的表现形式，但其实唯一形参都是<code>int *</code>，即编译器只检查传入的参数是否是<code>int *</code>。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
print(&amp;i); <span class="hljs-comment">// 所以这也是能编译通过的</span></code></pre><h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><pre><code class="hljs cpp">f(<span class="hljs-keyword">int</span> (&amp;arr)[<span class="hljs-number">10</span>]); <span class="hljs-comment">// 正确， 读的方式：从里往外读，从右往左读</span>
f(<span class="hljs-keyword">int</span>&amp; arr[<span class="hljs-number">10</span>]); <span class="hljs-comment">// 错误，这样是引用的数组，而引用不是对象，不能存于数组</span></code></pre><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>当传递数组为参数时，实际传的是数组首元素的指针。当我们传多维数组，也就是数组的数组时，数组首元素即一个数组，所以实际传的是一个指向数组的指针。数组第二维及以后的维度都是数组类型的一部分，不能省略，所以我们应该这样传：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)</span></span>;  <span class="hljs-comment">// 第二维是类型的一部分，因此要制定维度，这里是10</span></code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员函数与this指针"><a href="#成员函数与this指针" class="headerlink" title="成员函数与this指针"></a>成员函数与this指针</h3><p>以一个成员函数的调用为例：</p><pre><code class="hljs cpp">total.isbn()</code></pre><p>当我们调用成员函数时，其实是在替某个对象调用它。如果该成员函数指向了该类的某个成员变量，则它隐式地指向调用该函数对象的成员变量。</p><p>成员函数通过一个名为<code>this</code>的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>，如调用上述函数，则可以等价地认为编译器重写为</p><pre><code class="hljs cpp">Sales_data::isbn(&amp;total);</code></pre><p>在成员函数内部，我们可以直接使用该对象的成员，而无需成员访问运算符，也正是因为this所指的就是这个对象。所以我们使用<code>bookNo</code>，其实相当于<code>this-&gt;bookNo</code>。</p><p>因为<code>this</code>总是指向“这个”对象，所以它是一个<strong>常量指针</strong>。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>这里const的作用是<strong>修改隐式this指针的类型</strong>。</p><p>默认情况下，this的类型是指向类类型非常量版本的常量指针，即<code>T *const</code>，则我们不能将其绑定到一个常量对象上，这样我们也就不能在一个常量对象上调用普通的成员函数了。</p><p>而const成员函数则可以将this转换为指向常量的常量指针<code>const T *const</code>，这样常量对象也就能调用const成员函数了。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数不能声明为const"><a href="#构造函数不能声明为const" class="headerlink" title="构造函数不能声明为const"></a>构造函数不能声明为const</h4><p>当我们创建一个const类对象时，直到构造函数完成初始化过程，对象才真正获得了“常量”属性，因此构造函数在const对象构造过程中是可以向其写值的，那么也就不能声明为const。</p><h4 id="合成默认构造函数"><a href="#合成默认构造函数" class="headerlink" title="合成默认构造函数"></a>合成默认构造函数</h4><p>如果我们没有显式地定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数，称为合成默认构造函数，它按以下规则初始化类的成员：</p><ul><li>如果存在类内初始值（在定义时赋初值，如<code>int a = 3</code>），用它初始化成员</li><li>否则，默认初始化成员</li></ul><p>如果类内含有内置类型或者复合类型（指针，引用等）的成员，只有当这些成员全都被赋予了类内初始值，这个类才适合使用合成默认构造函数，不然这些成员的值是未定义的。</p><h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><p>当某个数据成员被构造初始化列表忽略时，它将以合成默认构造函数的方式隐式初始化。</p><h3 id="从const成员函数返回-this"><a href="#从const成员函数返回-this" class="headerlink" title="从const成员函数返回*this"></a>从const成员函数返回*this</h3><p>因为const成员函数中this是一个<code>const T *const</code>类型的指针，指向常量的指针返回指向的对象必须是常量，不让修改。因此，返回的<code>*this</code>应该是一个常量引用<code>const T&amp;</code>。</p><h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h3><p>因为非常量版本的函数对于常量对象是不可用的， 因此我们只能在一个常量对象上调用const成员函数；另一方面，虽然可以在非常量对象上调用常量函数，但显然非常量版本是一个更好的匹配。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Foo &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> </span>&#123;
        do_display(os);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">const</span> Foo &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span>&#123;
        do_display(os);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> </span>&#123;  <span class="hljs-comment">// 使用私有功能函数，减少代码重复</span>
        ...
    &#125;
&#125;;</code></pre><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p><strong>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。</strong></p><p>假如类Sales_item定义了以下函数</p><pre><code class="hljs cpp">Sales_item(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(Sales_item)</span></span>;</code></pre><p>那么以下代码是正确的：</p><pre><code class="hljs cpp">Sales_item item ...
    ...
<span class="hljs-built_in">string</span> null_book = <span class="hljs-string">"9-999-999"</span>;
item.combine(nullbook);</code></pre><p>因为string类型可以隐式转换为Sales_itme类型。</p><p>但是隐式转换只允许一步类型转换，所以以下代码是错误的：</p><pre><code class="hljs cpp">item.combine(<span class="hljs-string">"9-999-999"</span>); <span class="hljs-comment">// 需要两步，（1）把const char*转为string （2）把string转为Sales_item</span></code></pre><h4 id="explicit抑制隐式转换"><a href="#explicit抑制隐式转换" class="headerlink" title="explicit抑制隐式转换"></a>explicit抑制隐式转换</h4><p>构造函数使用<code>explicit</code>关键字阻止隐式转换。</p><p>该关键字只对有一个实参的构造函数有效，需要多个实参的构造函数不能用于隐式转换，也就不需要该关键字。只能在类内声明时加，类外定义时不应重复。</p><p><strong>explicit构造函数只能用于直接初始化！</strong></p><p>发生隐式转换的一种情况是我们执行拷贝形式的初始化时（使用=），如果该构造函数是explicit，则无法进行该隐式转换。</p><pre><code class="hljs cpp"><span class="hljs-function">Sales_data <span class="hljs-title">item</span><span class="hljs-params">(null_book)</span></span>; <span class="hljs-comment">// 正确：直接初始化</span>
Sales_data item = null_book <span class="hljs-comment">// 错误 无法完成隐式转换</span></code></pre><h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>常用的IO库设施：</p><ul><li>istream（输入流）类型</li><li>ostream（输出流）类型</li><li>cin， 一个istream对象，从<strong>标准输入</strong>读取数据</li><li>cout， 一个ostream对象，向<strong>标准输出</strong>写入数据</li><li>cerr，一个ostream对象，用于输出程序错误信息，写入<strong>标准错误</strong></li><li><code>&gt;&gt;</code>运算符（提取运算符），用于从一个istream对象读取输入</li><li><code>&lt;&lt;</code>运算符（插入运算符），用于向一个ostream对象写入输出</li></ul><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p><strong>IO对象不能拷贝和赋值！</strong></p><h3 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h3><p>由于流可能处于错误状态，因此代码通常应该在使用流前检查它是否是良好的。确定一个流对象的状态最简单的方法就是将它作为一个条件来使用：</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word)
    <span class="hljs-comment">// 流状态良好</span></code></pre><h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p>IO库定义了一个iostate类型，作为位集合使用。</p><ul><li>badbit表示系统级错误，不可恢复</li><li>failbit是可恢复错误，流还可以使用，如期望读取数值却读到了字符串等错误</li><li>文件结束，eofbit和failbit都会被置位</li><li>goodbit值为0表示流状态良好</li></ul><p>我们前面将流当做条件使用的代码其实就相当于<code>!fail()</code>。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>文件常用操作：</p><ul><li>fstream fstrm(filename); 创建一个文件流对象，并绑定一个文件，自动调用open函数打开它</li><li>fstrm.open(filename) 打开并绑定文件filename</li><li>fstrm.close()关闭与fstrm绑定的文件</li><li>fstrm.is_open() 返回一个bool值，指出与fstrm关联的文件是否成功打开</li></ul><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>open失败，failbit会被置位。因为调用open可能失败，因此检测open是否成功是个好习惯，可以检查流对象的有效性或调用is_open()函数。</p><p>对一个已经打开的文件流调用open会失败，而且为了将文件流关联到另一个文件，必须首先关闭已经关联的文件。</p><p>当一个fstream对象被销毁时，会自动调用close函数。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><div class="table-container"><table><thead><tr><th>in</th><th>读</th></tr></thead><tbody><tr><td>out</td><td>写</td></tr><tr><td>app</td><td>每次写操作前定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>二进制读写</td></tr></tbody></table></div><ol><li>只有out被设定，trunc才能被设定</li><li>只要trunc没被设定，app就可以设定</li></ol><h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul><li>istringstream</li><li>ostringstream</li><li>stringstream</li></ul><p>从string中读写数据，就像string是个IO流一样。</p><h3 id="istringsteam常用形式"><a href="#istringsteam常用形式" class="headerlink" title="istringsteam常用形式"></a>istringsteam常用形式</h3><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line, word;
<span class="hljs-keyword">while</span> (getline(<span class="hljs-built_in">cin</span>, line)) &#123;
    <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">record</span><span class="hljs-params">(line)</span></span>;
    <span class="hljs-keyword">while</span> (record &gt;&gt; word) &#123;
        ...
    &#125;
&#125;</code></pre><h3 id="ostringstream常用形式"><a href="#ostringstream常用形式" class="headerlink" title="ostringstream常用形式"></a>ostringstream常用形式</h3><p>当我们想逐步构造输出，希望最后一起打印时，ostringstream很有用。</p><p>比如一个人有很多电话号码，我们希望确定一个人所有有效的电话号码后再一起输出。</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;nums : entry.phones) &#123;
    <span class="hljs-keyword">if</span> (valid(nums)) &#123;
        formatted &lt;&lt;  <span class="hljs-string">" "</span> &lt;&lt; format(nums);
    &#125;
&#125;
os &lt;&lt; entry.name &lt;&lt; <span class="hljs-string">" "</span> formatted.str() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// stringstream的str成员函数是返回内部string的拷贝</span></code></pre><h1 id="动态内存与指针"><a href="#动态内存与指针" class="headerlink" title="动态内存与指针"></a>动态内存与指针</h1><p>能不用指针就不用指针，可以值传递或者引用，如果一定要用指针，先考虑智能指针，原始指针很少用。何时使用指针：<a href="https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself" target="_blank" rel="noopener">Why should I use a pointer rather than the object itself?</a></p><p>程序使用动态内存的三种原因：</p><ol><li>不知道自己需要使用多少对象（容器类）</li><li>不知道对象的准确类型（多态）</li><li>需要在多个对象间共享数据（使用shared_ptr共享底层数据）</li></ol><h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new delete"></a>new delete</h2><p>在C++中，如果需要自己直接管理内存，就需要使用new和delete这两个关键字。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>new表达式在自由空间构造一个对象，并返回该对象的指针。默认情况下，该对象是默认初始化的， 如果在类型名后加一个空括号则是值初始化，加参数则是调用对应有参数的构造函数（类）。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">// 默认初始化</span>
<span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(); <span class="hljs-comment">// 值初始化</span>
<span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 指定初始化为5，若是类则调用对应有参数的构造函数</span></code></pre><h4 id="动态分配的const对象"><a href="#动态分配的const对象" class="headerlink" title="动态分配的const对象"></a>动态分配的const对象</h4><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>);</code></pre><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>与new类似，delete也执行两个操作：</p><ol><li>销毁给定指针所指对象</li><li>释放对应内存</li></ol><h4 id="与malloc-free的区别"><a href="#与malloc-free的区别" class="headerlink" title="与malloc free的区别"></a>与malloc free的区别</h4><p>最主要的区别就是new delete在分配和释放内存之余还会构造和销毁对象，而malloc和free只会分配和释放内存。而且new和delete的操作符，可以被合法重载，而malloc和free不行。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针就是包装着原始指针的类，自行管理动态内存，无须担心内存泄漏。</p><p>现代C++中，原始指针不能与动态内存管理相关，这一工作应交给智能指针来做。</p><blockquote><p>A raw pointer should only be used as a “view” and not in any way involved in ownership.</p></blockquote><p>智能指针和原始指针的选用详见：<a href="https://stackoverflow.com/questions/7657718/when-to-use-shared-ptr-and-when-to-use-raw-pointers/7658089" target="_blank" rel="noopener">When to used shared_ptr and when to use raw pointers?</a></p><h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>我们可以认为每个shared_ptr都有一个关联的计数器， 通常称为引用计数。</p><p>当我们拷贝一个shared_ptr时，对应计数器都会递增，如用一个shared_ptr初始化另一个shared_ptr，或将其作为参数传递，或是作为函数返回值。当我们给shared_ptr赋予一个新值或是其被销毁，计数器就会递减。</p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>除了使用make_shared初始化shared_ptr，我们还可以使用new返回的指针初始化智能指针。但注意：接受指针参数的构造函数是explicit的，也就是说只能直接初始化，而不支持隐式转换</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;  <span class="hljs-comment">// 正确</span>
<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 错误</span></code></pre><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr“拥有”它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。使用new进行初始化。</p><p>不能拷贝或者赋值unique_ptr，但是可以通过rest或release转移指针的所有权。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是“弱”共享对象，指向shared_ptr管理的对象，不会改变其引用计数，而且即使有weak_ptr指向对象，对象也可以释放。</p><p>用处：</p><ol><li>检测一个对象是否还存在，解决空悬指针的问题<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="When is std::weak_ptr useful?">[3]</span></a></sup></li></ol><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>);
<span class="hljs-keyword">int</span> *ref = ptr;
<span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 此时ref和ptr都是空悬指针，指向未定义的数据</span>
<span class="hljs-comment">// 为了解决这一问题，我们可以使用shared_ptr和weak_ptr</span>
<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; sptr = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);
weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; weak = sptr;
sptr.reset(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>);   <span class="hljs-comment">// 转移指向的对象，释放原对象（如果引用计数为1）</span>
*sptr = <span class="hljs-number">5</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp = weak.lock()) <span class="hljs-comment">// 如果指向对象的引用计数为0，返回空shared_ptr,否则返回一个指向该对象的shared_ptr</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *temp &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-keyword">else</span> 
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weak is expired"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><ol><li>解决shared_ptr循环引用的问题</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">// 若让二叉树的节点一个成员变量shared_ptr指向其父节点，则存在循环引用，会造成内存泄漏</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> &#123;</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; left;
        <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; right;
        <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; parent;
        TreeNode(<span class="hljs-keyword">int</span> val):val(val) &#123;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        &#125;
        ~TreeNode() &#123;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Destructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        &#125;
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> val;

&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; ptr = make_shared&lt;TreeNode&gt;(<span class="hljs-number">4</span>);
    ptr-&gt;left = make_shared&lt;TreeNode&gt;(<span class="hljs-number">2</span>);
    ptr-&gt;left-&gt;parent = ptr;
    ptr-&gt;right = make_shared&lt;TreeNode&gt;(<span class="hljs-number">5</span>);
    ptr-&gt;right-&gt;parent = ptr;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ptr: "</span> &lt;&lt; ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ptr-&gt;left: "</span> &lt;&lt; ptr-&gt;left.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ptr-&gt;right: "</span> &lt;&lt; ptr-&gt;right.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">// 输出为</span>
Constructor
Constructor
Constructor
ptr: <span class="hljs-number">3</span>
ptr-&gt;left: <span class="hljs-number">1</span>
ptr-&gt;right: <span class="hljs-number">1</span>

<span class="hljs-comment">// 若将指向父节点的指针改为weak_ptr则可以解决这一问题</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> &#123;</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; left;
        <span class="hljs-built_in">shared_ptr</span>&lt;TreeNode&gt; right;
        weak_ptr&lt;TreeNode&gt; parent;
        TreeNode(<span class="hljs-keyword">int</span> val):val(val) &#123;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        &#125;
        ~TreeNode() &#123;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Destructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        &#125;
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> val;

&#125;;
<span class="hljs-comment">// 其余不变， 输出为：</span>
Constructor
Constructor
Constructor
ptr: <span class="hljs-number">1</span>
ptr-&gt;left: <span class="hljs-number">1</span>
ptr-&gt;right: <span class="hljs-number">1</span>
Destructor
Destructor
Destructor</code></pre><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><p>声明中包含类名，但是不能包含它的派生列表。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base;  <span class="hljs-comment">// 错误</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>;</span> <span class="hljs-comment">// 正确</span></code></pre><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>当我们使用存在继承关系的类型时，我们就需要将一个变量的静态类型和动态类型区分开来。</p><p>静态类型是在编译时已知的，是声明时确定的类型；动态类型则是实际在内存的对象的类型，运行时才可知。</p><p>比如我们知道item的静态类型是<code>Base&amp;</code>，但是它动态类型依赖于绑定的实参，动态类型直到运行时调用函数才会知道，也许是<code>Base</code>，也许是<code>Derived</code>。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待，若基类希望派生类各自定义自己的版本，则声明这些函数为<strong>虚函数</strong>。</p><p>当用指针或引用调用虚函数时，该调用将被动态绑定，即调用函数的版本由运行时调用的对象决定。</p><p>如果派生类没有覆盖基类的某个虚函数，则派生类会直接继承基类的版本。</p><h3 id="C-的多态性"><a href="#C-的多态性" class="headerlink" title="C++的多态性"></a>C++的多态性</h3><h4 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h4><p>即函数重载，相同的函数名，类型或个数不同的参数。</p><h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><p>对于类中定义的虚函数，我们使用基类的引用或指针调用它时，将发生动态绑定，直到运行时我们才确定调用函数的版本。这其实是基于引用或指针的静态类型和动态类型不同这一事实。</p><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>继承。有类的继承才有重写，重载不需要继承</li><li>函数签名。重写函数必须有相同的函数名与参数，而重载函数需要有相同的函数名，不同的参数</li><li>函数作用域。重写的函数有不同的作用域（不同类中），而重载的函数有相同的作用域。</li><li>函数的行为。重写是子类函数希望做与父类函数有些不同的工作，而重载是根据不同的参数来进行不同的工作。</li></ol><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="基础与常用异常处理"><a href="#基础与常用异常处理" class="headerlink" title="基础与常用异常处理"></a>基础与常用异常处理</h2><p>在真实程序中，应该把业务逻辑代码和用户交互的代码分离开来。因此，当遇到问题时，最好不要直接输出错误信息，而是应该抛出异常，让对应专门的代码处理问题，如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (item1.isbn() != item2.isbn())
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Data must refer to same isbn"</span>);</code></pre><p><code>runtime_error</code>是运行时不符合预期时可用。</p><p>异常抛出后，需要<code>try</code>语句块来进行处理。其通用语法为</p><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;
    program-statements
&#125; <span class="hljs-keyword">catch</span> (exception-declaration) &#123;
    handle-statements
&#125; <span class="hljs-keyword">catch</span>(...) &#123;
	...   
&#125;</code></pre><p>让我们用一个典例来加以说明：</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 添加item的代码，若两个item的isbn不同，抛出runtime_error</span>
    &#125; <span class="hljs-keyword">catch</span> (runtime_error err) &#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="hljs-string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">char</span> c;
        <span class="hljs-built_in">cin</span> &gt;&gt; c;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">cin</span> || c == <span class="hljs-string">'n'</span>)
            <span class="hljs-keyword">break</span>;
    &#125;
&#125;</code></pre><p>每个标准库类都定义了一个<code>what</code>成员函数，用于输出错误信息，该错误信息就是之前构造该异常对象时的初始化参数。因此这里会输出<code>Data must refer to same isbn</code>。</p><p>由于输入的isbn不同，我们提示用户是否重新输入，若输入的不是字符（<code>!cin</code>）或输入为n则跳出，不然重新输入。</p><h2 id="寻找处理代码"><a href="#寻找处理代码" class="headerlink" title="寻找处理代码"></a>寻找处理代码</h2><p><strong>寻找处理代码的过程与函数调用链刚好相反</strong>。当异常被抛出时，首先搜索该异常的函数，若没找到匹配的catch则终止该函数，并在调用该函数的函数中继续寻找，以此类推，沿着程序的执行路径逐层回退，直到找到合适类型的catch语句为止。</p><p>如果最终都没有找到匹配的catch语句，则程序转到名为<code>terminate</code>的标准库函数，执行该函数，导致程序非正常退出。</p><h2 id="异常的行为"><a href="#异常的行为" class="headerlink" title="异常的行为"></a>异常的行为</h2><p><strong>异常中断了程序的正常流程</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://stackoverflow.com/questions/18901080/why-is-the-sizeofint-sizeoflong" target="_blank" rel="noopener">Why is the sizeof(int) == sizeof(long)?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is" target="_blank" rel="noopener">Why is unsigned integer overflow defined behavior but signed integer overflow isn’t?</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful" target="_blank" rel="noopener">When is std::weak_ptr useful?</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/">C++ Primer</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/C/">C++</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">组成结构与操作系统</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/C-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"><span class="hidden-mobile">C++头文件包含的相关问题</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","C++Primer读书笔记&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };</script><script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script></body></html>