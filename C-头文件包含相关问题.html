<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>C++头文件包含的相关问题 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-01-02 10:24" pubdate>2021年1月2日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 1.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 15 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">C++头文件包含的相关问题</h1><div class="markdown-body" id="post-body"><p>前两天，室友测试C++的循环包含（<code>cyclic include</code>）和友元函数，但却总是报错。我们一起探讨并查询了各类资料后，终于搞清楚了原因。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们有<code>A</code>和<code>B</code>两个类，分别在不同的头文件中，两个头文件互相包含（但由于有<code>include guard</code>并不会出现循环包含问题）。<code>A</code>类中有一个<code>B</code>类友元函数，一切都是运行正确的，直到我们在<code>B.cpp</code>中加入了<code>B</code>类该函数的定义。</p><p><strong>A.h</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>B.h</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"A.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>B.cpp</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp; a)</span> </span>&#123;
   
&#125;</code></pre><p><strong>main.cpp</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"A.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

&#125;</code></pre><p>运行命令：</p><pre><code class="hljs shell">g++ -g -o test main.cpp B.cpp</code></pre><p><strong>报错信息</strong>：</p><pre><code class="hljs shell">A.h:7:17: error: 'B' has not been declared
    friend void B::fun(A&amp;);</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>经过分析与误打误撞的尝试，我们发现有以下两种消除错误的方法：</p><ol><li>删除<code>B.h</code>中的<code>#include &quot;A.h&quot;</code>语句</li><li>将<code>B.cpp</code>中的<code>#include &quot;B.h&quot;</code>该为<code>#include &quot;A.h&quot;</code></li></ol><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>对于头文件包含产生的问题，最好的方法或许就是自己去扮演<strong>预处理器</strong>的角色。</p><p>C++中，<code>.cpp</code>文件是一个编译单元，因此我们这里来一一分析<code>.cpp</code>文件。</p><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><p><code>main.cpp</code>中先包含了<code>A.h</code>，这时因为<code>A_H</code>还未定义，则<code>A.h</code>中就会定义<code>A_H</code>防止后续的重复包含。<code>A.h</code>又包含了<code>B.h</code>，因为<code>B_H</code>还未定义，则<code>B.h</code>中就会定义<code>B_H</code>。此时，<code>B.h</code>又尝试包含<code>A.h</code>，但由于<code>A_H</code>已被定义，返回的是空文本。最终这些内容都被拷贝到<code>main.cpp</code>中，大致如下：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    
&#125;</code></pre><p>由于B类中的fun函数只是需要A类的引用，而不是A的实例本身或A的成员变量，所以一个前置声明<code>class A;</code>是足够的，并不会报错。</p><p>而A类中需要用到B类的成员函数，因此需要有B类的前置声明和该成员函数的前置声明，预处理后的文件中确实做到了这一点，所以也不会报错。</p><p>关于前置声明，不了解的读者请仔细阅读<a href="https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration" target="_blank" rel="noopener">When can I use a forward declaration?</a>。</p><h3 id="B-cpp"><a href="#B-cpp" class="headerlink" title="B.cpp"></a>B.cpp</h3><p>由于每个<code>.cpp</code>文件是独立的编译单元，因此编译完<code>main.cpp</code>后，将编译<code>B.cpp</code>，而且<strong>之前处理的宏定义（如#ifndef,#define等）都会被遗忘</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why aren’t my include guards preventing recursive inclusion and multiple symbol definitions?">[1]</span></a></sup>。</p><p><code>B.cpp</code>中包含了 <code>B.h</code>，由于没有定义<code>B_H</code>，则会定义<code>B_H</code>，然后<code>B.h</code>包含<code>A.h</code>，定义<code>A_H</code>，<code>A.h</code>中还尝试包含<code>B.h</code>，但由于<code>B_H</code>已被定义，返回的是空文本。最终内容被拷贝到<code>B.cpp</code>中，大致如下：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;
&#125;;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>可以发现，A类中用到了B的成员函数，但B的定义却在后面，所以找不到B类及其成员函数的定义，报错。</p><h2 id="解决方法分析"><a href="#解决方法分析" class="headerlink" title="解决方法分析"></a>解决方法分析</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>由于<code>B.h</code>中我们只用了A类的引用，所以其实一个前向声明就足够了。加上了<code>#include &quot;A.h&quot;</code>，反而引入了A类中B类成员函数找不到声明的问题。因此，删掉<code>#include &quot;A.h&quot;</code>即可，这是比较好的解决方法。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>由于出错的原因就是<code>B.cpp</code>中包含<code>B.h</code>，<code>B.h</code>又包含<code>A.h</code>，引入了A类中B类成员函数找不到声明的问题，因此我们可以直接在<code>B.cpp</code>中包含<code>A.h</code>，这样B类的定义就会在A类前面，不会报错。但是一般而言实现文件应该是要包含对应的头文件的，这样消除错误会带来耦合。</p><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>由于C++是分离编译的，则<code>main.cpp</code>-&gt;<code>main.obj</code>，而<code>B.cpp</code>-&gt;<code>B.obj</code>，按理说这两个目标文件中都应该包含着<code>class B</code>的定义，那为什么没有重复定义的错误呢？</p><p>根据查询的资料，因为<strong>C++是允许类存在重复定义的</strong>，但是所定义的类必须完全一致<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Definitions and ODR (One Definition Rule)">[2]</span></a></sup>。具体的原因我也还不清楚，应该是关于设计、链接等方面的原因，等我以后进行了更深层次的学习后，再来补上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://stackoverflow.com/questions/65455024/mutilple-definition-when-linking-object-files" target="_blank" rel="noopener">Mutilple definition when linking object files</a></p></li><li><p><a href="https://stackoverflow.com/questions/57516685/why-does-the-same-class-being-defined-in-multiple-cpp-files-not-cause-a-linker" target="_blank" rel="noopener">Why does the same class being defined in multiple .cpp files not cause a linker multiple definition error?</a></p></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://stackoverflow.com/questions/14909997/why-arent-my-include-guards-preventing-recursive-inclusion-and-multiple-symbol" target="_blank" rel="noopener">Why aren’t my include guards preventing recursive inclusion and multiple symbol definitions?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.cppreference.com/w/cpp/language/definition" target="_blank" rel="noopener">Definitions and ODR (One Definition Rule)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E9%97%B2%E8%B0%88/">技术闲谈</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/C/">C++</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">C++Primer读书笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/OOP-%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html"><span class="hidden-mobile">OOP-酒店管理系统</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","C++头文件包含的相关问题&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>