<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>OOP - C++笔记 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-03 17:41" pubdate>2020年12月3日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 29 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">OOP - C++笔记</h1><div class="markdown-body" id="post-body"><h3 id="错误：此声明没有存储类或类型说明符"><a href="#错误：此声明没有存储类或类型说明符" class="headerlink" title="错误：此声明没有存储类或类型说明符"></a>错误：此声明没有存储类或类型说明符</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">namespace</span> ns1 &#123;
    <span class="hljs-keyword">int</span> inflag;
&#125;
<span class="hljs-keyword">namespace</span> ns2 &#123;
    <span class="hljs-keyword">int</span> inflag;
&#125;
ns1::inflag = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 错误：此声明没有存储类或类型说明符</span>
ns2::inflag = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 错误：此声明没有存储类或类型说明符</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; ns1::inflag &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; ns2::inflag &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre><p>如果将9、10行代码移入主函数内就不会报错。</p><p>这是因为上述代码的9、10行是赋值语句，而在Cpp中<strong>函数外只能定义全局变量或者对象 ，而不能执行语句及调用函数 。</strong>因此，移到函数内，那么赋值语句是允许的。</p><h3 id="重载函数的要求"><a href="#重载函数的要求" class="headerlink" title="重载函数的要求"></a>重载函数的要求</h3><p>重载函数的参数个数或类型必须至少有其中之一不同。<strong>不允许重载的函数只有返回类型不同。</strong></p><p>函数模板不是一个实实在在的函数，<strong>编译系统并不产生任何执行代码</strong>。当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便<strong>生成一个重载函数</strong>，该重载函数的函数体与函数模板的函数体相同。</p><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>需要复制构造函数的三种情况</p><ol><li><p>新建立一个对象，需要另一个对象对其初始化</p><pre><code class="hljs cpp"><span class="hljs-function">Box <span class="hljs-title">box1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
<span class="hljs-function">Box <span class="hljs-title">box2</span><span class="hljs-params">(box1)</span></span>;</code></pre></li><li><p>对象作为形参</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Box b)</span> </span>&#123;
    ...
&#125;</code></pre></li><li><p>对象作为返回值</p><pre><code class="hljs kotlin">Box <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;
 ...
&#125;</code></pre></li></ol><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>需要在类外初始化</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x, y;
&#125;
<span class="hljs-keyword">int</span> A::x = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> A::y = <span class="hljs-number">1</span>;</code></pre><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>类内外定义均可</p><pre><code class="hljs cpp"><span class="hljs-comment">// 类内</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">number</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;
<span class="hljs-comment">// 或者类外</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::number</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;</code></pre><h3 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h3><h4 id="指向非静态成员函数的指针"><a href="#指向非静态成员函数的指针" class="headerlink" title="指向非静态成员函数的指针"></a>指向非静态成员函数的指针</h4><p>形式：数据类型名 (类名:: 指针变量名)(参数列表) = 类名::成员函数名；</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (Point::*getxP)() = Point::getX;
<span class="hljs-built_in">cout</span> &lt;&lt; (p.*getxP)() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h4 id="指向静态成员（函数）的指针"><a href="#指向静态成员（函数）的指针" class="headerlink" title="指向静态成员（函数）的指针"></a>指向静态成员（函数）的指针</h4><p>对类的静态成员的访问是不依赖于对象的，因此可以用<strong>普通的指针</strong>来指向和访问静态成员。</p><pre><code class="hljs cpp"><span class="hljs-comment">// 静态成员变量</span>
<span class="hljs-keyword">int</span> *countp=&amp;Point::count;

<span class="hljs-comment">// 静态成员函数</span>
<span class="hljs-keyword">void</span> (*gc)()=Point::GetC;
<span class="hljs-comment">// 调用</span>
(*gc)();</code></pre><h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>先调用对象成员的构造函数，再调用本类的构造函数。析构函数的调用顺序刚好相反。</p><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>在<strong>类模板外</strong>定义成员函数时，每一个函数前均加上：</p><p>template<class 类型参数></class></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载本质上是一种特殊的<strong>函数重载</strong>，运算符重载的函数参数就是该运算符涉及的操作数，因此运算符重载在参数个数上是有限制的（作为成员函数，参数最多有一个；作为友元函数，最多两个），这是它<strong>不同于普通的函数重载之处</strong>。</p><h4 id="自增运算符"><a href="#自增运算符" class="headerlink" title="自增运算符"></a>自增运算符</h4><p>++为前置运算符时，它的运算符重载函数的一般格式为：</p><p><strong><type>operator ++( )</type></strong></p><p>++为后置运算符时，它的运算符重载函数的一般格式为：</p><p><strong><type>operator ++(int)</type></strong></p><h4 id="两种重载方式"><a href="#两种重载方式" class="headerlink" title="两种重载方式"></a>两种重载方式</h4><p>当运算符重载为<strong>类的成员函数</strong>时，对于单目运算符，操作数一定是对象本身，<strong>对于双目运算符，左操作数一定是对象</strong>。</p><p>当运算符重载为友元函数时，参数中同样必须有一个是用户自定义类型的对象，<strong>但不限定其必须是左操作数</strong></p><h3 id="基本类型与类类型的转换"><a href="#基本类型与类类型的转换" class="headerlink" title="基本类型与类类型的转换"></a>基本类型与类类型的转换</h3><h4 id="基本类型到类类型"><a href="#基本类型到类类型" class="headerlink" title="基本类型到类类型"></a>基本类型到类类型</h4><p>转换构造函数，如；</p><pre><code class="hljs cpp">Complex(<span class="hljs-keyword">double</span> r) &#123;
    real = r;
    imag = <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">// 有了上述函数，以下语句即合法</span>
Complex c = <span class="hljs-number">3.14</span>;</code></pre><h4 id="类类型到基本类型"><a href="#类类型到基本类型" class="headerlink" title="类类型到基本类型"></a>类类型到基本类型</h4><p>要将类对象转换为基本类型数据，需要一个特殊的<strong>成员函数</strong>——<strong>类型转换函数</strong>（实际就是类型转换运算符的重载，也正因为其实是对运算符的重载，这一函数只能是成员函数而不能是友元函数，与因为运算符重载的对象需要this指针）。</p><pre><code class="hljs cpp"><span class="hljs-comment">// 格式  （注意，没有返回值和参数！</span>
<span class="hljs-keyword">operator</span>〈返回基本类型名〉（）
&#123;
    ……
    <span class="hljs-keyword">return</span> 〈基本类型值〉
&#125;</code></pre><p>例：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span>
    <span class="hljs-keyword">double</span> Real, Imag;

  <span class="hljs-keyword">public</span>:
	...
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//成员函数，定义类转换 Complex－&gt;double</span>
&#125;;
<span class="hljs-function">Complex::<span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; 
    <span class="hljs-keyword">return</span> Real * Real + Imag * Imag; 
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)</span></span>;
    <span class="hljs-keyword">double</span> d;
    d = <span class="hljs-number">2.5</span> + c1; <span class="hljs-comment">// 隐式调用类型转换函数</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 隐式调用类型转换函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre><h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><p>类的继承方式有public公有继承)、protected(保护继承)和private(私有继承)三种。<strong>默认情况下为私有继承</strong>。</p><p>三种继承方式下<strong>派生类中</strong>基类成员的访问控制权限</p><div class="table-container"><table><thead><tr><th></th><th>公有继承</th><th>私有继承</th><th>保护继承</th></tr></thead><tbody><tr><td>公有成员</td><td>公有</td><td>私有</td><td>保护</td></tr><tr><td>私有成员</td><td>派生类成员无法访问</td><td>派生类成员无法访问</td><td>派生类成员无法访问</td></tr><tr><td>保护成员</td><td>保护</td><td>私有</td><td>保护</td></tr></tbody></table></div><h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><h5 id="派生类调用基类的构造函数"><a href="#派生类调用基类的构造函数" class="headerlink" title="派生类调用基类的构造函数"></a>派生类调用基类的构造函数</h5><p>派生类只能在构造函数的初始化列表中调用基类的构造函数，而<strong>不能在函数体中调用</strong>。</p><pre><code class="hljs cpp">Rectangle(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height)
        :Point(x, y), w(width), h(height) &#123;&#125;  <span class="hljs-comment">// √</span>
Rectangle(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height)
        :w(width), h(height) &#123;
	Point(x, y);    <span class="hljs-comment">// ×  </span>
&#125;</code></pre><p>因为是先调用基类的构造函数再调用派生类的构造函数，而函数体就已经是在派生类的构造函数了，因此会先调用基类的默认构造函数，这里的初始化目的并没有达到，因为派生类构造函数体中的基类构造函数调用只是对一个临时对象进行了初始化（调试时发现this指针不同）。</p><h5 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h5><p>构造函数调用顺序为：基类的构造函数→对象成员构造函数→派生类的构造函数。</p><p>析构函数调用顺序刚好相反。</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表顺序无关。</p><p>如果有多个成员类对象，则构造函数的调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序。</p><p>派生类新增加的同名成员会隐藏基类中的同名成员，因此</p><pre><code class="hljs cpp"><span class="hljs-comment">// 若C是A和B的派生类且三个类都有a成员变量</span>
C c1;
c1.a = <span class="hljs-number">3</span>;    <span class="hljs-comment">//这样是修改了C类的成员</span>
<span class="hljs-comment">// 若想访问基类的成员，需要加作用域运算符</span>
c1.A::a = <span class="hljs-number">3</span>;
c1.B::a = <span class="hljs-number">3</span>;</code></pre><h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p><img src="C:\Users\10132\AppData\Roaming\Typora\typora-user-images\image-20201202170517362.png" srcset="/img/loading.gif" alt="image-20201202170517362"></p><p>这样的话C类会从A类和B类继承下来两份N类的成员，这时就无法区分了。</p><p>为了避免出现这样的二义性问题，可以将直接基类（如A、B）的共同基类（如N）设置为虚基类，这样共同基类（N）在<strong>内存中只有一个副本存在</strong>（<strong>因此其构造函数也只会调用一次</strong>）。</p><p>虚基类的定义格式为：</p><p>class &lt;派生类名&gt;: <strong>virtual</strong> &lt;继承方式&gt;&lt;共同基类名&gt;;</p><p>为了保证虚基类在派生类中只继承一次，应当在该基类的<strong>所有直接派生类</strong>中声明为虚基类。</p><h5 id="包含虚基类的构造函数调用顺序"><a href="#包含虚基类的构造函数调用顺序" class="headerlink" title="包含虚基类的构造函数调用顺序"></a>包含虚基类的构造函数调用顺序</h5><ol><li><p>先调用虚基类的构造函数，再调用非虚基类的构造函数。</p></li><li><p>若同一层次中包含多个虚基类，其调用顺序为<strong>定义时的顺序</strong>。</p></li><li><p>若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序。</p></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>从系统实现的角度，多态性分为两类：</p><ol><li><p><strong>静态多态性</strong>：在程序编译时系统就能决定调用的是哪个函数。又称为编译时的多态性。静态多态性是通过函数的重载实现的（包括运算符重载）。</p></li><li><p><strong>动态多态性</strong>：在程序运行过程中才动态地确定操作所针对的对象。又称为运行时的多态性。<strong>动态多态性是通过虚函数实现的</strong>。</p></li></ol><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>虚函数的使用：</p><ol><li>类之间应满足类型兼容原则</li><li>同名声明虚函数</li><li>通过指针、引用来访问虚函数</li></ol><p>注意，类型兼容原则是以下三种情况：</p><ol><li>派生类的对象可以赋值给基类的对象。</li><li>派生类的对象可以初始化基类的引用。</li><li>派生类的对象的地址可以赋值给基类的指针变量。</li></ol><p>而访问虚函数只能是后两者。</p><p>若要访问派生类中相同名字的函数，必须将<strong>基类中的同名函数定义为虚函数</strong>，这样，就可以动态地根据基类的引用或指针调用不同类中的函数。</p><p>一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。</p><p><strong>构造函数不能是虚函数。</strong> 虚函数作为运行时的多态性的基础，主要是针对对象的，而构造函数是在对象产生之前运行的。所以，将构造函数声明为虚函数是没有意义的。</p><p><strong>析构函数可以是虚函数</strong>。比如释放内存时，由于实施多态性时是通过将基类的指针指向派生类的对象来完成的，如果删除该指针，就会调用该指针指向的派生类的析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象才被完全释放。</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;) = 0</p><p>纯虚函数不定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>包含一个或多个纯虚函数的类称为抽象类。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a> <a class="hover-with-bg" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">面向对象程序设计</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/C/">C++</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0.html"><span class="hidden-mobile">汇编实验：统计数字个数</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","OOP - C++笔记&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>