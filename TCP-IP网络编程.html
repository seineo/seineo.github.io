<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>TCP/IP网络编程 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-04-11 19:13" pubdate>2021年4月11日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 56 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">TCP/IP网络编程</h1><div class="markdown-body" id="post-body"><h2 id="理解网络编程和套接字"><a href="#理解网络编程和套接字" class="headerlink" title="理解网络编程和套接字"></a>理解网络编程和套接字</h2><p>我们使用套接字完成网络的数据传输，为什么要用“套接字”这个词呢？我们把插头插在插座上就能获取电力供给，同样，使用套接字就可以连接到网络。</p><h3 id="构建接电话套接字"><a href="#构建接电话套接字" class="headerlink" title="构建接电话套接字"></a>构建接电话套接字</h3><p>我们可以用<strong>TCP套接字</strong>比喻成电话机。</p><ol><li><p>socket函数 &lt;-&gt;准备电话机（不同的在于电话机购买好后，安装和电话号码的分配交给电信局的人完成，而套接字需要我们自己安装和分配地址等）</p></li><li><p>bind函数 &lt;-&gt; 分配电话号码（套接字是分配ip地址和端口号）</p></li><li><p>listen函数 &lt;-&gt; 连接电话线（是套接字转为可接受连接的状态）</p></li><li><p>accept函数 &lt;-&gt;拿起话筒进行交流（套接字接受了对方的连接请求，开始通信）</p></li></ol><h3 id="构建打电话套接字"><a href="#构建打电话套接字" class="headerlink" title="构建打电话套接字"></a>构建打电话套接字</h3><p>上述是服务端的套接字，下面介绍用于请求连接的客户端套接字。</p><p><strong>第一步</strong>一致，然后就只需要直接向服务端发送连接请求即可（地址调用connect函数时会分配）。</p><p>connect函数 &lt;-&gt; 打电话（请求连接）</p><h3 id="套接字与文件"><a href="#套接字与文件" class="headerlink" title="套接字与文件"></a>套接字与文件</h3><p>在linux的世界里，socket被认为是文件的一种，因此在网络传输过程中也可以使用文件I/O的相关函数。</p><p>文件描述符是一个整数，只不过是为了方便称呼操作系统中的各个文件而赋予的数而已。</p><h2 id="套接字类型与协议设置"><a href="#套接字类型与协议设置" class="headerlink" title="套接字类型与协议设置"></a>套接字类型与协议设置</h2><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>socket函数创建套接字，返回套接字的文件描述符。参数为：</p><ul><li>domain：协议族</li><li>type：传输方式</li><li>protocol：协议</li></ul><h4 id="协议族-Protocol-Family"><a href="#协议族-Protocol-Family" class="headerlink" title="协议族(Protocol Family)"></a>协议族(Protocol Family)</h4><p>套接字通信中协议具有一些分类，以下是常用的两个分类（其余此处忽略）：</p><ul><li>PF_INET：IPv4协议族</li><li>PF_INET6：IPv6协议族</li></ul><h4 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h4><p>即套接字的数据传输方式，作为socket函数的第二个参数传递。已通过第一个参数传输了协议族，还需要决定传输方式？问题就在于一个协议族中也存在多种数据传输方式。</p><p>以下有两种具有代表性的传输方式：</p><ul><li>SOCK_STREAM：面向连接（基于流）的套接字（一般为TCP），可靠的、按序传递的、基于字节的。</li><li>SOCK_DGRAM：面向消息的套接字（一般为UDP），不可靠的、不按序传递的、以数据的高速传输为目的的。</li></ul><h4 id="协议的最终选择"><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h4><p>一般而言传输前两个参数即可创建所需套接字，因此大部分情况下向第三个参数传递0即可。</p><p>除非遇到同一个协议族中存在多个数据传输方式相同的协议，这时我们就需要指定，如：</p><ul><li>IPPROTO_TCP</li><li>IPPROTO_UDP</li></ul><h2 id="地址族与数据序列"><a href="#地址族与数据序列" class="headerlink" title="地址族与数据序列"></a>地址族与数据序列</h2><h3 id="分配给套接字的IP地址和端口号"><a href="#分配给套接字的IP地址和端口号" class="headerlink" title="分配给套接字的IP地址和端口号"></a>分配给套接字的IP地址和端口号</h3><p>IP地址是为收发网络数据而分配给计算机的值，而端口号是为了区分程序中创建的套接字而分配给套接字的序号。</p><h3 id="地址信息的表示"><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h3><h4 id="表示IPv4地址的结构体"><a href="#表示IPv4地址的结构体" class="headerlink" title="表示IPv4地址的结构体"></a>表示IPv4地址的结构体</h4><p><code>sockaddr_in</code>结构体定义的协议族、ip地址和端口号，可作为地址信息传输给bind函数。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span>
    <span class="hljs-keyword">sa_family_t</span>    sin_family;  <span class="hljs-comment">// 地址族</span>
    <span class="hljs-keyword">uint16_t</span>       sin_port;    <span class="hljs-comment">// 16位端口号</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>    <span class="hljs-comment">// 32位ip地址</span>
    <span class="hljs-keyword">char</span>           sin_zero[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 不使用</span>
&#125;</code></pre><p>而其中的<code>in_addr</code>结构体用于存放ip地址：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span>
    <span class="hljs-keyword">in_addr_t</span>     s_addr;      <span class="hljs-comment">// 32位ipv4地址</span>
&#125;</code></pre><p><code>sockaddr_in</code>中的<code>sin_zero</code>成员是该结构体用于和<code>sockaddr</code>结构体大小保持一致而插入的，必须填充为0，否则无法使用。</p><p>为什么需要与<code>sockaddr</code>一致呢？而<code>sockaddr</code>又是什么？实际上，bind函数的第二个参数期望的就是<code>sockaddr</code>结构体变量的地址，其结构如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span>
    <span class="hljs-keyword">sa_family_t</span> sin_family;   <span class="hljs-comment">// 地址族</span>
    <span class="hljs-keyword">char</span>        sa_data[<span class="hljs-number">14</span>];  <span class="hljs-comment">// 地址信息</span>
&#125;</code></pre><p>可以发现，<code>sockaddr</code>结构体将ip地址和端口号等信息都存在<code>sa_data</code>数组中，不方便程序员操作，因此就有了<code>sockaddr_in</code>结构体，方便操作，按之前说的方法填充<code>sockaddr_in</code>则可以生成符合bind函数要求的字节流。</p><h4 id="sockaddr-in的成员分析"><a href="#sockaddr-in的成员分析" class="headerlink" title="sockaddr_in的成员分析"></a>sockaddr_in的成员分析</h4><ul><li>sin_family：每种协议族适用的地址族不同，常见的两种为<code>AF_INET</code>（IPv4的地址族）和<code>AF_INET6</code>（IPv6的地址族）</li><li>sin_port：保存16位端口号，<strong>注意：它以网络字节序保存</strong></li><li>sin_addr：保存32位ip地址，也以网络字节序保存</li></ul><h3 id="网络字节序与地址变换"><a href="#网络字节序与地址变换" class="headerlink" title="网络字节序与地址变换"></a>网络字节序与地址变换</h3><h4 id="字节序与网络字节序"><a href="#字节序与网络字节序" class="headerlink" title="字节序与网络字节序"></a>字节序与网络字节序</h4><p>CPU向内存保存数据的方式有两种：</p><ul><li>大端序：高位字节存放在低位地址</li><li>小端序：高位字节存放在高位地址</li></ul><p>不同的CPU保存方式不同（虽然主流的intel系列CPU使用小端序保存），因此不同计算机间数据传输时要有统一的标准，即网络字节序：大端序。</p><h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> short <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short)</span></span>;   
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> short <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> short)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)</span></span>;</code></pre><p>h -&gt; host，to -&gt; 转换， n -&gt; network，s -&gt; short， l -&gt; long。</p><p>short用于端口号的转换，long用于ip地址转换。</p><p><strong>除了向<code>sockaddr_in</code>结构体填充数据时需要注意，其他情况无需考虑字节序的问题</strong>。</p><h3 id="网络地址的初始化与分配"><a href="#网络地址的初始化与分配" class="headerlink" title="网络地址的初始化与分配"></a>网络地址的初始化与分配</h3><h4 id="字节序-字符串转整型"><a href="#字节序-字符串转整型" class="headerlink" title="字节序 - 字符串转整型"></a>字节序 - 字符串转整型</h4><p>inet_addr函数完成这一转换，接受点分十进制的字符串，返回整型数据，<strong>注意：该整型数据就是满足网络字节序的</strong>。</p><p>inet_aton与inet_addr在功能上完全相同，只不过该函数利用了in_addr结构体，更常用：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr_inet</span>;</span>
inet_aton(addr, &amp;addr_inet.sin_addr); <span class="hljs-comment">// 若成功（返回1，失败返回0），结果写入addr_inet.sin_addr.s_addr</span>
...</code></pre><p>ienet_ntoa与inet_aton功能相反。</p><p>n -&gt; num， a -&gt; address。</p><h4 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h4><p>常见的初始化方法如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span>
<span class="hljs-keyword">char</span> *serv_ip = <span class="hljs-string">"211.217.168.13"</span>;
<span class="hljs-keyword">char</span> *serv_port = <span class="hljs-string">"9190"</span>;
<span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(addr)); <span class="hljs-comment">// 主要是为了将sin_zero清零</span>
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = inet_addr(serv_ip);
addr.sin_port = htons(atoi(serv_port));</code></pre><p>每次初始化都需要输入ip地址会比较繁琐，因此我们可以使用<code>INADDR_ANY</code>来初始化ip地址：</p><pre><code class="hljs c">addr.sin_addr.s_addr = htonl(INADDR_ANY);</code></pre><p>若采用这种方法，则可以自动获取服务端的ip地址，不必亲自输入，且如果计算机有多个ip地址（即有多个网卡的计算机），那么只要端口号一致，就可以从不同的ip地址接收数据。</p><h2 id="基于TCP的服务端-客户端"><a href="#基于TCP的服务端-客户端" class="headerlink" title="基于TCP的服务端/客户端"></a>基于TCP的服务端/客户端</h2><h3 id="函数调用顺序"><a href="#函数调用顺序" class="headerlink" title="函数调用顺序"></a>函数调用顺序</h3><p>服务端：socket -&gt; bind -&gt; listen -&gt; accept -&gt; read/write -&gt; close</p><p>客户端：socket-&gt; connect -&gt; read/write -&gt; close</p><p>调用bind函数给套接字分配地址后，就需要通过listen函数进入等待连接请求状态。只有调用了listen函数，客户端才可以进入可发出连接请求的状态，即这时候才能调用connect函数，之前调用会发生错误。</p><p>另外，connect函数成功了并不是已经建立连接开始通信了，只是进入了服务端的等待队列（listen函数的第二个参数表明了这一队列的长度），accept函数被调用后才是进行通信。</p><p>accept函数会自动创建一个新的套接字用于连接发起请求的客户端进行通信。为什么不用服务端的套接字呢？因为客户端的连接请求也属于从网络接收到的数据，而要接受数据就需要套接字，服务端的套接字就是用来接受请求的。</p><p><strong>客户端套接字地址在哪？</strong></p><p>connect函数参数只有套接字的文件描述符和目标地址，并未出现套接字地址的分配，不需要分配ip和端口吗？不是的，在调用connect函数时，内核会自动分配ip和端口，ip即主机的ip，端口随机。</p><h3 id="粘包-拆包"><a href="#粘包-拆包" class="headerlink" title="粘包/拆包"></a>粘包/拆包</h3><p><strong>注意：编写代码时需要注意TCP的粘包、拆包问题（要意识到TCP是面向字节流的协议，无消息边界）</strong></p><pre><code class="hljs cpp">write(sock, message, <span class="hljs-built_in">strlen</span>(message));
str_len = read(sock, message, BUF_SIZE - <span class="hljs-number">1</span>);
message[str_len] = <span class="hljs-number">0</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"message: %s"</span>, message);</code></pre><p>以上代码就是错误假设了：“每次调用read、write函数时都会以传入的字符串为单位执行实际的I/O操作”。</p><p>实际上，有可能多次write函数传递的字符串一次性传到服务端，也有可能字符串太长，它拆分成了两个数据包进行传送。read也是一样，我们并不一定能一次读出期望长度的字符串。</p><p>为了解决这一问题，就需要应用层定义消息边界，可以是定长的（读取一定长度的字符串才结束），也可以是不定长的（定义结束符或加入表示长度的字段）。</p><h3 id="TCP套接字的I-O缓冲"><a href="#TCP套接字的I-O缓冲" class="headerlink" title="TCP套接字的I/O缓冲"></a>TCP套接字的I/O缓冲</h3><p>如前所述，TCP套接字数据收发没有边界，服务端调用1次write函数传输40字节数据，客户端也有可能通过4次read函数调用每次读取10字节。那么当第一次客户端接受10字节后，剩余的30字节存放在哪里呢？</p><p>实际上，内核为TCP套接字维护输入缓冲区与输出缓冲区，write函数调用只是将数据从进程的缓冲区移到输出缓冲区，在适当的时候传向对方的输入缓冲区；而read函数调用只是从输入缓冲区移动到进程的缓冲区。</p><p>I/O缓冲特性如下：</p><ul><li>I/O缓冲在每个TCP套接字中单独存在</li><li>I/O缓冲在创建套接字时自动生成</li><li>即使关闭套接字也会继续传递输出缓冲中遗留的数据</li><li>但关闭套接字会丢失输入缓冲的数据</li></ul><p>那么如果“客户端输入缓冲只有50字节，但服务端传输了100字节”呢？会丢失数据吗？</p><p>不会，因为TCP有流量控制。</p><h2 id="基于UDP的服务端-客户端"><a href="#基于UDP的服务端-客户端" class="headerlink" title="基于UDP的服务端/客户端"></a>基于UDP的服务端/客户端</h2><p>UDP可靠性比不上TCP，但是也不会像想象中的那么频繁的丢失数据，因此在更重视性能而非可靠性的情况下，UDP是一个很好的选择。比如要通过网络实时传输视频时，对于多媒体数据而言丢失一部分也没有太大问题，但要提供实时服务，速度是十分重要的因素，这时候就需要考虑使用UDP。</p><h3 id="函数调用顺序-1"><a href="#函数调用顺序-1" class="headerlink" title="函数调用顺序"></a>函数调用顺序</h3><p>由于UDP没有连接，因此UDP中只有创建套接字和数据交换的过程。</p><p>TCP中，套接字之间是一对一的关系，若需要向10个客户端提供服务，除了用于接受连接请求的服务端套接字外，还需要10个用于通信的套接字。而在UDP中，不管是服务器还是客户端都只需要1个套接字。我们可将收发信件使用的邮筒比作UDP套接字，只要附近有1个邮筒，就可以通过它向任意地址寄出邮件，同理，只要1个UDP套接字就可以向任意主机传输数据。</p><p>服务端：socket -&gt; bind -&gt; recvfrom/sendto -&gt; close</p><p>客户端：socket -&gt; sendto/recvfrom -&gt; close</p><p><strong>客户端套接字的地址会由sendto函数自动分配。</strong></p><h3 id="UDP存在数据边界"><a href="#UDP存在数据边界" class="headerlink" title="UDP存在数据边界"></a>UDP存在数据边界</h3><p>输入函数的调用次数会与输出函数的调用次数完全一致，这样才能保证接受全部已发送的数据。</p><p>例如，我们在客户端调用了三次输出函数，而在服务端先调用<code>sleep</code>沉睡了5秒，那么如果是TCP，我们也许一次就可以读取完成，但是如果是UDP，我们必须还是调用三次的输入函数才能读取完成。</p><h3 id="UDP的连接"><a href="#UDP的连接" class="headerlink" title="UDP的连接"></a>UDP的连接</h3><p>UDP通过修改sendto函数的目标ip参数，可以重复利用同一个UDP套接字向不同的目标传输数据，每次传输过程分为以下三个阶段：</p><ol><li>向UDP套接字注册目标ip和端口</li><li>传输数据</li><li>删除注册的目标ip和端口</li></ol><p>那如果我们是想与同一主机进行长时间的通信，每次传输的第一和第三阶段都很耗时且没必要，此时将UDP套接字变成已连接的套接字会提高效率。</p><p>创建已连接的UDP套接字只需要调用connect函数即可，针对UDP调用connect函数并不意味着要与对方的UDP套接字连接，而只是注册目标ip和端口信息。</p><h2 id="优雅地断开套接字连接"><a href="#优雅地断开套接字连接" class="headerlink" title="优雅地断开套接字连接"></a>优雅地断开套接字连接</h2><p>套接字是双向通信，因此有两个流：输入流和输出流，而linux中的close函数是同时断开了两个流。当主机A发送完最后的数据后，调用close函数，其他主机发送给主机A的数据也就都被丢弃了。</p><p>因此引入了shutdown函数来实现“半关闭”：只关闭一半的流。</p><p>第一个参数为套接字，第二个参数即为断开连接的方式：</p><ul><li>SHUT_RD：只断开输入流</li><li>SHUT_WR：只断开输出流</li><li>SHUT_RDWR：同时断开两个流</li></ul><h2 id="域名与网络地址"><a href="#域名与网络地址" class="headerlink" title="域名与网络地址"></a>域名与网络地址</h2><p>由于服务器的域名基本不会变，而其IP地址会相对频繁的改变，那么为了给用户提供便利的运行方法，我们就需要程序可以由输入的域名转为实际的ip地址进行通信。</p><p>利用域名获取ip地址：gethostbyname</p><p>利用ip地址获取域名：gethostbyaddr</p><p>返回值均为<code>struct hostent*</code>，这一结构体定义如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> &#123;</span>
    <span class="hljs-keyword">char</span> *h_name;   <span class="hljs-comment">// 官方域名</span>
    <span class="hljs-keyword">char</span> **h_aliases;  <span class="hljs-comment">// 别名链表</span>
	<span class="hljs-keyword">int</span> h_addrtype;   <span class="hljs-comment">// 主机的地址类型，如果是ipv4，则存储AF_INET</span>
    <span class="hljs-keyword">int</span> h_length;   <span class="hljs-comment">// 地址长度</span>
    <span class="hljs-keyword">char</span> **h_addr_list;   <span class="hljs-comment">// 地址链表</span>
&#125;</code></pre><p>注意：地址链表存的地址是<code>char*</code>类型而不是<code>struct in_addr*</code>类型，这是因为这一结构体并不是只为了IPv4准备的，为了通用性便使用了<code>char*</code>类型，那为什么不用<code>void*</code>呢？这是因为套接字的相关函数是在<code>void*</code>标准化前定义的，当时通用类型是采用<code>char*</code>指针。</p><p>在使用<code>inet_ntoa</code>时就需要将<code>char*</code>转为<code>struct in_addr*</code>。</p><h2 id="套接字的多种选项"><a href="#套接字的多种选项" class="headerlink" title="套接字的多种选项"></a>套接字的多种选项</h2><p>读取选项：getsockopt</p><p>设置选项：setsockopt</p><p>函数需要制定协议层和对应层中的选项，协议层有套接字层（SOL_SOCKET）、IP层（IPPROTO_IP）和TCP层（IPPROTO_TCP），我们这里主要说明套接字和TCP层的几个重要选项。</p><h3 id="SO-TYPE"><a href="#SO-TYPE" class="headerlink" title="SO_TYPE"></a>SO_TYPE</h3><p>整形变量，说明套接字的类型，1是TCP，2是UDP。</p><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><p>是输入输出缓冲区大小相关的选项，每个机器都不同，我机器上的输入缓冲是13万多字节，而输出缓冲仅有1万多字节。当然缓冲区的大小也是可以修改的，但我们给定的大小只是建议，因为缓冲大小的设置需谨慎处理，由系统决定。</p><h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>服务端（主动方）在和客户端（被动方）已建立连接的情况下，强制关闭服务端，然后重新运行服务端，会报错：bind函数运行异常，但过了几分钟又可以重新运行，这是为什么呢？</p><p>服务端（主动方）在四次握手中接收到客户端（被动方）主动发送的FIN报文后就会进入Time-wait状态，时间持续2个MSL（最大报文存活时间），这是为了确认客户端（被动方）能收到服务端（主动方）对这个FIN报文的ACK。</p><p>TIme-wait看似重要，但却不一定讨人喜欢，比如我们服务器发生故障重启，却还需要等待几分钟才能重新运行，这是不合理的。</p><p>解决方案就是修改套接字的SO_REUSEADDR选项。我们将SO_REUSEADDR选项修改为1（true），就可以将<strong>地址重分配</strong>，即把Time-wait状态下的套接字端口号重新分配给新的套接字使用，这样服务端就变成了随时可运行的状态。</p><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><p>这一TCP选项涉及Nagle算法，这一算法是为了防止数据报过多而导致网络过载而设计的。</p><p>如果不使用Nagle算法，数据到达输出缓冲后就立即发送出去，即使该数据仅有一个字节，都需要用几十字节的首部包装然后发送，这样网络的传输效率并不高。</p><p>而Nagle算法只有<strong>当收到了前一数据的ACK</strong>或<strong>当前输出缓冲中的数据的大小已到达了MSS</strong>（最大报文段长度）才可以发送当前数据。</p><p>Nagle算法可以充分地利用缓冲，但是会造成一定程度的延迟。根据传输数据的特性，若数据较大，典型的是传输大文件的数据，即便不使用Nagle算法，也会在装满输出缓冲时传输数据包，这时在不需ACK的情况下连续传输，可以大大提高传输速率。因此，要准确的判断数据的特性，不应胡乱使用或禁用Nagle算法。</p><p>Nagle算法默认是开启的，如果想禁用，则将TCP协议层的TCP_NODELAY选项置为1即可，但<strong>注意：TCP_NODELAY选项在<code>netinet/tcp.h</code>头文件中</strong>。</p><h2 id="多进程服务端"><a href="#多进程服务端" class="headerlink" title="多进程服务端"></a>多进程服务端</h2><p>之前的服务器只能同时给一个客户端服务，其他的需要排队，这样的用户体验是很不好的，为了同时向多个客户端提供服务，有以下三种具有代表性的并发服务端实现方法：</p><ul><li>多进程服务器</li><li>多路复用服务器</li><li>多线程服务器</li></ul><p>我们这里先讲解第一种：多进程服务器，通过为每个请求的客户端创建一个进程提供服务。</p><p>我们使用父进程受理客户端的连接请求，然后为每个连接请求创建一个子进程处理实际的连接通信。这其中设计两个主要的问题：</p><ol><li>如何向子进程传递accept函数返回的用于通信的套接字？</li><li>子进程是否可能变为僵尸进程？如何避免？</li></ol><p>对于第一个问题，因为子进程会赋值父进程拥有的资源，因此实际上根本不需要手动传递的过程。</p><h3 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h3><p>而对于第二个问题，首先什么是僵尸进程？为什么会产生它？僵尸进程就是当完成了执行，但在操作系统的进程表中仍然存在这一进程的表项，处于终止状态的进程。它的产生是由于操作系统在一个进程运行结束后并不会立即销毁它，而是等待它的父进程回收（即获取子进程的退出状态）后才销毁（从进程表中删除该表项），因此如果父进程并没有主动回收它的子进程，这一进程就会变为僵尸进程。</p><p>如何避免这一状况呢？这就分为了预防和解决，预防如下：</p><ol><li>父进程调用wait/waitpid函数等待子进程的结束，但这样父进程会被阻塞（除非选项设为WNOHANG，但也不方便）</li><li>注册SIGCHLD信号的处理函数，当父进程收到该信号时再去处理</li></ol><p>出现僵尸进程后的解决办法：</p><p>杀死父进程，这样子进程（也就是该僵尸进程）就变为了孤儿进程，会过继给init进程，由init进程负责回收。</p><p>这里要注意：<strong>僵尸进程并不等同于孤儿进程</strong>，孤儿进程是父进程结束后仍在运行的进程，它不会是僵尸进程， 因为它产生时会立即由init进程收养。</p><h3 id="基于多任务的并发服务器"><a href="#基于多任务的并发服务器" class="headerlink" title="基于多任务的并发服务器"></a>基于多任务的并发服务器</h3><p>需要注意套接字文件描述符的关闭问题。套接字是一种文件，而fork函数使得子进程复制了父进程的文件描述符，因此父进程和子进程各有一个相同但独立的套接字文件描述符指向服务端的套接字（也算是打开文件），客户端同理。只有所有指向该套接字的文件描述符都被销毁后（即打开文件的引用计数变为0），该套接字才会被销毁。示例代码如下：</p><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
    ...
    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程运行区域</span>
    	<span class="hljs-built_in">close</span>(serv_sock);  <span class="hljs-comment">//关闭子进程中的服务端套接字</span>
    	<span class="hljs-keyword">while</span> ((str_len = reaD(clnt_sock, buf, BUF_SIZE)) != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 连接存在</span>
        	<span class="hljs-built_in">write</span>(clnt_sock, buf, str_len);
    	&#125;
    	<span class="hljs-built_in">close</span>(clnt_sock);  <span class="hljs-comment">// 关闭子进程中的客户端套接字</span>
    	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
    	<span class="hljs-built_in">close</span>(clnt_sock);  <span class="hljs-comment">// 关闭父进程中的客户端套接字</span>
	&#125;
&#125;
<span class="hljs-built_in">close</span>(serv_sock);  <span class="hljs-comment">// 最终关闭父进程中的服务端套接字</span></code></pre></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">TCP/IP网络编程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><span class="hidden-mobile">组成结构与操作系统</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","TCP/IP网络编程&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>