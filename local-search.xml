<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>组成结构与操作系统</title>
    <link href="/%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
    <url>/%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
    
    <content type="html"><![CDATA[<p>最近在进行计算机组成结构与操作系统的查漏补缺，部分知识点纪录在此。</p><h1 id="位级表示"><a href="#位级表示" class="headerlink" title="位级表示"></a>位级表示</h1><h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h2><p>无符号数就是纯二进制表示，而有符号数有多种表示方法：原码、反码和补码，现大多使用补码。正是因为有符号数有多种表示方法，C++中如果对一个有符号数赋予超出表示范围的值，其结果是未定义的，因为不知道如何解释这个值。</p><p>原码和反码都是需要考虑符号的，而且0有正0和负0之分，因此不方便计算也不统一。反码英文是one’s complement，即1的补码，也就是取反，而补码的英文是two’s complement，但不是2的补码，而是2^w^的补码，其中w是该数二进制表示的位数，也就是说一个负数-x，它的补码表示是2^w^ - x，计算方法简记为<code>取反加一</code>。以-1的补码为例，也就是求正数1对2^w^的补码：</p><pre><code class="hljs shell">  1 0 0 0 0-   0 0 0 1-------------  0 1 1 1 1</code></pre><p>而取反加一也刚好是这个结果，所以一般教的计算方法都是取反加一。</p><h2 id="二进制与十进制的转换"><a href="#二进制与十进制的转换" class="headerlink" title="二进制与十进制的转换"></a>二进制与十进制的转换</h2><ol><li><p>正整数转二进制：</p><p>除二取余，倒序排列</p></li><li><p>小数转二进制</p><p>对小数点后的数乘以2，取结果的整数部分，以此类推，直到小数部分为0或精度足够</p></li><li><p>二进制转十进制</p><p>位上的值与对应权值（基数为2）相乘并累加</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="浮点数与整数直接类型转换"><a href="#浮点数与整数直接类型转换" class="headerlink" title="浮点数与整数直接类型转换"></a>浮点数与整数直接类型转换</h3><p>旧C++、C语言中：(type)val</p><p>现代C++中：static_cast\<type \>(val)</type></p><p><strong>（以下知识在深入理解计算机系统中有涉及）</strong></p><p>整数存储在通用寄存器中，浮点数存储在xmm寄存器（是ymm寄存器的低16字节）中。它们之间的强制类型转换有对应的机器指令。</p><p>浮点数转成整数是直接截断，向0舍入；而整数转成浮点数便是根据IEEE的浮点数位表示标准进行转换。</p><h3 id="用指针进行类型转换"><a href="#用指针进行类型转换" class="headerlink" title="用指针进行类型转换"></a>用指针进行类型转换</h3><p>旧C++、C语言中：(type*)&amp;val</p><p>现代C++中：reinterpret_cast\<type *\>(&amp;val)</type></p><p>不是直接对值的类型转换，那样也许会改变底层的位表示。而是不改变底层的位表示，而是用另一种类型的方法去解释底层的位表示：<a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">例子</a></p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在进程模型中，计算机上所有可运行的软件，包括操作系统，都称为进程。</p><p>进程是一个正在执行的程序的实例，包括程序计数器、寄存器等程序运行需要的资源。</p><h3 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h3><p>具体区别 1 2 3?</p><p>例子：</p><p>我正在根据参考答案用红笔修改做过的作业，这里参考答案就是程序，红笔和我做过的作业就是相关的资源，我就是CPU，那么进程就是我阅读参考答案，比照我写的答案，用红笔进行修改的这一系列动作的总和。</p><p>而如果现在面试官打电话叫我面试，那我就记录下我改到的位置（保存进程当前状态），然后接电话根据我以前学习的知识回答面试官的问题。这里处理机就是从一个进程切换到了一个高优先级的进程，每个进程都拥有各自的程序（参考答案和我学习过的知识）。面试完后，我又回来继续改作业，从刚才改到的位置继续下去。</p><p>值得注意的是：<strong>一个程序运行两遍，算作两个进程</strong>。比如我们可以运行两次自己写的代码，其中用<code>getpid</code>获得当前进程的pid，我们会发现每次运行输出的pid不同。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>unix系统中只有一个系统调用可以用来创建新进程：fork，创建出来的子进程通常还会接着执行execve来修改其内存映像并运行一个新程序。之所以要安排两步来建立进程，是为了在fork之后但在execve之前允许该子进程修改其文件描述符，这样可以完成输入输出的重定向。</p><p>具体原因其实还是历史遗留，当时fork和execve刚设计时还没有进程和线程的概念，execve就是会直接把shell的内存修改以执行新的程序，但这样要每次重新加载shell，于是fork就出现了，复制一份shell的内存映像、文件描述符等，用execve执行新任务而对shell本身没有影响。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>如：</p><pre><code class="hljs shell">ps aux &gt; 1.txt</code></pre><p>shell会先fork出一个自身的进程，然后将文件描述符1从标准输出改为输出到1.txt，再使用execve执行ps这个命令，ps直接输出即可，结果就是输出到1.txt中了。</p><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在unix中，进程和他的所有子进程以及后裔共同组成一个进程组。</p><p>init进程会出现在启动映像中，当它开始运行时，读入一个说明终端数量的文件，接着为每个终端创建一个新的进程。这些进城等待用户登录，登录成功后，登录进程就会执行shell准备接受命令，接受的这些命令又会启动更多的进程。这样，所有进程都属于以init为根的一棵进程树。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程有三个状态：</p><ol><li>运行态（占用cpu）</li><li>就绪态（可运行，但是由于其他进程占用cpu而暂时停止）</li><li>阻塞态（不能运行，等待某些事件发生才可运行，如等待用户输入）</li></ol><p>unix中当一个进程从管道或其他设备读取数据时，如果暂时没有有效的输入，进程会被自动阻塞（为什么会暂时没有有效输入？这是由命令的执行时间以及分配到的cpu时间决定的）。</p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为每个进程维护一个表格，即进程表，包含程序计数器、寄存器、堆栈指针、文件描述符、用户和调度信息等，这些信息可以保证该进程能在状态切换或中断后能再次启动，像什么也没发生一样。</p><h3 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h3><p>采用多道程序设计可以提高CPU的利用率。</p><p>我们使用概率的角度来看CPU的利用率。假设一个进程等待IO操作的时间与其停留在内存中的时间的比为p，那么当内存中同时有n个进程时，所有n个进程都在等待IO（即CPU空转）的概率是p^n^，CPU的利用率=1-p^n^。n称为多道程序设计的道数。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>进程是资源分配的最小单位，而线程是资源调度的最小单位。<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><p>线程</p><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><p>主要原因：许多应用中同时存在着多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解为可以和所有准并行运行的多个线程，程序设计、用户体验和性能会变得更好。</p><ol><li>多个线程拥有共享同一地址空间和所有可用数据的能力</li><li>线程比进程更轻量级，创建一个线程比创建一个进程要快10~100倍</li><li>如果存在大量的计算和大量的IO处理，多线程允许这些活动彼此重叠进行，从而加快执行速度</li></ol><p>例子：</p><p>一个字处理程序，需要与用户交互，当用户修改后还需要重新格式化文件。如果是单线程程序，用户修改后，程序马上去格式化，如果是大文件，则时间较长无法响应用户的其他需求。但如果我们程序有两个线程，一个线程与用户交互，另一个在后台格式化处理。当用户修改后，交互的线程通知后台线程进行格式化处理，期间交互线程仍可以响应用户的一些简单命令，也许当用户请求查看格式化好的文件时已经格式化好了，用户的体验也就更好。我们还可以再添加一个线程用于文件的备份，该线程周期性地保存文件内容。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>每个线程都有自己的堆栈，因为通常每个线程都会各自调用不同的过程，从而有一个不同的执行历史。</p><p>在多线程的情况下，进程通常会从当前的单个线程开始，这个线程有能力创建新的线程，新线程自动在创建线程的地址空间运行。通常线程没有层次关系，所有线程都是平等的（有时候会具有父子关系）。</p><h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>在unix中，有一个通用的线程包pthread，以下是其中常用的函数调用：</p><div class="table-container"><table><thead><tr><th>pthread_create</th><th>创建新线程</th></tr></thead><tbody><tr><td>pthread_exit</td><td>结束调用的线程</td></tr><tr><td>pthread_join</td><td>等待一个特定线程退出</td></tr><tr><td>pthread_yield</td><td>让出cpu来运行另一线程</td></tr></tbody></table></div><h3 id="用户级线程与内核级线程"><a href="#用户级线程与内核级线程" class="headerlink" title="用户级线程与内核级线程"></a>用户级线程与内核级线程</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>将线程包放在用户空间中，内核对线程包一无所知。从内核角度看，就是按正常的单线程进程管理。在用户控件管理线程，每个进程都需要有一张线程表，用来跟踪与记录各线程的属性，如程序计数器，堆栈指针等，以便后续线程状态切换的复原。</p><p>用户级线程的切换可以在几条指令内完成，比内核级至少快一个数量级。</p><p>用户级线程的一个问题是实现阻塞系统调用，如果线程实际进行会阻塞的系统调用，则所有线程会停止（因为用户级线程是进程内线程调度）。因此，有许多方法被提出，如使用非阻塞的系统调用，或阻塞前通知替换等。</p><p>还有一个问题就是，由于在一个单独的进程内部是没有时钟中断（因为时钟中断是硬中断，进入内核态后因为系统按单线程进程管理，所以对内部的线程是无法处理的）的，所以用户级线程包中一旦一个线程开始执行，那么该进程中其他线程就不能运行，除非第一个线程主动放弃CPU或运行结束。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>每个进程不再有线程表，相反，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建或撤销一个线程时，它进行一个系统调用，这个系统调用是通过更新线程表来完成的。</p><p>所有阻塞线程的调用都以系统调用的形式实现，不需要任何新的非阻塞系统调用，缺点就是系统调用的代价比较大。</p><h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>有三个问题：</p><ol><li>信息传递</li><li>互斥</li><li>同步</li></ol><p>第一个问题对线程来说比较容易，因为它们共享同一个地址空间，但另外两个问题和对应的解决方法同样适用于线程。</p><h3 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h3><p>竞争条件：多个进程读写共享数据，其最后的结果取决于进程运行的精确时序。</p><p>互斥（mutual exclusion）：以某种手段确保当一个进程在读写一个共享数据时，其他进程不能做同样的操作。</p><p>临界区：对共享内存进行访问的<strong>程序片段</strong>。</p><p>如果能使两个进程不可能同时处在临界区，那么就能避免竞争条件。</p><p><strong>典型问题</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者-消费者问题</a>（仔细阅读，有错误实例、伪代码与解析）</p><p><a href="https://shivammitra.com/c/producer-consumer-problem-in-c/" target="_blank" rel="noopener">使用信号量与互斥量的C代码</a></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>用于解决进程同步或互斥问题而引入的整型变量。</p><p>对于生产者-消费者问题而言，信号量mutex用于互斥，fill和empty用于同步。</p><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>如果不需要信号量的<strong>计数能力</strong>，有时候可以使用信号量的简化版本，即互斥量（其实就是二进制信号量）。对于生产者-消费者问题，这只能用于解决缓冲区大小为1的情况。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>任意时刻管程中只会有一个活跃进程，这一特性使得管程能有效地完成互斥，这是编译器的任务。由于无需考虑互斥问题，我们只需关心如何让进程在无法继续时阻塞，方法仍然是上述的条件变量。</p><p>管程是编程语言的组成部分，java中便有管程，但是c和c++没有，因此这里不做过多的探讨。</p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>是系统调用，而不属于具体语言。</p><p>通常会在并行程序设计系统中使用消息传递，这里不做过多的探讨。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h3><ol><li>创建新进程后，需要决定先运行父进程还是子进程</li><li>一个进程退出时，一般会选择一个就绪的进程，如果没有，则运行系统提供的一个空闲进程。</li><li>一个进程被阻塞后，需要选择另一个进程运行</li><li>IO中断发生时，一般这时候某些被阻塞的进程就会称为可运行的就绪进程了。</li></ol><p>如果硬件时钟提供周期性的中断，可以在每k个时钟中断时做出调度决策。</p><p>根据如何处理时钟中断，可将调度算法分为两类：抢占式与非抢占式。</p><p>非抢占式调度算法调度一个进程，然后让该进程运行直至被阻塞或自动释放CPU，它不会被强制挂起，因此在时钟中断时不会发生进程调度，在处理完时钟中断后，如果没有更高优先级的进程到达，被中断的进程会继续运行。</p><p>而抢占式调度算法会让进程运行某个固定时段的最大值，到时间后如果该进程还在运行则将其挂起，挑选另一个进程运行。要进行抢占式调度，就需要在该时段的末端发生时钟中断，以便把CPU控制返回给调度程序。</p><p>当然，如果没有可用的时钟，则只能使用非抢占式算法。</p><h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><p>在不同的系统中，调度程序的优化目标是不同的。通常分为三种系统环境：</p><ol><li>批处理</li><li>交互式（分时）</li><li>实时（这里不探讨该系统的调度算法，不常用）</li></ol><p><a href="https://www.douban.com/note/311010077/" target="_blank" rel="noopener">三种系统的介绍以及各自常用的调度算法</a></p><p><a href="https://blog.csdn.net/u010889616/article/details/48424501" target="_blank" rel="noopener">三种系统的区别</a></p><p>批处理系统中，不会有用户在一旁等待快捷响应，因此非抢占式算法或每个进程都有长时间周期的抢占式算法都可以，这样减少了进程切换从而改善了性能。</p><p>交互式系统中，为了用户的体验抢占是必需的。</p><h3 id="调度算法的目标和指标"><a href="#调度算法的目标和指标" class="headerlink" title="调度算法的目标和指标"></a>调度算法的目标和指标</h3><ul><li>所有系统（目标）：<ul><li>公平：给每个进程公平的CPU份额</li><li>策略强制执行：保证规定的策略被执行</li><li>平衡：保持系统所有部分都忙碌</li></ul></li><li>批处理系统：<ul><li>吞吐量：每小时完成的作业数</li><li>周转时间：从提交作业到完成作业的平均时间</li><li>CPU利用率（不是个好的指标）</li></ul></li><li>交互式系统<ul><li>响应时间：快速响应请求</li><li>均衡性：满足用户的期望</li></ul></li></ul><h3 id="具体的调度算法"><a href="#具体的调度算法" class="headerlink" title="具体的调度算法"></a>具体的调度算法</h3><h4 id="批处理系统中"><a href="#批处理系统中" class="headerlink" title="批处理系统中"></a>批处理系统中</h4><ol><li>先来先服务：对短作业不友好</li><li>最短作业优先：在所有作业都可同时运行的情况下，最短作业优先算法是最优的</li><li>最短剩余时间优先：是最短作业优先的抢占式版本</li><li>最高响应比优先：？书上可能有</li></ol><p>1，2非抢占式，3抢占式</p><h4 id="交互式系统中"><a href="#交互式系统中" class="headerlink" title="交互式系统中"></a>交互式系统中</h4><ol><li>轮转调度：</li><li>优先级调度</li><li>多级队列</li><li>最短进程优先</li><li>彩票调度</li><li>保证调度（每个进程公平，一般来说是均分）</li><li>公平分享调度（每个用户公平，一般来说是均分）</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。这样的调度取决于是用户级线程还是内核级线程。</p><p>若是用户级线程，由于内核并不知道线程的存在，所以内核和以前一样操作，选取一个进程A，给予时间片控制，A中的线程调度程序选择运行那个线程由于进程内不存在时钟中断，所以该线程可以任意运行多少时间。从实用角度考虑，一般调度算法使用的是轮转调度和优先级调度。</p><p>若是内核调度，则内核选择特定的线程运行，给其赋予一个时间片，时间片结束后挂起该线程。</p><p>两者的差别主要在于性能，用户级线程切换只需要少量指令，而内核级线程却需要完整的上下文切换（因为它不考虑属于哪个进程，也就没有共同的地址空间了），修改内存映像，这导致若干的延迟。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件的存储实现"><a href="#文件的存储实现" class="headerlink" title="文件的存储实现"></a>文件的存储实现</h2><p><strong>扇区是对硬盘而言，块是对文件系统而言</strong>。文件系统不是一个扇 区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，block才是文件存取的最小单位。一般是4KB一块。</p><h3 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1. 连续分配"></a>1. 连续分配</h3><p>是最简单的分配方案，即将每个文件连续存储在磁盘上。</p><p>这一方法有两大优势：</p><ol><li>实现简单，记录每个文件的磁盘块只需要记住第一块的磁盘地址和文件块数即可</li><li>读操作性能好，只需要找到初始位置，不需要再寻道、旋转等，连续读即可。</li></ol><p>但是随着时间的推移，文件的不断添加与释放会使磁盘产生很多碎片，后期要想存储一个新文件很难找到位置。</p><p>但是这一方法也不是没有用处，比如DVD这种一次性写的介质，就很适合使用连续分配这一方法。</p><h3 id="2-链表分配"><a href="#2-链表分配" class="headerlink" title="2. 链表分配"></a>2. 链表分配</h3><p>为每个文件构造磁盘块链表。每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。</p><p>这一方法可以充分利用磁盘块，无需担心因为碎片而浪费空间。而且同样只需要存放第一块的磁盘地址，就可以访问到其他块。</p><p>另一方面，链式存储的随机访问相当缓慢，尤其这还是磁盘IO访问。而且，由于指针占去了一些字节，所以要完整读出文件内容，就需要获取各个块的数据部分然后拼接起来，这其中会涉及复制而引发额外的开销。</p><h3 id="3-用内存中的表进行链表分配"><a href="#3-用内存中的表进行链表分配" class="headerlink" title="3. 用内存中的表进行链表分配"></a>3. 用内存中的表进行链表分配</h3><p>如果取出每个磁盘块中的指针字段，将他们放在内存的表中，就可以解决上述的两个问题。</p><p>每个表项存储着下一磁盘块的块号，顺着这一链就可以找到该文件的所有磁盘块。内存中这样的一个表格称为<strong>文件分配表</strong>（File Allocation Table, FAT），现在各个版本Windows仍然支持这一管理方式。</p><p>但这一方法有一个缺点就是必须把整个表都放在内存中，对于比较大的磁盘来说，表会十分大，占用很多内存，这是不实际的。</p><h3 id="4-i节点"><a href="#4-i节点" class="headerlink" title="4. i节点"></a>4. i节点</h3><p>给每个节点都赋予一个称为i节点（index-node）的数据结构，其中列出的文件属性与文件块的磁盘地址。</p><p>这种机制有很大的优势，因为只有当对应文件打开时，其i节点才会在内存中，这通常比FAT所占据的空间要小。</p><h2 id="目录的存储实现"><a href="#目录的存储实现" class="headerlink" title="目录的存储实现"></a>目录的存储实现</h2><p>打开文件时，操作系统利用给出的路径名找到相应的目录项，目录项提供了查找文件磁盘块需要的信息，这因系统而异，可能是磁盘块的初始地址、第一个块的编号或者是i节点号。总之，目录系统 的主要功能就是把文件名映射为定位文件数据所需的信息。</p><p>对于使用i节点的系统，文件属性是存放在i节点中而不是目录项中的，这样目录项会更短，只有文件名和i节点号。</p><p>现代操作系统都支持可变长度的长文件名，这是如何实现的呢？</p><p>我们可以使目录项本身是固定长度的，而将文件名放置在目录后面的堆中（目录项中的指针指向堆中的文件名）。这一当一个文件目录项被移走后，另一个文件的目录项总可以适合这个空隙。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最近未使用"><a href="#最近未使用" class="headerlink" title="最近未使用"></a>最近未使用</h3><p>大部分支持虚拟内存的计算机中，系统为每个页面都设置了两个状态位，页面被读取设置R位，被修改设置M位。</p><p>利用R位和M位可以将页面分为4类</p><ul><li>第0类：没有访问，没有修改</li><li>第1类：没有访问，已被修改</li><li>第2类：已被访问，没有修改</li><li>第3类：已被访问，且被修改</li></ul><p>NRU（Not Recently Used）算法是当启动一个进程时，将所有页面的两个位由操作系统置为0，R位被时钟中断定期清零，以区分最近没有被访问的页面和被访问的页面（其实就是降低各个类的编号）。</p><p>看起来第1类是不可能出现的，其实第3类如果被时钟中断R位清零就得到了第1类。</p><p>缺页中断时，该算法会随机地从编号最小的页面中挑选一个淘汰。</p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>操作系统维护一个页面链表，最新进入的页面在表尾，最早的在表头，缺页中断时就淘汰表头页面，并把新页调入的页面插入表尾。</p><h3 id="第二次机会"><a href="#第二次机会" class="headerlink" title="第二次机会"></a>第二次机会</h3><p>FIFO可能会把经常使用的算法置换出去，为了避免这一问题，可以检查最老页面的R位，如果是0，则立刻置换，如果是1，则将R位清零，并将该页面放到链表的尾端，装入时间就像刚装入一样，这就是给了第二次的机会。</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>第二次机会是比较合理的置换算法，但是经常要在链表中移动页面，降低了效率。</p><p>我们可以把所有的页面放入一个环形链表，指针指向最老的页面。</p><p>每当发生缺页中断，检查指针所指页面的R位是否为0，是则淘汰，并将新的页面插入该位置，然后把指针向前移动一位；否则清除R位，并把指针向前移动一位。</p><h3 id="最近最少使用"><a href="#最近最少使用" class="headerlink" title="最近最少使用"></a>最近最少使用</h3><p>LRU（Least Recently Used）算法：在发生缺页中断时，置换未使用时间最长的页面。</p><p>一种实现是用一个特殊链表，将最近最多使用的放在表头，最近最少使用的放在表尾，每次使用到的页面如果在链表中，就把它取出并放到表头。不过这个实现一方面很耗时，并且实际上是“最近最久未使用”。</p><p>一种硬件实现是使用一个计数器，每次执行指令自增1，每个页表项中提供一位来容纳这个值，每次访问时就把计数器的值存到访问的页表项中。淘汰页面时选择最小的即可。虽然很符合“最近最少使用”的含义，缺点是消耗了很多存储空间；另外，计数器的溢出也是个问题。同样是“最近最久未使用”。</p><p>硬件的实现较为复杂，但我们可以用软件近似实现。一种软件实现被称为NFU(Not Frequently Used，最不常用)，每个页面使用一个计数器，每次时钟中断时，将页面的R位（是否被引用，0或1）加到计数器上。缺页中断时置换计数器值最小的。这种实现的坏处是它“从不忘记任何事情”，简单地说就是在之前计数器值比较高的页面，即使不再访问，仍然会保持这个值；而别的页面在后续始终无法超过。</p><p>对NFU做一个小修改，就可以很好的模拟LRU：将R位增加前先计数器右移、R位增加到计数器左边的最高位而不是右边的最低位。修改后的算法称为<strong>老化(aging)算法</strong>。其蕴含的特征是：越高位越新，最近的使用权重最大；早期的使用记录会随着右移而舍弃。</p><p>老化算法就不需要担心溢出问题，但同样由于计数器位数有限（比如8位），会限制对以往页面的记录。比如如果两个页面的计数器都是0，那我们只能随机选择一个，但其实有可能其中一个页面在9个时钟前是被访问了的，但我们看不到这些。 在实践中，如果时钟是20ms，那么8位其实是够用的，毕竟一个页面160ms没有被访问说明它很可能不那么重要。</p><h2 id="分页系统的设计"><a href="#分页系统的设计" class="headerlink" title="分页系统的设计"></a>分页系统的设计</h2><h3 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h3><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>（是共享内存通信方式的实现原理）</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h3 id="分段-1"><a href="#分段-1" class="headerlink" title="分段"></a>分段</h3><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h3 id="x86的实现"><a href="#x86的实现" class="headerlink" title="x86的实现"></a>x86的实现</h3><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按请求顺序完成请求，一般来说寻道时间会很长</p><h3 id="最短寻道优先"><a href="#最短寻道优先" class="headerlink" title="最短寻道优先"></a>最短寻道优先</h3><p>下一次总是处理与刺头最近的请求以使得寻道时间最小化。</p><p>这样响应时间确实是最优的，但是很容易使得磁盘臂停留在磁盘的中部区域，而两端的极端地区的请求等待时间很长，即 获得最小响应时间的目标与公平性存在冲突。</p><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>保持一个方向移动，知道在那个方向上没有请求为止，然后改变方向。</p><p>软件会维护一个二进制位表示方向UP和DOWN。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_ 1"><sup>1</sup>. <a href="zhihu.com/question/66902460">为什么Linux下要把创建进程分为fork()和exec()(一系列函数)两个函数来处理?</a><a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup>2</sup>. <a href="https://www.zhihu.com/question/274550824" target="_blank" rel="noopener">操作系统中到底是谁分配的资源?</a><a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>现代操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++Primer读书笔记</title>
    <link href="/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <url>/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>最近重读了C++ Primer这本书，比较重要的知识点记录在此，也对其中一些知识点做了一些延伸。</p><p>主要来源：C++ Primer、stack overflow</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="变量与基本类型"><a href="#变量与基本类型" class="headerlink" title="变量与基本类型"></a>变量与基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p>C++的基本内置类型包括算数类型（arithmetic type）和空类型（void）。</p><p>算数类型中，short至少为16位，int至少为16位，long至少为32位，而long long至少为64位。</p><p>windows上一般int和long均为32位，而linux 64位机器上long和long long是64位，int是32位。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why is the sizeof(int) == sizeof(long)?">[1]</span></a></sup></p><h4 id="如何选择类型"><a href="#如何选择类型" class="headerlink" title="如何选择类型"></a>如何选择类型</h4><ol><li>数值不会为负时，选择无符号类型</li><li>若数值超过int，直接选用long long，因为如上所述，long也许会与int是同样大小</li><li>浮点数选double，因为精度高，且计算代价与float相差无几。</li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>当我们赋给无符号类型一个超出其范围的值时，结果是初始值对无符号类型可以表示的数目取模的余数。</li><li>当我们赋给带符号类型一个超出其范围的值时，结果是未定义的。</li></ol><p>因为C、C++对于数值的表示是与CPU一致的，在实际中，表示无符号的方式就只有一种：纯二进制表示；但表示有符号的类型却有多种，如反码、补码等，无法统一，因此在C++中结果未定义。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why is unsigned integer overflow defined behavior but signed integer overflow isn’t?">[2]</span></a></sup></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量：一个具名的、可供程序操作的存储空间</p></li><li><p>对象：一块能存储数据并具有某种类型的内存空间</p></li></ul><p>对于C++程序员而言，这两者一般可以互换使用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>初始化不是赋值。</strong>初始化是创建变量时赋予一个初始值，而赋值是把对象当前值擦除，以一个新值替代。</p><ul><li>列表初始化：C++11新标准，用花括号初始化变量。<strong>对于内置变量，若初始值存在丢失信息的风险，会报warning，其他初始化则不会。</strong></li><li><strong>默认初始化</strong>：当定义变量没给指定初始值时，变量会被默认初始化，其值由定义的位置决定。（<strong>任何</strong>）变量若在函数外，初始化为0；若是在函数内的<strong>内置类型变量</strong>，会不被初始化，其值未定义。而各个类自己决定初始化对象的方式，如常用的string，则会默认初始化为空串。</li></ul><h4 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h4><p>为了允许将程序拆分为多个部分来编写（模块化），C++支持<strong>分离式编译</strong>，该机制允许检查程序分割为多个文件，每个文件可以被独立编译。</p><p>由于拆分成了多个文件，需要有文件间共享代码的方法，因此C++将声明和定义分开来。声明可以有多次，但定义只能有一次。</p><p>容易弄错的声明与定义：</p><pre><code class="hljs cpp"><span class="hljs-comment">// declaration</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> bar;  <span class="hljs-comment">// extern说明该变量必须！是另一个编译单元的全局变量 但这一外部声明语句可以在本编译单元的任意处使用</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span>;</span><span class="hljs-comment">// definition</span><span class="hljs-keyword">int</span> bar;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span> &#123;</span>&#125;;<span class="hljs-comment">// 这还是定义</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.1416</span>; <span class="hljs-comment">// 赋了初始值，抵消了extern的作用</span></code></pre><h4 id="typedef和-define"><a href="#typedef和-define" class="headerlink" title="typedef和#define"></a>typedef和#define</h4><h1 id="define是预处理器的命令，只是进行字符的替换，编译器看不到其所定义的标识符。"><a href="#define是预处理器的命令，只是进行字符的替换，编译器看不到其所定义的标识符。" class="headerlink" title="define是预处理器的命令，只是进行字符的替换，编译器看不到其所定义的标识符。"></a>define是预处理器的命令，只是进行字符的替换，编译器看不到其所定义的标识符。</h1><p>typedef是编译器的关键字，会进行类型的检查。</p><h4 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h4><p>（引用指的是“左值引用”，指针指的是“原始指针”）</p><p>引用是对绑定的<strong>对象</strong>（只能是对象，而不能是一个字面值）起的一个别名，它本身不是一个对象。引用必须初始化，且<strong>不能重新绑定到另外一个对象</strong>。引用的类型和与之绑定的对象要严格匹配。由于引用不是一个对象，所以不能定义引用的引用。</p><p>指针也实现了对其他对象的简介访问。但与引用相比也有许多不同点：</p><ol><li>指针本身是一个对象，允许拷贝与赋值，而且指针可以先后指向不同的对象</li><li>指针无需在定义时赋初始值，与其他内置类型一样，在块作用域内没被初始化则拥有一个不确定的值</li></ol><h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义包括一个<strong>基本数据类型</strong>（如int）和一组<strong>声明符</strong>（声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。如<code>i</code>，<code>*p</code>，<code>&amp;r</code>）。在同一条定义语句中，基本类型必须只有一个，但是声明符可以不同。如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1024</span>, *p = &amp;i, &amp;r = i;  <span class="hljs-comment">// i是整数，p是int指针，r是int引用</span></code></pre><p><code>*</code>和<code>&amp;</code>在这里是<strong>类型修饰符</strong>，作为<strong>声明符</strong>的一部分。</p><p>经常会有一种错误的观点认为，在定义语句中，类型修饰符会作用于定义的全部变量，实际并不是，仅仅作用于其后的第一个变量。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span>* p1, p2; <span class="hljs-comment">// p1是int的指针，但p2不是，p2是int类型</span><span class="hljs-keyword">int</span> *p1, *p2; <span class="hljs-comment">// p1, p2都是int的指针</span></code></pre><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const对象仅在文件内有效，若多个文件中出现了同名，其实等同于在不同文件中分别定义了独立的变量。如果想在文件间共享，则不管是声明还是定义都添加extern关键字。</p><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp 定义一个常量，允许被其他文件访问</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">100</span>;<span class="hljs-comment">// file1.h</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize; <span class="hljs-comment">// 与file1.cpp是同一个</span></code></pre><h4 id="对常量的引用"><a href="#对常量的引用" class="headerlink" title="对常量的引用"></a>对常量的引用</h4><p>对常量的引用不能用于修改其绑定的对象，但其绑定的对象不一定是一个常量（只是引用“自以为是”罢了）。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> &amp;r1 = i;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i;r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，i被修改为0</span>r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//错误 不能通过r2修改i</span></code></pre><p>而如果是一个常量，那么引用只能是对常量的引用。</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span><span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">// 错误， 否则可以通过r2修改i</span></code></pre><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><ul><li>指向常量的指针，可以不初始化，不能用于改变其所指对象的值（与引用相同，也是“自以为是”）</li><li>常量指针，<strong>必须初始化</strong>，初始化后它的值（所存对象的地址）不能再改变</li></ul><h4 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h4><ul><li>顶层const：可以表示<strong>任意对象</strong>是常量</li><li>底层const：表示与指针和引用这类复合类型的<strong>基本类型部分</strong>是常量</li></ul><p>一般一个类型要么是顶层const，要么是底层const，但指针既可以是顶层const，也可以是底层const。</p><p>常量指针，指针本身是常量，是顶层const；而指向常量的指针，指针本身不是常量，但而指向的对象是常量（指针自以为是），所以是底层const。</p><p>这两个概念在拷贝与赋值时十分重要。</p><p>在拷贝时，顶层const不受影响：</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> i = ci; <span class="hljs-comment">// 正确</span><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> cp = &amp;i;<span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// 正确</span></code></pre><p>因为拷贝操作并不会改变被拷贝对象的值，所以是不是常量都无所谓。</p><p>但是底层const的限制不能忽视。当执行对象的拷贝操作时，<strong>拷入和拷出的对象都必须具有相同的底层const资格，或者能够相互转换，一般来说只有非常量可以转换成常量。</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *cp = &amp;i;<span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">// 错误，因为cp是底层const，而p不是 有可能会通过p修改cp所指向的值</span>cp = p; <span class="hljs-comment">// 正确， int*可以转成const int*</span></code></pre><h2 id="字符串与向量"><a href="#字符串与向量" class="headerlink" title="字符串与向量"></a>字符串与向量</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline参数是一个输入流和一个string对象，返回流参数。</p><p>每次读取一行，<strong>换行符会被读进来</strong>，所读的内容存入string对象，但是<strong>不存换行符</strong>。</p><p>所以我们一般输出时会自行加一个endl：</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line;<span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>, line))    <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h4 id="处理字符"><a href="#处理字符" class="headerlink" title="处理字符"></a>处理字符</h4><p>在<code>cctype</code>头文件中，常用的有：</p><ul><li>isalpha(c) 字母</li><li>isdigit(c) 数字</li><li>isalnum(c) 字母或数字</li><li>isspace(c) 空白</li><li>ispunct(c) 标点符号</li></ul><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p><code>operator+</code>是拷贝两个字符串，生成新的字符串，复杂度为<code>O(length(oldStr+newStr))</code>，<code>operator+=</code>是调用<code>append</code>函数，而<code>append</code>函数复杂度为<code>O(length(newStr))</code>。</p><p><code>append</code>的实现：根据文档，没有标准的复杂度保证，而实现是类似vector的insert函数。</p><h4 id="string和vector"><a href="#string和vector" class="headerlink" title="string和vector\"></a>string和vector\<char \></char></h4><p>string是模板类<code>basic_string</code>的char特例，源码定义如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-built_in">string</span>;</code></pre><p>而basic_string类中，有三个主要的成员变量，分别是分配空间的首尾地址和当前最后一个元素的地址，这与vector是一样。因此，string和vector\<char \>在数据结构上是一致的，只不过string还提供了额外的对于字符串的操作，如转为c-style字符串的<code>data()</code>函数，还重载了输入输出运算符等等。</char></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h4><p>如果只提供vector容纳的数量，而略去了初始值，那么库会给一个值初始化的初值赋给容器中所有元素。</p><p>如果元素是内置类型，会自动设为0，如果是某种类类型，则又类默认初始化。</p><h4 id="vcector和string的增长"><a href="#vcector和string的增长" class="headerlink" title="vcector和string的增长"></a>vcector和string的增长</h4><p>vector和string都是分配连续的内存空间，元素是连续存储的。因此当没有空间容纳新元素时，我们必须重新分配一片内存空间，将已有元素移到新空间，添加元素，然后释放旧空间。如果每次添加元素都分配新空间，效率会很低。因此，vector和string的实现通常会分配比新的空间需求更大的空间，预留这些空间作为备用。</p><p>c++标准其实并没有指定要扩展内容多少，是依赖于实现的。各个实现也只是为了实现标准中所说的push_back（vector的）要摊还O(1)，比如g++编译器是2倍，而vs的编译器是1.5倍。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们可以使用下标运算符来访问容器，但迭代器是一种更通用的访问机制。</p><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</p><p>在修改容器容量的循环中，不要使用迭代器，因为原本的迭代器会失效。</p><h4 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h4><p>支持加减一个整数，支持在同一个容器中的迭代器大小比较。</p><p><strong>支持同一个容器中两个迭代器的减法运算<code>iter1-iter2</code>，但不支持加法运算<code>iter1+iter2</code></strong>。</p><h4 id="样例：迭代器版本的二分搜索"><a href="#样例：迭代器版本的二分搜索" class="headerlink" title="样例：迭代器版本的二分搜索"></a>样例：迭代器版本的二分搜索</h4><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> beg = text.begin();<span class="hljs-keyword">auto</span> end = text.end();<span class="hljs-keyword">auto</span> mid = beg + (end - beg) / <span class="hljs-number">2</span>;<span class="hljs-keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;    <span class="hljs-keyword">if</span> (sought &lt; *mid) &#123;        end = mid;    &#125; <span class="hljs-keyword">else</span> &#123;        beg = mid +<span class="hljs-number">1</span>;    &#125;    mid = beg + (end - beg) / <span class="hljs-number">2</span>;&#125;</code></pre><p><strong>为什么求mid是beg + (end-beg)/2而不是(beg+end)/2？</strong></p><ol><li>如果是下标访问，beg+end或许会溢出</li><li>如果是迭代器版本，迭代器并不支持迭代器相加的运算</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的维度在编译时必须已知，即维度是常量表达式（字面值，常量表达式初始化的const对象，constexpr类型变量）</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>当使用字符串字面值初始化字符数组时，一定要注意<strong>字符串字面值</strong>的结尾还有一个空字符会被自动添加。</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> a1[] = &#123;<span class="hljs-string">'c'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'+'</span>&#125; <span class="hljs-comment">// 正确 字符字面值初始化，大小为3</span><span class="hljs-keyword">char</span> a2[] = <span class="hljs-string">"C++"</span>  <span class="hljs-comment">// 正确 字符串字面值初始化 大小为4</span><span class="hljs-keyword">char</span> a3[<span class="hljs-number">6</span>] = <span class="hljs-string">"Daniel"</span>  <span class="hljs-comment">// 错误，没位置存放空字符\0</span></code></pre><h4 id="不允许拷贝与赋值"><a href="#不允许拷贝与赋值" class="headerlink" title="不允许拷贝与赋值"></a>不允许拷贝与赋值</h4><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a1[] = a; <span class="hljs-comment">// 错误 不允许一个数组初始化另一个数组</span></code></pre><h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p>使用数组的时候编译器一般会把它转换为数组首元素的指针。</p><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> *p = strs; <span class="hljs-comment">// 等价于string *p = &amp;strs[0]</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testArr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> <span class="hljs-comment">// a等价于&amp;a[0]，是指针</span></span><span class="hljs-function"><span class="hljs-comment">// 但注意定义数组时，数组名的类型仍然是数组</span></span>int a[3] = &#123;1, 2, 3&#125;; // a为数组类型<span class="hljs-keyword">decltype</span>(a) a2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 正确</span>a2 = p; <span class="hljs-comment">// 错误 不能将指针赋给数组</span></code></pre><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p><strong>除非必须，否则不用后置版本。</strong></p><p>前置版本是将运算对象加1（或减1），然后返回改变后的对象，是左值；而后置版本是先暂存当前对象，然后加1（或减1），返回暂存的对象，是右值。如果我们不需要修改前的值，那么暂存的对象就是一种浪费。</p><h4 id="混用解引用和递增运算符"><a href="#混用解引用和递增运算符" class="headerlink" title="混用解引用和递增运算符"></a>混用解引用和递增运算符</h4><p>这是一种常见的简洁写法，值得学习。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> beg = v.begin();<span class="hljs-keyword">while</span> (beg != v.end() &amp;&amp; *beg &gt; <span class="hljs-number">0</span>)    <span class="hljs-built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><p><strong>后置递增运算符的优先级高于解引用运算符。</strong>因此<code>*beg++</code>等价于<code>*(beg++)</code>。最终，这条语句输出<code>beg</code>开始指向的那个元素，并将指针向前移动一个位置。</p><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>sizeof返回一个表达式或类型名所占的字节数，编译时计算，返回的是常量表达式。</p><p><strong>它并不实际计算其运算对象的值</strong>，如：</p><ol><li>sizeof(*p) p可以是一个无效的指针，因为无需真的解引用指针</li><li>sizeof(Sales_data::revenue) 可以使用作用域运算符获取类成员的大小，因为无需真的获取该成员</li></ol><p>注意：对于stl的容器，sizeof返回的是与容器类相关的一个常量值。比如：vector是24， unordered_set</p><p>是56。</p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used" target="_blank" rel="noopener">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></p><p>形式如下：</p><pre><code class="hljs cpp">cast-name&lt;type&gt;(expression);</code></pre><ul><li><p><code>static_cast</code>：只要不包含底层const，对于有明确定义的类型转换就可以使用。尤其是把一个较大的算术类型转换为较小的类型时，这会告诉编译器我们知道且不在乎该精度损失。</p></li><li><p><code>const_cast</code>：只能改变运算对象的底层const。</p></li><li><p><code>reinterpret_cast</code>（<strong>十分危险</strong>）：为运算对象的位模式提供重新的解释，如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip;<span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);</code></pre></li><li><p><code>dynamic_cast</code>：</p></li></ul><h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>早期C++有两种强制类型转换的形式：</p><ul><li>函数形式：type(expr)</li><li>C语言风格：(type)expr</li></ul><p>旧式的强制类型转换包含现代显式类型转换的前三种形式，但是由于从形式上来说不那么清晰明了，一旦转换过程出现问题，追踪起来更为困难。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们作用在数组上的函数有影响：</p><ol><li>不能拷贝数组。因此我们无法以值传递的方式使用数组参数。</li><li>使用数组时常会将其转换为指针。因此我们为一个函数传递数组时，传递的实际是数组首元素的指针。</li></ol><p>对于一个数组参数，我们可以有多种形式</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [])</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 这里的维度只是期望，实际不一定是10</span></code></pre><p>虽然有不同的表现形式，但其实唯一形参都是<code>int *</code>，即编译器只检查传入的参数是否是<code>int *</code>。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;print(&amp;i); <span class="hljs-comment">// 所以这也是能编译通过的</span></code></pre><h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><pre><code class="hljs cpp">f(<span class="hljs-keyword">int</span> (&amp;arr)[<span class="hljs-number">10</span>]); <span class="hljs-comment">// 正确， 读的方式：从里往外读，从右往左读</span>f(<span class="hljs-keyword">int</span>&amp; arr[<span class="hljs-number">10</span>]); <span class="hljs-comment">// 错误，这样是引用的数组，而引用不是对象，不能存于数组</span></code></pre><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>当传递数组为参数时，实际传的是数组首元素的指针。当我们传多维数组，也就是数组的数组时，数组首元素即一个数组，所以实际传的是一个指向数组的指针。数组第二维及以后的维度都是数组类型的一部分，不能省略，所以我们应该这样传：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)</span></span>;  <span class="hljs-comment">// 第二维是类型的一部分，因此要制定维度，这里是10</span></code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员函数与this指针"><a href="#成员函数与this指针" class="headerlink" title="成员函数与this指针"></a>成员函数与this指针</h3><p>以一个成员函数的调用为例：</p><pre><code class="hljs cpp">total.isbn()</code></pre><p>当我们调用成员函数时，其实是在替某个对象调用它。如果该成员函数指向了该类的某个成员变量，则它隐式地指向调用该函数对象的成员变量。</p><p>成员函数通过一个名为<code>this</code>的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>，如调用上述函数，则可以等价地认为编译器重写为</p><pre><code class="hljs cpp">Sales_data::isbn(&amp;total);</code></pre><p>在成员函数内部，我们可以直接使用该对象的成员，而无需成员访问运算符，也正是因为this所指的就是这个对象。所以我们使用<code>bookNo</code>，其实相当于<code>this-&gt;bookNo</code>。</p><p>因为<code>this</code>总是指向“这个”对象，所以它是一个<strong>常量指针</strong>。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>这里const的作用是<strong>修改隐式this指针的类型</strong>。</p><p>默认情况下，this的类型是指向类类型非常量版本的常量指针，即<code>T *const</code>，则我们不能将其绑定到一个常量对象上，这样我们也就不能在一个常量对象上调用普通的成员函数了。</p><p>而const成员函数则可以将this转换为指向常量的常量指针<code>const T *const</code>，这样常量对象也就能调用const成员函数了。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数不能声明为const"><a href="#构造函数不能声明为const" class="headerlink" title="构造函数不能声明为const"></a>构造函数不能声明为const</h4><p>当我们创建一个const类对象时，直到构造函数完成初始化过程，对象才真正获得了“常量”属性，因此构造函数在const对象构造过程中是可以向其写值的，那么也就不能声明为const。</p><h4 id="合成默认构造函数"><a href="#合成默认构造函数" class="headerlink" title="合成默认构造函数"></a>合成默认构造函数</h4><p>如果我们没有显式地定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数，称为合成默认构造函数，它按以下规则初始化类的成员：</p><ul><li>如果存在类内初始值（在定义时赋初值，如<code>int a = 3</code>），用它初始化成员</li><li>否则，默认初始化成员</li></ul><p>如果类内含有内置类型或者复合类型（指针，引用等）的成员，只有当这些成员全都被赋予了类内初始值，这个类才适合使用合成默认构造函数，不然这些成员的值是未定义的。</p><h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><p>当某个数据成员被构造初始化列表忽略时，它将以合成默认构造函数的方式隐式初始化。</p><h3 id="从const成员函数返回-this"><a href="#从const成员函数返回-this" class="headerlink" title="从const成员函数返回*this"></a>从const成员函数返回*this</h3><p>因为const成员函数中this是一个<code>const T *const</code>类型的指针，指向常量的指针返回指向的对象必须是常量，不让修改。因此，返回的<code>*this</code>应该是一个常量引用<code>const T&amp;</code>。</p><h3 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h3><p>因为非常量版本的函数对于常量对象是不可用的， 因此我们只能在一个常量对象上调用const成员函数；另一方面，虽然可以在非常量对象上调用常量函数，但显然非常量版本是一个更好的匹配。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Foo &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> </span>&#123;        do_display(os);    &#125;    <span class="hljs-function"><span class="hljs-keyword">const</span> Foo &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span>&#123;        do_display(os);        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> </span>&#123;  <span class="hljs-comment">// 使用私有功能函数，减少代码重复</span>        ...    &#125;&#125;;</code></pre><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p><strong>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。</strong></p><p>假如类Sales_item定义了以下函数</p><pre><code class="hljs cpp">Sales_item(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>);<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(Sales_item)</span></span>;</code></pre><p>那么以下代码是正确的：</p><pre><code class="hljs cpp">Sales_item item ...    ...<span class="hljs-built_in">string</span> null_book = <span class="hljs-string">"9-999-999"</span>;item.combine(nullbook);</code></pre><p>因为string类型可以隐式转换为Sales_itme类型。</p><p>但是隐式转换只允许一步类型转换，所以以下代码是错误的：</p><pre><code class="hljs cpp">item.combine(<span class="hljs-string">"9-999-999"</span>); <span class="hljs-comment">// 需要两步，（1）把const char*转为string （2）把string转为Sales_item</span></code></pre><h4 id="explicit抑制隐式转换"><a href="#explicit抑制隐式转换" class="headerlink" title="explicit抑制隐式转换"></a>explicit抑制隐式转换</h4><p>构造函数使用<code>explicit</code>关键字阻止隐式转换。</p><p>该关键字只对有一个实参的构造函数有效，需要多个实参的构造函数不能用于隐式转换，也就不需要该关键字。只能在类内声明时加，类外定义时不应重复。</p><p><strong>explicit构造函数只能用于直接初始化！</strong></p><p>发生隐式转换的一种情况是我们执行拷贝形式的初始化时（使用=），如果该构造函数是explicit，则无法进行该隐式转换。</p><pre><code class="hljs cpp"><span class="hljs-function">Sales_data <span class="hljs-title">item</span><span class="hljs-params">(null_book)</span></span>; <span class="hljs-comment">// 正确：直接初始化</span>Sales_data item = null_book <span class="hljs-comment">// 错误 无法完成隐式转换</span></code></pre><h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>常用的IO库设施：</p><ul><li>istream（输入流）类型</li><li>ostream（输出流）类型</li><li>cin， 一个istream对象，从<strong>标准输入</strong>读取数据</li><li>cout， 一个ostream对象，向<strong>标准输出</strong>写入数据</li><li>cerr，一个ostream对象，用于输出程序错误信息，写入<strong>标准错误</strong></li><li><code>&gt;&gt;</code>运算符（提取运算符），用于从一个istream对象读取输入</li><li><code>&lt;&lt;</code>运算符（插入运算符），用于向一个ostream对象写入输出</li></ul><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p><strong>IO对象不能拷贝和赋值！</strong></p><h3 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h3><p>由于流可能处于错误状态，因此代码通常应该在使用流前检查它是否是良好的。确定一个流对象的状态最简单的方法就是将它作为一个条件来使用：</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; word)    <span class="hljs-comment">// 流状态良好</span></code></pre><h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p>IO库定义了一个iostate类型，作为位集合使用。</p><ul><li>badbit表示系统级错误，不可恢复</li><li>failbit是可恢复错误，流还可以使用，如期望读取数值却读到了字符串等错误</li><li>文件结束，eofbit和failbit都会被置位</li><li>goodbit值为0表示流状态良好</li></ul><p>我们前面将流当做条件使用的代码其实就相当于<code>!fail()</code>。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>文件常用操作：</p><ul><li>fstream fstrm(filename); 创建一个文件流对象，并绑定一个文件，自动调用open函数打开它</li><li>fstrm.open(filename) 打开并绑定文件filename</li><li>fstrm.close()关闭与fstrm绑定的文件</li><li>fstrm.is_open() 返回一个bool值，指出与fstrm关联的文件是否成功打开</li></ul><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>open失败，failbit会被置位。因为调用open可能失败，因此检测open是否成功是个好习惯，可以检查流对象的有效性或调用is_open()函数。</p><p>对一个已经打开的文件流调用open会失败，而且为了将文件流关联到另一个文件，必须首先关闭已经关联的文件。</p><p>当一个fstream对象被销毁时，会自动调用close函数。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><div class="table-container"><table><thead><tr><th>in</th><th>读</th></tr></thead><tbody><tr><td>out</td><td>写</td></tr><tr><td>app</td><td>每次写操作前定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>二进制读写</td></tr></tbody></table></div><ol><li>只有out被设定，trunc才能被设定</li><li>只要trunc没被设定，app就可以设定</li></ol><h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul><li>istringstream</li><li>ostringstream</li><li>stringstream</li></ul><p>从string中读写数据，就像string是个IO流一样。</p><h3 id="istringsteam常用形式"><a href="#istringsteam常用形式" class="headerlink" title="istringsteam常用形式"></a>istringsteam常用形式</h3><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line, word;<span class="hljs-keyword">while</span> (getline(<span class="hljs-built_in">cin</span>, line)) &#123;    <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">record</span><span class="hljs-params">(line)</span></span>;    <span class="hljs-keyword">while</span> (record &gt;&gt; word) &#123;        ...    &#125;&#125;</code></pre><h3 id="ostringstream常用形式"><a href="#ostringstream常用形式" class="headerlink" title="ostringstream常用形式"></a>ostringstream常用形式</h3><p>当我们想逐步构造输出，希望最后一起打印时，ostringstream很有用。</p><p>比如一个人有很多电话号码，我们希望确定一个人所有有效的电话号码后再一起输出。</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;nums : entry.phones) &#123;    <span class="hljs-keyword">if</span> (valid(nums)) &#123;        formatted &lt;&lt;  <span class="hljs-string">" "</span> &lt;&lt; format(nums);    &#125;&#125;os &lt;&lt; entry.name &lt;&lt; <span class="hljs-string">" "</span> formatted.str() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// stringstream的str成员函数是返回内部string的拷贝</span></code></pre><h1 id="动态内存与指针"><a href="#动态内存与指针" class="headerlink" title="动态内存与指针"></a>动态内存与指针</h1><p>能不用指针就不用指针，可以值传递或者引用，如果一定要用指针，先考虑智能指针，原始指针很少用。何时使用指针：<a href="https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself" target="_blank" rel="noopener">Why should I use a pointer rather than the object itself?</a></p><p>程序使用动态内存的三种原因：</p><ol><li>不知道自己需要使用多少对象（容器类）</li><li>不知道对象的准确类型（多态）</li><li>需要在多个对象间共享数据（使用shared_ptr共享底层数据）</li></ol><h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new delete"></a>new delete</h2><p>在C++中，如果需要自己直接管理内存，就需要使用new和delete这两个关键字。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>new表达式在自由空间构造一个对象，并返回该对象的指针。默认情况下，该对象是默认初始化的， 如果在类型名后加一个空括号则是值初始化，加参数则是调用对应有参数的构造函数（类）。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">// 默认初始化</span><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(); <span class="hljs-comment">// 值初始化</span><span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 指定初始化为5，若是类则调用对应有参数的构造函数</span></code></pre><h4 id="动态分配的const对象"><a href="#动态分配的const对象" class="headerlink" title="动态分配的const对象"></a>动态分配的const对象</h4><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>);</code></pre><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>与new类似，delete也执行两个操作：</p><ol><li>销毁给定指针所指对象</li><li>释放对应内存</li></ol><h4 id="与malloc-free的区别"><a href="#与malloc-free的区别" class="headerlink" title="与malloc free的区别"></a>与malloc free的区别</h4><p>最主要的区别就是new delete在分配和释放内存之余还会构造和销毁对象，而malloc和free只会分配和释放内存。而且new和delete的操作符，可以被合法重载，而malloc和free不行。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针就是包装着原始指针的类，自行管理动态内存，无须担心内存泄漏。</p><p>现代C++中，原始指针不能与动态内存管理相关，这一工作应交给智能指针来做。</p><blockquote><p>A raw pointer should only be used as a “view” and not in any way involved in ownership.</p></blockquote><p>智能指针和原始指针的选用详见：<a href="https://stackoverflow.com/questions/7657718/when-to-use-shared-ptr-and-when-to-use-raw-pointers/7658089" target="_blank" rel="noopener">When to used shared_ptr and when to use raw pointers?</a></p><h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>我们可以认为每个shared_ptr都有一个关联的计数器， 通常称为引用计数。</p><p>当我们拷贝一个shared_ptr时，对应计数器都会递增，如用一个shared_ptr初始化另一个shared_ptr，或将其作为参数传递，或是作为函数返回值。当我们给shared_ptr赋予一个新值或是其被销毁，计数器就会递减。</p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>除了使用make_shared初始化shared_ptr，我们还可以使用new返回的指针初始化智能指针。但注意：接受指针参数的构造函数是explicit的，也就是说只能直接初始化，而不支持隐式转换</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;  <span class="hljs-comment">// 正确</span><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 错误</span></code></pre><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr“拥有”它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。使用new进行初始化。</p><p>不能拷贝或者赋值unique_ptr，但是可以通过rest或release转移指针的所有权。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是“弱”共享对象，指向shared_ptr管理的对象，不会改变其引用计数，而且即使有weak_ptr指向对象，对象也可以释放。</p><p>用处：检测一个对象是否还存在，解决空悬指针的问题。</p><p>具体看以下例子<sup><a href="#fn_3" id="reffn_3">3</a></sup>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>);<span class="hljs-keyword">int</span> *ref = ptr;<span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 此时ref和ptr都是空悬指针，指向未定义的数据</span><span class="hljs-comment">// 为了解决这一问题，我们可以使用shared_ptr和weak_ptr</span><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; sptr = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; weak = sptr;sptr.reset(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>);   <span class="hljs-comment">// 转移指向的对象，释放原对象（如果引用计数为1）</span>*sptr = <span class="hljs-number">5</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> temp = weak.lock()) <span class="hljs-comment">// 如果指向对象的引用计数为0，返回空shared_ptr,否则返回一个指向该对象的shared_ptr</span>    <span class="hljs-built_in">cout</span> &lt;&lt; *temp &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span>     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"weak is expired"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><p>声明中包含类名，但是不能包含它的派生列表。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base;  <span class="hljs-comment">// 错误</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>;</span> <span class="hljs-comment">// 正确</span></code></pre><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>当我们使用存在继承关系的类型时，我们就需要将一个变量的静态类型和动态类型区分开来。</p><p>静态类型是在编译时已知的，是声明时确定的类型；动态类型则是实际在内存的对象的类型，运行时才可知。</p><p>比如我们知道item的静态类型是<code>Base&amp;</code>，但是它动态类型依赖于绑定的实参，动态类型直到运行时调用函数才会知道，也许是<code>Base</code>，也许是<code>Derived</code>。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待，若基类希望派生类各自定义自己的版本，则声明这些函数为<strong>虚函数</strong>。</p><p>当用指针或引用调用虚函数时，该调用将被动态绑定，即调用函数的版本由运行时调用的对象决定。</p><p>如果派生类没有覆盖基类的某个虚函数，则派生类会直接继承基类的版本。</p><h3 id="C-的多态性"><a href="#C-的多态性" class="headerlink" title="C++的多态性"></a>C++的多态性</h3><h4 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h4><p>即函数重载，相同的函数名，类型或个数不同的参数。</p><h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><p>对于类中定义的虚函数，我们使用基类的引用或指针调用它时，将发生动态绑定，直到运行时我们才确定调用函数的版本。这其实是基于引用或指针的静态类型和动态类型不同这一事实。</p><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>继承。有类的继承才有重写，重载不需要继承</li><li>函数签名。重写函数必须有相同的函数名与参数，而重载函数需要有相同的函数名，不同的参数</li><li>函数作用域。重写的函数有不同的作用域（不同类中），而重载的函数有相同的作用域。</li><li>函数的行为。重写是子类函数希望做与父类函数有些不同的工作，而重载是根据不同的参数来进行不同的工作。</li></ol><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="基础与常用异常处理"><a href="#基础与常用异常处理" class="headerlink" title="基础与常用异常处理"></a>基础与常用异常处理</h2><p>在真实程序中，应该把业务逻辑代码和用户交互的代码分离开来。因此，当遇到问题时，最好不要直接输出错误信息，而是应该抛出异常，让对应专门的代码处理问题，如下：</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (item1.isbn() != item2.isbn())    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"Data must refer to same isbn"</span>);</code></pre><p><code>runtime_error</code>是运行时不符合预期时可用。</p><p>异常抛出后，需要<code>try</code>语句块来进行处理。其通用语法为</p><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;    program-statements&#125; <span class="hljs-keyword">catch</span> (exception-declaration) &#123;    handle-statements&#125; <span class="hljs-keyword">catch</span>(...) &#123;...   &#125;</code></pre><p>让我们用一个典例来加以说明：</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 添加item的代码，若两个item的isbn不同，抛出runtime_error</span>    &#125; <span class="hljs-keyword">catch</span> (runtime_error err) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="hljs-string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">char</span> c;        <span class="hljs-built_in">cin</span> &gt;&gt; c;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">cin</span> || c == <span class="hljs-string">'n'</span>)            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p>每个标准库类都定义了一个<code>what</code>成员函数，用于输出错误信息，该错误信息就是之前构造该异常对象时的初始化参数。因此这里会输出<code>Data must refer to same isbn</code>。</p><p>由于输入的isbn不同，我们提示用户是否重新输入，若输入的不是字符（<code>!cin</code>）或输入为n则跳出，不然重新输入。</p><h2 id="寻找处理代码"><a href="#寻找处理代码" class="headerlink" title="寻找处理代码"></a>寻找处理代码</h2><p><strong>寻找处理代码的过程与函数调用链刚好相反</strong>。当异常被抛出时，首先搜索该异常的函数，若没找到匹配的catch则终止该函数，并在调用该函数的函数中继续寻找，以此类推，沿着程序的执行路径逐层回退，直到找到合适类型的catch语句为止。</p><p>如果最终都没有找到匹配的catch语句，则程序转到名为<code>terminate</code>的标准库函数，执行该函数，导致程序非正常退出。</p><h2 id="异常的行为"><a href="#异常的行为" class="headerlink" title="异常的行为"></a>异常的行为</h2><p><strong>异常中断了程序的正常流程</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote id="fn_ 3"><sup>3</sup>. <a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful" target="_blank" rel="noopener">\When is std::weak_ptr useful?</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://stackoverflow.com/questions/18901080/why-is-the-sizeofint-sizeoflong" target="_blank" rel="noopener">Why is the sizeof(int) == sizeof(long)?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is" target="_blank" rel="noopener">Why is unsigned integer overflow defined behavior but signed integer overflow isn’t?</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section><a href="#reffn_ 3" title="Jump back to footnote [ 3] in the text.">&#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++头文件包含的相关问题</title>
    <link href="/C-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"/>
    <url>/C-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<p>前两天，室友测试C++的循环包含（<code>cyclic include</code>）和友元函数，但却总是报错。我们一起探讨并查询了各类资料后，终于搞清楚了原因。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们有<code>A</code>和<code>B</code>两个类，分别在不同的头文件中，两个头文件互相包含（但由于有<code>include guard</code>并不会出现循环包含问题）。<code>A</code>类中有一个<code>B</code>类友元函数，一切都是运行正确的，直到我们在<code>B.cpp</code>中加入了<code>B</code>类该函数的定义。</p><p><strong>A.h</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>B.h</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"A.h"</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>B.cpp</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp; a)</span> </span>&#123;   &#125;</code></pre><p><strong>main.cpp</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"A.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"B.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><p>运行命令：</p><pre><code class="hljs shell">g++ -g -o test main.cpp B.cpp</code></pre><p><strong>报错信息</strong>：</p><pre><code class="hljs shell">A.h:7:17: error: 'B' has not been declared    friend void B::fun(A&amp;);</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>经过分析与误打误撞的尝试，我们发现有以下两种消除错误的方法：</p><ol><li>删除<code>B.h</code>中的<code>#include &quot;A.h&quot;</code>语句</li><li>将<code>B.cpp</code>中的<code>#include &quot;B.h&quot;</code>该为<code>#include &quot;A.h&quot;</code></li></ol><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>对于头文件包含产生的问题，最好的方法或许就是自己去扮演<strong>预处理器</strong>的角色。</p><p>C++中，<code>.cpp</code>文件是一个编译单元，因此我们这里来一一分析<code>.cpp</code>文件。</p><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><p><code>main.cpp</code>中先包含了<code>A.h</code>，这时因为<code>A_H</code>还未定义，则<code>A.h</code>中就会定义<code>A_H</code>防止后续的重复包含。<code>A.h</code>又包含了<code>B.h</code>，因为<code>B_H</code>还未定义，则<code>B.h</code>中就会定义<code>B_H</code>。此时，<code>B.h</code>又尝试包含<code>A.h</code>，但由于<code>A_H</code>已被定义，返回的是空文本。最终这些内容都被拷贝到<code>main.cpp</code>中，大致如下：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    &#125;</code></pre><p>由于B类中的fun函数只是需要A类的引用，而不是A的实例本身或A的成员变量，所以一个前置声明<code>class A;</code>是足够的，并不会报错。</p><p>而A类中需要用到B类的成员函数，因此需要有B类的前置声明和该成员函数的前置声明，预处理后的文件中确实做到了这一点，所以也不会报错。</p><p>关于前置声明，不了解的读者请仔细阅读<a href="https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration" target="_blank" rel="noopener">When can I use a forward declaration?</a>。</p><h3 id="B-cpp"><a href="#B-cpp" class="headerlink" title="B.cpp"></a>B.cpp</h3><p>由于每个<code>.cpp</code>文件是独立的编译单元，因此编译完<code>main.cpp</code>后，将编译<code>B.cpp</code>，而且<strong>之前处理的宏定义（如#ifndef,#define等）都会被遗忘</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Why aren’t my include guards preventing recursive inclusion and multiple symbol definitions?">[1]</span></a></sup>。</p><p><code>B.cpp</code>中包含了 <code>B.h</code>，由于没有定义<code>B_H</code>，则会定义<code>B_H</code>，然后<code>B.h</code>包含<code>A.h</code>，定义<code>A_H</code>，<code>A.h</code>中还尝试包含<code>B.h</code>，但由于<code>B_H</code>已被定义，返回的是空文本。最终内容被拷贝到<code>B.cpp</code>中，大致如下：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> B_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> A_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A_H</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A&amp;)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>可以发现，A类中用到了B的成员函数，但B的定义却在后面，所以找不到B类及其成员函数的定义，报错。</p><h2 id="解决方法分析"><a href="#解决方法分析" class="headerlink" title="解决方法分析"></a>解决方法分析</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>由于<code>B.h</code>中我们只用了A类的引用，所以其实一个前向声明就足够了。加上了<code>#include &quot;A.h&quot;</code>，反而引入了A类中B类成员函数找不到声明的问题。因此，删掉<code>#include &quot;A.h&quot;</code>即可，这是比较好的解决方法。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>由于出错的原因就是<code>B.cpp</code>中包含<code>B.h</code>，<code>B.h</code>又包含<code>A.h</code>，引入了A类中B类成员函数找不到声明的问题，因此我们可以直接在<code>B.cpp</code>中包含<code>A.h</code>，这样B类的定义就会在A类前面，不会报错。但是一般而言实现文件应该是要包含对应的头文件的，这样消除错误会带来耦合。</p><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>由于C++是分离编译的，则<code>main.cpp</code>-&gt;<code>main.obj</code>，而<code>B.cpp</code>-&gt;<code>B.obj</code>，按理说这两个目标文件中都应该包含着<code>class B</code>的定义，那为什么没有重复定义的错误呢？</p><p>根据查询的资料，因为<strong>C++是允许类存在重复定义的</strong>，但是所定义的类必须完全一致<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Definitions and ODR (One Definition Rule)">[2]</span></a></sup>。具体的原因我也还不清楚，应该是关于设计、链接等方面的原因，等我以后进行了更深层次的学习后，再来补上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://stackoverflow.com/questions/65455024/mutilple-definition-when-linking-object-files" target="_blank" rel="noopener">Mutilple definition when linking object files</a></p></li><li><p><a href="https://stackoverflow.com/questions/57516685/why-does-the-same-class-being-defined-in-multiple-cpp-files-not-cause-a-linker" target="_blank" rel="noopener">Why does the same class being defined in multiple .cpp files not cause a linker multiple definition error?</a></p></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://stackoverflow.com/questions/14909997/why-arent-my-include-guards-preventing-recursive-inclusion-and-multiple-symbol" target="_blank" rel="noopener">Why aren’t my include guards preventing recursive inclusion and multiple symbol definitions?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.cppreference.com/w/cpp/language/definition" target="_blank" rel="noopener">Definitions and ODR (One Definition Rule)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-酒店管理系统</title>
    <link href="/OOP-%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html"/>
    <url>/OOP-%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某酒店有客房若干间，其中客房分为不同等级，如豪华、标准、普通等，客房床位数也不同。例如，豪华套房有4个床位，400元/晚；标准客房2个床位，200元/晚；普通客房1个床位，100元/晚。</p><p>顾客分金卡会员、银卡会员、普通会员及非会员，其享受的折扣不同。例如，金卡会员可享受8折优惠，银卡会员可享受9折优惠，普通会员享受95折优惠，非会员不享受优惠。</p><p>当顾客连续入住多天时，也可享受一定的折扣。例如，当顾客连续入住2 - 4晚时，可享受9折优惠；连续入住5 - 8晚时，可享受85折优惠；连续入住9晚以上时，可享受8折优惠。</p><p>采用面向对象的思想，建立系统中清晰的类，分析和定义各个类，每个类中要有各自的属性和方法，并开发一套客房管理系统，实现如下功能：<br>​ （1） 管理员：以管理员身份登录系统，查询当前客房入住及预订情况，并设置客房价格、顾客优惠政策等；<br>​ （2） 酒店前台：以前台身份登录系统，查询当前客房入住及预订情况，为顾客办理入住、退房、换房等服务；顾客退房后为顾客计算消费金额并收费；<br>​ （3） 顾客：可以注册和登录系统，用户在查找到心仪的客房后，登录酒店客房管理系统可提交订单实现客房预订；未入住酒店前1天，可取消客房预订；顾客入住退房后可评论。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目要求我们采用面向对象的思想，为管理员、酒店前台与顾客开发一套酒店管理系统。管理员需要能够登陆系统、查看客房的入住与预定情况、修改客房的价格以及顾客的优惠政策；前台也需要能够登录系统、查看客房的入住与预定情况，还需要能够为顾客办理手续和收费；而顾客需要能够进行注册与登录、选房、预订与评论等操作。</p><p>分析题目可以发现，不同人员的操作存在着一些共性，他们都需要登陆系统、也都可以查看评论。虽然所有人都可以要查看客房的情况，但内部人员和顾客的查看操作是不同的：内部人员需要能够查看当前入住情况、所有的预订情况和指定日期范围的预订情况，而顾客只需看到他们指定日期范围内空闲的客房情况。另外，顾客优惠的政策是所有人可见的，但却只有管理员可以更改。</p><p>要设计一个上述的管理系统，除了业务逻辑，还需要有交互式的界面，本次大作业使用了Qt Creator进行界面设计。除此之外，我们还需要存储人员及客房的相关信息，在这里我们采用Mysql的本地数据库进行存储。</p><h2 id="类图设计及说明"><a href="#类图设计及说明" class="headerlink" title="类图设计及说明"></a>类图设计及说明</h2><h3 id="业务逻辑类图"><a href="#业务逻辑类图" class="headerlink" title="业务逻辑类图"></a>业务逻辑类图</h3><pre><code class="hljs mermaid">classDiagram    User &lt;|-- Insider    User &lt;|-- Customer    Insider &lt;|-- Manager    Insider &lt;|-- Receptionclass User &#123;&lt;&lt;abstract&gt;&gt;+checkAllReviews() QsqlQuery+login()* int-QString account-QString password&#125;class Customer &#123;+login() int+getAvailRooms(const QDate&amp;, const QDate&amp;) QSqlQuery+book(const QString&amp;, const QDate&amp;, const QDate&amp;) bool+cancelBook(const QString&amp;, const QDate&amp;) bool+getHistoricalOrders() QSqlQuery+review(const QString&amp;, const QDate&amp;, const QString&amp;) bool+signUp(const QString&amp;, const QString&amp;) bool&#125;class Insider &#123;+login() int+getCheckInInfo(bool) QSqlQuery+getBookInfo(bool) QSqlQuery+getBookInfo(const QDate&amp;, const QDate&amp;, bool) QSqlQuery&#125;class Manager &#123;+setRoomPrice(char, size_t) void+setMemberDiscount(char level, double newDicount) void+setDayDiscount(size_t lo, size_t hi, double newDiscount) bool&#125;class Reception &#123;+checkin(const QString&amp;, const QString&amp;, const QDate&amp;) bool+changeRoom(const QString&amp;, const QString&amp;) bool+checkOut(const QString&amp;, const QString&amp;, const QDate&amp;) bool+calCost(const QString&amp;, const QString&amp;, size_t) double&#125;</code></pre><p>由上述分析，我们可以将业务逻辑抽象表示为以下六个类：用户抽象类<code>User</code>，内部人员类<code>Insider</code>，顾客类<code>Customer</code>，管理员类<code>Manager</code>，前台类<code>Reception</code>和优惠政策类<code>Policy</code>（后文均用类名指代）。</p><p><code>Manager</code>类与<code>Reception</code>类继承<code>Insider</code>类，而<code>Insider</code>类与<code>Customer</code>类又都是<code>User</code>类的子类。<code>User</code>类中有<code>account</code>和<code>password</code>两个私有变量，即每个登录到管理系统的人员都有自己的账号与密码。因为内部人员和顾客的账号密码存在不同的数据库表中，所以<code>User</code>还有一个抽象函数<code>login()</code>，而<code>Insider</code>和<code>Customer</code>分别重写了它。</p><h3 id="系统类图"><a href="#系统类图" class="headerlink" title="系统类图"></a>系统类图</h3><pre><code class="hljs mermaid">classDiagramLoginForm ..&gt; CustomerFormLoginForm ..&gt; ManagerFormLoginForm ..&gt; ReceptionForm    ManagerForm *-- Manager    ReceptionForm *-- Reception    CustomerForm *-- Customer    Manager o-- DatabaseUtils    Reception o-- DatabaseUtils    Customer o-- DatabaseUtils    class LoginForm &#123;+on_signInButton_clicked() void+on_registerButton_clicked() void-CustomerWin *customerWin;    -ManagerWin *managerWin;    -ReceptionWin *receptionWin;&#125;class CustomerForm &#123;+on_book_clicked() void    +on_getRooms_clicked() void    +on_bookedRooms_clicked() void    +on_cancelBook_clicked() void    +on_historicalOrders_clicked() void    +on_writeReview_clicked() void    +on_allReviews_clicked() void    +on_tableView_clicked(const QModelIndex &amp;) void    -Customer customer;    -WriteReview *review;&#125;class ManagerForm &#123;+on_checkinInfo_clicked() void+on_allBookInfo_clicked() void+on_checkInfo_clicked() void+modify_clicked() void+on_allReviews_clicked() void void-Manager manager-ModifyInfo *modifyInfo&#125;class ReceptionForm &#123;+on_checkinInfo_clicked() void+on_allBookInfo_clicked() void+on_checkInfo_clicked() void+on_checkin_clicked() void+on_checkout_clicked() void+on_changeRoom_clicked() void+on_allReviews_clicked() void+on_tableView_clicked(const QModelIndex &amp;) void-Reception reception-ChangeRoom* changeRoom&#125;class Customer &#123;&#125;class Manager &#123;&#125;class Reception &#123;&#125;class DatabaseUtils &#123;+connect() void+close() void+executeUpdate(const QString&amp;, const QVariantList&amp; args &#x3D; QVariantList()) bool+executeSelect(const QString&amp;, const QVariantList&amp; args &#x3D; QVariantList()) QSqlQuery&#125;</code></pre><p>表示层有四个用户界面，初始是登陆界面<code>LoginForm</code>，根据账号的不同分别进入三个不同的业务处理界面：管理员的<code>ManagerForm</code>、酒店前台的<code>ReceptionForm</code>和顾客的<code>CustomerForm</code>。这三个界面有着不同的控件，对应着不同的槽函数，槽函数中调用了业务逻辑层中对应类的函数来完成业务的处理。而业务逻辑层中的处理有时需要访问数据库，这时就需要调用数据库访问帮助类<code>DatabaseUtils</code>来完成数据的增删查改。</p><h2 id="E-R图设计及说明"><a href="#E-R图设计及说明" class="headerlink" title="E-R图设计及说明"></a>E-R图设计及说明</h2><p>（由于本门课是面向对象程序设计，数据库部分简略带过）</p><h3 id="系统E-R图"><a href="#系统E-R图" class="headerlink" title="系统E-R图"></a>系统E-R图</h3><p><img src="/img/posts/hotelMS系统E-R图.png" srcset="/img/loading.gif" alt=""></p><p>一个顾客账号可以预订多个客房，且顾客可以对每个订单进行不同的评价。根据订单的进度，订单可能是以下状态的一种：已预订、已入住或已完成。</p><h3 id="内部人员E-R图"><a href="#内部人员E-R图" class="headerlink" title="内部人员E-R图"></a>内部人员E-R图</h3><p><img src="img/posts/hotelMS内部人员E-R图.png" srcset="/img/loading.gif" alt=""></p><p>内部人员的账号密码独立存在一个表中。</p><h2 id="系统功能设计"><a href="#系统功能设计" class="headerlink" title="系统功能设计"></a>系统功能设计</h2><p><img src="img/posts/hotelMS系统功能设计.png" srcset="/img/loading.gif" alt=""></p><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>实现流程表示如下：</p><p>（注：紫色矩形表示的是操作的名称，蓝色矩形才是实际的操作）</p><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p><img src="img/posts/hotelMS管理员流程图.png" srcset="/img/loading.gif" alt=""></p><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><p><img src="img/posts/hotelMS前台流程图.png" srcset="/img/loading.gif" alt=""></p><h3 id="顾客"><a href="#顾客" class="headerlink" title="顾客"></a>顾客</h3><p><strong>注：这里的有效时间是在题目的基础上，参考了现实中酒店的做法，设定为入住日期前一天17:00前</strong>。</p><p><img src="img/posts/hotelMS顾客流程图.png" srcset="/img/loading.gif" alt=""></p><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><ol><li><p>类的继承关系不明</p><p>一开始没有insider这个类，因为以为查看房间情况的函数是通用的，只需<code>Manager</code>、<code>Reception</code>与<code>Customer</code>各自重写即可，后来才发现内部人员的查看方式较为多样，需要一个内部人员类才行。</p></li><li><p>订单状态不知如何处理</p><p>因为顾客入住酒店是有三种状态的：预订、入住与退房，一开始想建立三个联系表，当预订转为入住，就从预订表中删除并添加到入住表中；退房时，将从入住表中删除并添加到已完成订单表中。但后来通过与同学讨论，找到了更简单有效的方法，即只建立一个联系表，订单加上一个状态字段表示其状态。</p></li><li><p>政策是否应该抽象为类</p><p>一开始我将政策抽象为一个<code>Policy</code>类，优惠政策为静态私有变量，所有人员可以通过其静态成员函数获取当前的政策，而<code>Manager</code>类是友元类，可以直接修改优惠政策。但后来我才发现这样有很大的问题，管理员通过成员函数修改<code>Policy</code>的静态私有变量是只在运行时有效的，当程序再次运行时又会恢复原样；且一个类全是静态函数与静态变量，似乎这个类也没有存在的必要。因此，我将<code>Policy</code>类删除，将优惠政策放入数据库中。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">深入浅出UML类图</a></li><li><a href="https://www.yzer.club/markdown-mermaid-class-diagram/" target="_blank" rel="noopener">Markdown 中使用 mermaid 类图</a></li><li><a href="https://www.meetingcpp.com/blog/items/refactoring-my-qt-database-code.html" target="_blank" rel="noopener">Refactoring my Qt database code</a></li><li><a href="https://blog.csdn.net/u012940001/article/details/76622730" target="_blank" rel="noopener">PO、BO、VO、POJO、DTO、DAO分别代表什么意思</a></li><li><a href="https://stackoverflow.com/questions/28388666/how-to-check-if-two-date-ranges-overlap-in-mysql" target="_blank" rel="noopener">How to check if two date ranges overlap in mysql?</a></li><li><a href="https://blog.csdn.net/wojiuguowei/article/details/71294434" target="_blank" rel="noopener">QT QTableView 获取单击选中行的内容</a></li><li><a href="https://blog.csdn.net/qq_33308135/article/details/98038794" target="_blank" rel="noopener">Qt 多个控件 对应一个槽函数</a></li><li><a href="https://blog.csdn.net/weixin_43384257/article/details/89294811" target="_blank" rel="noopener">Qt把QString类型转换为char类型</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">三层架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>面向对象程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地图路由</title>
    <link href="/%E5%9C%B0%E5%9B%BE%E8%B7%AF%E7%94%B1.html"/>
    <url>/%E5%9C%B0%E5%9B%BE%E8%B7%AF%E7%94%B1.html</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>目标。</strong>优化 Dijkstra 算法,使其可以处理给定图的数千条最短路径查询。 一旦你读取图(并<br>可选地预处理),你的程序应该在<strong>亚线性时间</strong>内解决最短路径问题。一种方法是预先计算出<br>所有顶点对的最短路径;然而,你无法承受存储所有这些信息所需的二次空间。你的目标是<br>减少每次最短路径计算所涉及的工作量,而不会占用过多的空间。 建议你选择下面的一些<br>潜在想法来实现,或者你可以开发和实现自己的想法。</p><p><strong>想法 1.</strong> Dijkstra 算法的朴素实现检查图中的所有 V 个顶点。 减少检查的顶点数量的一种策<br>略是一旦发现目的地的最短路径就停止搜索。 通过这种方法,可以使每个最短路径查询的<br>运行时间与 E’ log V’成比例,其中 E’和 V’是 Dijkstra 算法检查的边和顶点数。</p><p><strong>想法 2.</strong> 你可以利用问题的欧式几何来进一步减少搜索时间,这在算法书的第 4.4 节描述过。<br>对于一般图,Dijkstra 通过将 d[w]更新为 d[v] + 从 v 到 w 的距离来松弛边 v-w。 对于地图,<br>则将 d[w]更新为 d[v] + 从 v 到 w 的距离 + 从 w 到 d 的欧式距离 − 从 v 到 d 的欧式距离。<br>这种方法称之为 A*算法。这种启发式方法会有性能上的影响,但不会影响正确性。</p><p><strong>想法 3.</strong> 使用更快的优先队列。 在提供的优先队列中有一些优化空间。 你也可以考虑使用<br>Sedgewick 程序中的多路堆(Multiway heaps, Section 2.4)。</p><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>我们将分别完成题述的三个想法，将过程可视化，并比较运行时间。</p><p>本文都以起点：6000，终点：1000为例。</p><p><a href="https://github.com/seineo/Algorithms/tree/master/Part2/usa.txt" target="_blank" rel="noopener">测试数据</a></p><p>最终代码：</p><ul><li><a href="https://github.com/seineo/Algorithms/tree/master/Part2/MapRouting.java" target="_blank" rel="noopener">MapRouting.java</a></li><li><a href="https://github.com/seineo/Algorithms/tree/master/Part2/Dijkstra.java" target="_blank" rel="noopener">Dijkstra.java</a></li></ul><h3 id="想法一"><a href="#想法一" class="headerlink" title="想法一"></a>想法一</h3><p>即给定目的地，遇到目的地就停止（early exit）。</p><p>输出如下：</p><pre><code class="hljs shell">running time :358.943s1000 to 6000distance: 6637.540854006546</code></pre><p>可视化如下：</p><p><img src="img/posts/MapRouting1.png" srcset="/img/loading.gif" alt=""></p><p>运行过程中，算法从出发点一圈一圈往外探索，直至遇到目的地。</p><h3 id="想法二"><a href="#想法二" class="headerlink" title="想法二"></a>想法二</h3><p>即给dijkstra加一个启发函数，优先级不止考虑当前点到出发点的距离，也将考虑到目的地的距离。</p><p>输出如下：</p><pre><code class="hljs shell">running time :111.123s1000 to 6000distance: 6637.540854006546</code></pre><p>可视化如下：</p><p><img src="img/posts/MapRouting2.png" srcset="/img/loading.gif" alt=""></p><p>可见，A*算法比dijkstra算法更具目的性，直指目的地探索，运行时间不到dijkstra算法的三分之一。</p><h3 id="想法三"><a href="#想法三" class="headerlink" title="想法三"></a>想法三</h3><p>即更换优先队列，这里我们将索引优先队列更改为索引2-路优先队列。</p><p>输出如下：</p><pre><code class="hljs shell">running time :107.39s1000 to 6000distance: 6637.540854006546</code></pre><p>可视化如下：</p><p><img src="img/posts/MapRouting3.png" srcset="/img/loading.gif" alt=""></p><p>可以发现，使用多路优先队列运行时间又减少了一些。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++返回值优化</title>
    <link href="/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96.html"/>
    <url>/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96.html</url>
    
    <content type="html"><![CDATA[<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span>  <span class="hljs-keyword">public</span>:    Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" default constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    Test(<span class="hljs-keyword">const</span> Test &amp;that) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" copy constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    ~Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" deconstructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-function">Test <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;    Test temp;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;    Test a = func();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>上述代码的调用流程应该是这样的：</p><ol><li>调用temp 的构造函数</li><li>函数返回值会调用临时对象复制构造函数</li><li>调用a的复制构造函数</li><li>调用返回的临时对象的析构函数</li><li>调用a的析构函数</li></ol><p>但实际的输出却是这样的：</p><pre><code class="hljs delphi"><span class="hljs-number">0</span>x61fe0f <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fe0f</span> <span class="hljs-title">deconstructor</span></span></code></pre><p>经过一步步调试发现，其只进行了上述调用流程的第一步和最后一步。</p><p>为什么呢？查询资料后发现，这是C++的一项编译优化技术，称为<strong>返回值优化</strong>，即并<strong>不进行返回值构造临时对象这一过程</strong>，这样也就不会调用复制构造函数了。</p><p>若需要，我们可以加上<code>-fno-elide-constructors</code>这一编译选项来关闭这一优化（该选项的详细说明可以在Linux终端通过<code>man gcc</code>或<code>man g++</code>命令来查看）。</p><p>在终端输入以下命令：</p><pre><code class="hljs shell">g++ -g -o test -fno-elide-constructors test.cpp./test</code></pre><p>我们可以得到以下输出：</p><pre><code class="hljs delphi"><span class="hljs-number">0</span>x61fbaf <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3f</span> <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fbaf</span> <span class="hljs-title">destructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3e</span> <span class="hljs-title">copy</span> <span class="hljs-title">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3f</span> <span class="hljs-title">destructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3e</span> <span class="hljs-title">destructor</span></span></code></pre><p>该输出符合上述调用流程。</p><p>另外，<strong>函数返回值其实是优先调用移动构造函数的</strong>。若定义了移动构造函数，它将调用移动构造函数而非复制构造函数。当然，若我们自己并未定义移动构造函数，它也就只能调用复制构造函数了。</p><p>我们在代码中加入移动构造函数：</p><pre><code class="hljs cpp">Test(Test &amp;&amp;that) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" move constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;</code></pre><p>并关掉返回值优化，则运行结果为：</p><pre><code class="hljs delphi"><span class="hljs-number">0</span>x61fbaf <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3f</span> <span class="hljs-title">move</span> <span class="hljs-title">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fbaf</span> <span class="hljs-title">destructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3e</span> <span class="hljs-title">move</span> <span class="hljs-title">constructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3f</span> <span class="hljs-title">destructor</span></span><span class="hljs-function">0<span class="hljs-title">x61fd3e</span> <span class="hljs-title">destructor</span></span></code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="栈帧提前构造"><a href="#栈帧提前构造" class="headerlink" title="栈帧提前构造"></a>栈帧提前构造</h4><p>对于返回值优化，一种实现方法是在调用函数（caller）在栈帧上声明一个隐藏对象，然后将其地址隐蔽地传入被调用函数（callee），被调用函数的返回值直接构造到该地址上。如下所示：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span>  <span class="hljs-keyword">public</span>:    Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" default constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    Test(<span class="hljs-keyword">const</span> Test &amp;that) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" copy constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    <span class="hljs-comment">// Test(Test &amp;&amp;that) &#123; cout &lt;&lt; this &lt;&lt; " move constructor" &lt;&lt; endl; &#125;</span>    ~Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" destructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-function">Test* <span class="hljs-title">func</span><span class="hljs-params">(Test* hidden)</span> </span>&#123;    Test temp;    *hidden = temp;      <span class="hljs-keyword">return</span> hidden;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;    Test hidden;    Test a = *func(&amp;hidden);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>注意：由于第14行是需要调用赋值运算符的，所以我们这里将移动构造函数注释了。（移动构造函数与赋值运算符不能共存）</p><p>输出如下：</p><pre><code class="hljs cpp"><span class="hljs-number">0x61fd3f</span> <span class="hljs-keyword">default</span> constructor<span class="hljs-number">0x61fc7f</span> <span class="hljs-keyword">default</span> constructor<span class="hljs-number">0x61fc7f</span> destructor<span class="hljs-number">0x61fd3e</span> copy constructor<span class="hljs-number">0x61fd3e</span> destructor<span class="hljs-number">0x61fd3f</span> destructor</code></pre><p>可见这种方法优化并不明显，仅是将一个复制构造函数换成了普通构造函数。</p><h4 id="命名返回值优化"><a href="#命名返回值优化" class="headerlink" title="命名返回值优化"></a>命名返回值优化</h4><p>另一方法是命名法返回值优化，其去除了基于栈的构造与析构，而是直接将返回值移进目标对象的地址。如下所示：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span>  <span class="hljs-keyword">public</span>:    Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" default constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    Test(<span class="hljs-keyword">const</span> Test &amp;that) &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" copy constructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;    <span class="hljs-comment">// Test(Test &amp;&amp;that) &#123; cout &lt;&lt; this &lt;&lt; " move constructor" &lt;&lt; endl; &#125;</span>    ~Test() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">" destructor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Test *target)</span> </span>&#123;    Test temp;    *target = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;    Test a;    func(&amp;a);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出如下：</p><pre><code class="hljs routeros">0x61fd3f<span class="hljs-built_in"> default </span>constructor0x61fc8f<span class="hljs-built_in"> default </span>constructor0x61fc8f destructor0x61fd3f destructor</code></pre><p>这一方法的效率已经很高了，但还是与实际编译器的输出略有不同，或许实际中编译器或许进行了更多更复杂的优化吧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zh.m.wikipedia.org/zh-hans/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">维基百科：返回值优化</a></li><li><a href="https://stackoverflow.com/questions/45336433/move-constructor-called-on-return-instead-of-copy" target="_blank" rel="noopener">move constructor called on return instead of copy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP - C++笔记</title>
    <link href="/OOP-C-%E7%AC%94%E8%AE%B0.html"/>
    <url>/OOP-C-%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="错误：此声明没有存储类或类型说明符"><a href="#错误：此声明没有存储类或类型说明符" class="headerlink" title="错误：此声明没有存储类或类型说明符"></a>错误：此声明没有存储类或类型说明符</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">namespace</span> ns1 &#123;    <span class="hljs-keyword">int</span> inflag;&#125;<span class="hljs-keyword">namespace</span> ns2 &#123;    <span class="hljs-keyword">int</span> inflag;&#125;ns1::inflag = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 错误：此声明没有存储类或类型说明符</span>ns2::inflag = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 错误：此声明没有存储类或类型说明符</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; ns1::inflag &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; ns2::inflag &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果将9、10行代码移入主函数内就不会报错。</p><p>这是因为上述代码的9、10行是赋值语句，而在Cpp中<strong>函数外只能定义全局变量或者对象 ，而不能执行语句及调用函数 。</strong>因此，移到函数内，那么赋值语句是允许的。</p><h3 id="重载函数的要求"><a href="#重载函数的要求" class="headerlink" title="重载函数的要求"></a>重载函数的要求</h3><p>重载函数的参数个数或类型必须至少有其中之一不同。<strong>不允许重载的函数只有返回类型不同。</strong></p><p>函数模板不是一个实实在在的函数，<strong>编译系统并不产生任何执行代码</strong>。当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便<strong>生成一个重载函数</strong>，该重载函数的函数体与函数模板的函数体相同。</p><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>需要复制构造函数的三种情况</p><ol><li><p>新建立一个对象，需要另一个对象对其初始化</p><pre><code class="hljs cpp"><span class="hljs-function">Box <span class="hljs-title">box1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">Box <span class="hljs-title">box2</span><span class="hljs-params">(box1)</span></span>;</code></pre></li><li><p>对象作为形参</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Box b)</span> </span>&#123;    ...&#125;</code></pre></li><li><p>对象作为返回值</p><pre><code class="hljs kotlin">Box <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123; ...&#125;</code></pre></li></ol><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>需要在类外初始化</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x, y;&#125;<span class="hljs-keyword">int</span> A::x = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> A::y = <span class="hljs-number">1</span>;</code></pre><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>类内外定义均可</p><pre><code class="hljs cpp"><span class="hljs-comment">// 类内</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">number</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">// 或者类外</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::number</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h3><h4 id="指向非静态成员函数的指针"><a href="#指向非静态成员函数的指针" class="headerlink" title="指向非静态成员函数的指针"></a>指向非静态成员函数的指针</h4><p>形式：数据类型名 (类名:: 指针变量名)(参数列表) = 类名::成员函数名；</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> (Point::*getxP)() = Point::getX;<span class="hljs-built_in">cout</span> &lt;&lt; (p.*getxP)() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h4 id="指向静态成员（函数）的指针"><a href="#指向静态成员（函数）的指针" class="headerlink" title="指向静态成员（函数）的指针"></a>指向静态成员（函数）的指针</h4><p>对类的静态成员的访问是不依赖于对象的，因此可以用<strong>普通的指针</strong>来指向和访问静态成员。</p><pre><code class="hljs cpp"><span class="hljs-comment">// 静态成员变量</span><span class="hljs-keyword">int</span> *countp=&amp;Point::count;<span class="hljs-comment">// 静态成员函数</span><span class="hljs-keyword">void</span> (*gc)()=Point::GetC;<span class="hljs-comment">// 调用</span>(*gc)();</code></pre><h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>先调用对象成员的构造函数，再调用本类的构造函数。析构函数的调用顺序刚好相反。</p><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>在<strong>类模板外</strong>定义成员函数时，每一个函数前均加上：</p><p>template<class 类型参数></class></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载本质上是一种特殊的<strong>函数重载</strong>，运算符重载的函数参数就是该运算符涉及的操作数，因此运算符重载在参数个数上是有限制的（作为成员函数，参数最多有一个；作为友元函数，最多两个），这是它<strong>不同于普通的函数重载之处</strong>。</p><h4 id="自增运算符"><a href="#自增运算符" class="headerlink" title="自增运算符"></a>自增运算符</h4><p>++为前置运算符时，它的运算符重载函数的一般格式为：</p><p><strong><type>operator ++( )</type></strong></p><p>++为后置运算符时，它的运算符重载函数的一般格式为：</p><p><strong><type>operator ++(int)</type></strong></p><h4 id="两种重载方式"><a href="#两种重载方式" class="headerlink" title="两种重载方式"></a>两种重载方式</h4><p>当运算符重载为<strong>类的成员函数</strong>时，对于单目运算符，操作数一定是对象本身，<strong>对于双目运算符，左操作数一定是对象</strong>。</p><p>当运算符重载为友元函数时，参数中同样必须有一个是用户自定义类型的对象，<strong>但不限定其必须是左操作数</strong></p><h3 id="基本类型与类类型的转换"><a href="#基本类型与类类型的转换" class="headerlink" title="基本类型与类类型的转换"></a>基本类型与类类型的转换</h3><h4 id="基本类型到类类型"><a href="#基本类型到类类型" class="headerlink" title="基本类型到类类型"></a>基本类型到类类型</h4><p>转换构造函数，如；</p><pre><code class="hljs cpp">Complex(<span class="hljs-keyword">double</span> r) &#123;    real = r;    imag = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 有了上述函数，以下语句即合法</span>Complex c = <span class="hljs-number">3.14</span>;</code></pre><h4 id="类类型到基本类型"><a href="#类类型到基本类型" class="headerlink" title="类类型到基本类型"></a>类类型到基本类型</h4><p>要将类对象转换为基本类型数据，需要一个特殊的<strong>成员函数</strong>——<strong>类型转换函数</strong>（实际就是类型转换运算符的重载，也正因为其实是对运算符的重载，这一函数只能是成员函数而不能是友元函数，与因为运算符重载的对象需要this指针）。</p><pre><code class="hljs cpp"><span class="hljs-comment">// 格式  （注意，没有返回值和参数！</span><span class="hljs-keyword">operator</span>〈返回基本类型名〉（）&#123;    ……    <span class="hljs-keyword">return</span> 〈基本类型值〉&#125;</code></pre><p>例：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span>    <span class="hljs-keyword">double</span> Real, Imag;  <span class="hljs-keyword">public</span>:...    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//成员函数，定义类转换 Complex－&gt;double</span>&#125;;<span class="hljs-function">Complex::<span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> Real * Real + Imag * Imag; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)</span></span>;    <span class="hljs-keyword">double</span> d;    d = <span class="hljs-number">2.5</span> + c1; <span class="hljs-comment">// 隐式调用类型转换函数</span>    <span class="hljs-built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 隐式调用类型转换函数</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h3><p>类的继承方式有public公有继承)、protected(保护继承)和private(私有继承)三种。<strong>默认情况下为私有继承</strong>。</p><p>三种继承方式下<strong>派生类中</strong>基类成员的访问控制权限</p><div class="table-container"><table><thead><tr><th></th><th>公有继承</th><th>私有继承</th><th>保护继承</th></tr></thead><tbody><tr><td>公有成员</td><td>公有</td><td>私有</td><td>保护</td></tr><tr><td>私有成员</td><td>派生类成员无法访问</td><td>派生类成员无法访问</td><td>派生类成员无法访问</td></tr><tr><td>保护成员</td><td>保护</td><td>私有</td><td>保护</td></tr></tbody></table></div><h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><h5 id="派生类调用基类的构造函数"><a href="#派生类调用基类的构造函数" class="headerlink" title="派生类调用基类的构造函数"></a>派生类调用基类的构造函数</h5><p>派生类只能在构造函数的初始化列表中调用基类的构造函数，而<strong>不能在函数体中调用</strong>。</p><pre><code class="hljs cpp">Rectangle(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height)        :Point(x, y), w(width), h(height) &#123;&#125;  <span class="hljs-comment">// √</span>Rectangle(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height)        :w(width), h(height) &#123;Point(x, y);    <span class="hljs-comment">// ×  </span>&#125;</code></pre><p>因为是先调用基类的构造函数再调用派生类的构造函数，而函数体就已经是在派生类的构造函数了，因此会先调用基类的默认构造函数，这里的初始化目的并没有达到，因为派生类构造函数体中的基类构造函数调用只是对一个临时对象进行了初始化（调试时发现this指针不同）。</p><h5 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h5><p>构造函数调用顺序为：基类的构造函数→对象成员构造函数→派生类的构造函数。</p><p>析构函数调用顺序刚好相反。</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表顺序无关。</p><p>如果有多个成员类对象，则构造函数的调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序。</p><p>派生类新增加的同名成员会隐藏基类中的同名成员，因此</p><pre><code class="hljs cpp"><span class="hljs-comment">// 若C是A和B的派生类且三个类都有a成员变量</span>C c1;c1.a = <span class="hljs-number">3</span>;    <span class="hljs-comment">//这样是修改了C类的成员</span><span class="hljs-comment">// 若想访问基类的成员，需要加作用域运算符</span>c1.A::a = <span class="hljs-number">3</span>;c1.B::a = <span class="hljs-number">3</span>;</code></pre><h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p><img src="C:\Users\10132\AppData\Roaming\Typora\typora-user-images\image-20201202170517362.png" srcset="/img/loading.gif" alt="image-20201202170517362"></p><p>这样的话C类会从A类和B类继承下来两份N类的成员，这时就无法区分了。</p><p>为了避免出现这样的二义性问题，可以将直接基类（如A、B）的共同基类（如N）设置为虚基类，这样共同基类（N）在<strong>内存中只有一个副本存在</strong>（<strong>因此其构造函数也只会调用一次</strong>）。</p><p>虚基类的定义格式为：</p><p>class &lt;派生类名&gt;: <strong>virtual</strong> &lt;继承方式&gt;&lt;共同基类名&gt;;</p><p>为了保证虚基类在派生类中只继承一次，应当在该基类的<strong>所有直接派生类</strong>中声明为虚基类。</p><h5 id="包含虚基类的构造函数调用顺序"><a href="#包含虚基类的构造函数调用顺序" class="headerlink" title="包含虚基类的构造函数调用顺序"></a>包含虚基类的构造函数调用顺序</h5><ol><li><p>先调用虚基类的构造函数，再调用非虚基类的构造函数。</p></li><li><p>若同一层次中包含多个虚基类，其调用顺序为<strong>定义时的顺序</strong>。</p></li><li><p>若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序。</p></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>从系统实现的角度，多态性分为两类：</p><ol><li><p><strong>静态多态性</strong>：在程序编译时系统就能决定调用的是哪个函数。又称为编译时的多态性。静态多态性是通过函数的重载实现的（包括运算符重载）。</p></li><li><p><strong>动态多态性</strong>：在程序运行过程中才动态地确定操作所针对的对象。又称为运行时的多态性。<strong>动态多态性是通过虚函数实现的</strong>。</p></li></ol><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>虚函数的使用：</p><ol><li>类之间应满足类型兼容原则</li><li>同名声明虚函数</li><li>通过指针、引用来访问虚函数</li></ol><p>注意，类型兼容原则是以下三种情况：</p><ol><li>派生类的对象可以赋值给基类的对象。</li><li>派生类的对象可以初始化基类的引用。</li><li>派生类的对象的地址可以赋值给基类的指针变量。</li></ol><p>而访问虚函数只能是后两者。</p><p>若要访问派生类中相同名字的函数，必须将<strong>基类中的同名函数定义为虚函数</strong>，这样，就可以动态地根据基类的引用或指针调用不同类中的函数。</p><p>一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。</p><p><strong>构造函数不能是虚函数。</strong> 虚函数作为运行时的多态性的基础，主要是针对对象的，而构造函数是在对象产生之前运行的。所以，将构造函数声明为虚函数是没有意义的。</p><p><strong>析构函数可以是虚函数</strong>。比如释放内存时，由于实施多态性时是通过将基类的指针指向派生类的对象来完成的，如果删除该指针，就会调用该指针指向的派生类的析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象才被完全释放。</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;) = 0</p><p>纯虚函数不定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>包含一个或多个纯虚函数的类称为抽象类。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>面向对象程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编实验：统计数字个数</title>
    <link href="/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0.html"/>
    <url>/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个字符串，统计数字出现的次数。</p><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="img/posts/汇编实验三.png" srcset="/img/loading.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs asm">data segmentbuffer db 5 dup(?)input db &#39;please input a number &lt;&#x3D; 5 digits&#39;, 0ah, 0dh, &#39;$&#39;outOfBound db 0ah, 0dh, &#39;error: more than 5 digits&#39;,0ah, 0dh, &#39;$&#39;notANum db 0ah, 0dh, &#39;error: not a number&#39;,0ah, 0dh,&#39;$&#39;data endscode segment      assume ds:data, cs:codestart:mov bl, 0l4:mov ah, 01hint 21hcmp al, 20h   ; 空格结束输入je countcmp al, byte ptr &#39;0&#39;jb l4cmp al, byte ptr &#39;9&#39;ja l4inc bljmp l4count:       mov ah, 0    mov al, bl    ; 将要输出的数字    or  ax, ax    jz  zero    ; 是零则直接输出    mov bx, -1    ; 栈底    push bx    mov bx, 10    ; 除数l5:xor dx, dx   ; 余数清零   div bx   mov cx , ax   ;商   or  cx , dx   jz  print   ; 商与余数全零则结束   push dx   jmp l5zero:  mov dl , 30h   mov ah , 02h   int 21hjmp exit   print:   pop dx   cmp dx , -1   je  exit   add dx , 30h   mov ah , 02h   int 21h   jmp printexit:mov ah, 08h  ;结束时停留int 21h   mov ah , 4ch                  ;返回DOS   int 21hcode endsend start</code></pre>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编实验：十进制转二进制</title>
    <link href="/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html"/>
    <url>/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>重复从键盘输入不超过5位的十进制数，按回车键结束输入</li><li>将该十进制数转换成二进制数；结果以2进制数的形式显示在屏幕上</li><li>如果输入非数字字符，则报告出错信息，重新输入</li><li>直到输入’Q’或’q’时程序运行结束</li></ol><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="img/posts/汇编实验二.png" srcset="/img/loading.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs asm">data segmentbuffer db 5 dup(?)input db &#39;please input a number &lt;&#x3D; 5 digits&#39;, 0ah, 0dh, &#39;$&#39;outOfBound db 0ah, 0dh, &#39;error: more than 5 digits&#39;,0ah, 0dh, &#39;$&#39;notANum db 0ah, 0dh, &#39;error: not a number&#39;,0ah, 0dh,&#39;$&#39;data endscode segment      assume ds:data, cs:codestart:mov    ax, data    mov    ds, axmov bx, 0mov si, offset buffermov ah, 09hmov dx, offset inputint 21hl1:   ; 输入及判定mov ah, 01hint 21hcmp al, byte ptr &#39;q&#39;je overcmp al, byte ptr &#39;Q&#39;je overcmp al, 0dhje dealinc bxcmp bx, 5  ja error1cmp al, byte ptr &#39;0&#39;jb error2cmp al, byte ptr &#39;9&#39;ja error2mov [si], alinc sijmp l1deal:  ; 输入结束，处理数字mov cx, bxmov si, offset buffermov ah, 0   ; 清除高位mov al, [si]sub al, 30hcmp cx, 1  ; 一位数则直接输出je printOnedec cxl2:mov bx, 0ahmul bxinc simov bl, [si]sub bx, 30hadd ax, bxloop l2jmp printAllerror1:mov ah, 09hmov dx, offset outOfBoundint 21hjmp starterror2:mov ah, 09hmov dx, offset notANumint 21hjmp startprintOne:mov ah, 02hadd al, 30hmov dl, alint 21hjmp overprintAll:mov cx, 10hmov bx, axl3:mov ax, bxand ax, 8000h  ; 取最高位rol ax, 1  ; 循环左移，将最高位移到最低位mov ah, 02hadd al, 30hmov dl, alint 21hshl bx, 1loop l3over:mov ah, 4chint 21hcode endsend start</code></pre>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编实验：字符转ASCII码</title>
    <link href="/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%BD%ACASCII%E7%A0%81.html"/>
    <url>/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%BD%ACASCII%E7%A0%81.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>循环从键盘读入字符并回显在屏幕上，然后显示出对应字符的ASCII码，直到输入”Q”或“q”时结束。</p><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p>本题的核心在于如何将字符转成其对应的ASCII码</p><p><img src="img/posts/汇编实验一.png" srcset="/img/loading.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs assembly">data segmentdata endscode segment      assume ds:data, cs:codestart:      mov    ax, data      mov    ds, axp3:  mov    ah, 01h  int    21h  cmp    al, &#39;q&#39;  je     over  cmp    al, &#39;Q&#39;  je     over  mov    dh, 02h   ; 循环次数，循环两次，分别取高四位和低四位  mov    dl, al  mov    ch, al ; 将值暂存到dl和ch          mov    cl, 04h      shr    dl, cl    ; 取高四位              l2:         cmp    dl, 0ah      jb     f2      add    dl, 07h                f2:         add    dl, 30h                      mov    ah, 02h      int    21h      dec    dh      mov    dl, ch      and    dl, 0fh  ; 取低字节                cmp    dh, 0h ; 是否取了低四位      ja     l2        mov    ah, 02h      mov    dl, 0ah  ; 换行，为了美观      int    21h  loop   p3  ; 循环输入，直到遇到q或Qover:    mov    ah, 08h   ; 结束时停留  int    21h  mov    ah, 4ch  int    21hcode endsend start</code></pre>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种排序算法的实验性能比较</title>
    <link href="/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.html"/>
    <url>/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.html</url>
    
    <content type="html"><![CDATA[<p>实现插入排序（Insertion Sort），自顶向下归并排序（Top-down Mergesort），自底向上归并排序（Bottom-up Mergesort），随机快速排序（Random Quicksort），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partitioning）。对不同输入规模的数据进行实验，对比上述排序算法的时间及空间占用性能。</p><h3 id="我的计算机："><a href="#我的计算机：" class="headerlink" title="我的计算机："></a>我的计算机：</h3><ul><li>CPU：Intel® Core™ i5-8265U CPU @ 1.60GHz × 8</li><li>OS：Ubuntu 20.04.1 LTS, 64位</li></ul><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>计算方法：在算法前后分别使用一次Java库函数<code>System.currentTimeMillis()</code>得到<code>startTime</code>和<code>endTime</code>，然后<code>endTime - startTime</code>即可。</p><h3 id="表格形式"><a href="#表格形式" class="headerlink" title="表格形式"></a>表格形式</h3><p>Comparison of running time of sorting algorithms (in Micro Seconds)</p><div class="table-container"><table><thead><tr><th>N=1000</th><th>Run1</th><th>Run2</th><th>Run3</th><th style="text-align:left">Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>9</td><td>9</td><td>1</td><td style="text-align:left">1</td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>2.89</td></tr><tr><td>MergeSort(top-down)</td><td>1</td><td>0</td><td>0</td><td style="text-align:left">0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0.22</td></tr><tr><td>MergeSort(bottom-up)</td><td>2</td><td>1</td><td>1</td><td style="text-align:left">1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0.89</td></tr><tr><td>QuickSort</td><td>1</td><td>0</td><td>0</td><td style="text-align:left">0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0.22</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>1</td><td>1</td><td>0</td><td style="text-align:left">0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0.44</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>N=10000</th><th>Run1</th><th>Run2</th><th>Run3</th><th>Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>189</td><td>169</td><td>92</td><td>103</td><td>84</td><td>79</td><td>80</td><td>83</td><td>79</td><td>78</td><td>106.44</td></tr><tr><td>MergeSort(top-down)</td><td>6</td><td>3</td><td>3</td><td>3</td><td>3</td><td>1</td><td>1</td><td>1</td><td>2</td><td>1</td><td>2.56</td></tr><tr><td>MergeSort(bottom-up)</td><td>5</td><td>9</td><td>12</td><td>8</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>4.78</td></tr><tr><td>QuickSort</td><td>5</td><td>3</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>1</td><td>1</td><td>2</td><td>1.89</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>5</td><td>15</td><td>5</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>4</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>N=100000</th><th>Run1</th><th>Run2</th><th>Run3</th><th>Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>11956</td><td>12658</td><td>9770</td><td>9763</td><td>9808</td><td>9803</td><td>9755</td><td>9762</td><td>9820</td><td>9822</td><td>10343.89</td></tr><tr><td>MergeSort(top-down)</td><td>53</td><td>29</td><td>16</td><td>16</td><td>17</td><td>20</td><td>17</td><td>16</td><td>16</td><td>17</td><td>22.22</td></tr><tr><td>MergeSort(bottom-up)</td><td>59</td><td>19</td><td>17</td><td>17</td><td>17</td><td>18</td><td>18</td><td>17</td><td>17</td><td>17</td><td>22.11</td></tr><tr><td>QuickSort</td><td>38</td><td>20</td><td>16</td><td>15</td><td>15</td><td>15</td><td>15</td><td>16</td><td>15</td><td>15</td><td>18.33</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>43</td><td>22</td><td>20</td><td>21</td><td>20</td><td>20</td><td>21</td><td>20</td><td>20</td><td>20</td><td>23.00</td></tr></tbody></table></div><h3 id="折线图形式"><a href="#折线图形式" class="headerlink" title="折线图形式"></a>折线图形式</h3><p><img src="img/posts/runningtime.png" srcset="/img/loading.gif" alt=""></p><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>计算方法：在算法前后分别使用一次Java库函数<code>Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()</code>得到<code>startSpace</code>和<code>endSpace</code>，然后<code>endSpace - startSpace</code>即可。<strong>注：因为Java有垃圾回收机制，这一方法也许并不十分准确，但是用于比较算法，这一方法还是能给出大致的结果。</strong></p><h3 id="表格形式-1"><a href="#表格形式-1" class="headerlink" title="表格形式"></a>表格形式</h3><p>Comparison of space usage of algorithms (in Kilo Bytes)</p><div class="table-container"><table><thead><tr><th>N=1000</th><th>Run1</th><th>Run2</th><th>Run3</th><th>Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MergeSort(top-down)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MergeSort(bottom-up)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>QuickSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>N=10000</th><th>Run1</th><th>Run2</th><th>Run3</th><th>Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MergeSort(top-down)</td><td>0</td><td>39.08</td><td>0</td><td>0</td><td>0</td><td>0</td><td>39.08</td><td>0</td><td>39.08</td><td>0</td><td>13.03</td></tr><tr><td>MergeSort(bottom-up)</td><td>0</td><td>39.08</td><td>0</td><td>0</td><td>39.08</td><td>0</td><td>39.08</td><td>0</td><td>39.08</td><td>0</td><td>17.37</td></tr><tr><td>QuickSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>N=100000</th><th>Run1</th><th>Run2</th><th>Run3</th><th>Run4</th><th>Run5</th><th>Run6</th><th>Run7</th><th>Run8</th><th>Run9</th><th>Run10</th><th>Average</th></tr></thead><tbody><tr><td>InsertionSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MergeSort(top-down)</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td></tr><tr><td>MergeSort(bottom-up)</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td><td>390.64</td></tr><tr><td>QuickSort</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>QuickSort with 3-way partitioning</td><td>0</td><td>614.41</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>68.27</td></tr></tbody></table></div><h3 id="折线图形式-1"><a href="#折线图形式-1" class="headerlink" title="折线图形式"></a>折线图形式</h3><p><img src="img/posts/storageusage.png" srcset="/img/loading.gif" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://data-mining.philippe-fournier-viger.com/how-to-measure-the-memory-usage-of-data-mining-algorithms-in-java/" target="_blank" rel="noopener">How to measure the memory usage of data mining algorithms in Java?</a></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week5: Balanced Search Trees</title>
    <link href="/week5-Balanced-Search-Trees.html"/>
    <url>/week5-Balanced-Search-Trees.html</url>
    
    <content type="html"><![CDATA[<h1 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>2-3树是一种搜索树，其节点有三种可能：</p><ul><li>空节点：null</li><li>2-节点：有一个键值和两个指针，左指针指向键值较小的子2-3树，右指针指向键值较大的子2-3树。（同BST的内部节点）</li><li>3-节点：有两个键值和三个指针，左指针指向键值较小的子2-3树，中间指针指向键值在当前节点两键值之间的子2-3树，右指针指向键值较大的子2-3树。</li></ul><p>（放个2-节点和3-节点的图）</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>由上图可知，搜索过程与BST类似，只是遇到3-节点时需要多些条件判断，在此不再赘述。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>在搜索失败时，我们需要插入一个新节点。与BST不同，2-3树不会直接在null的位置加入一个新节点，而是尝试融入进搜索过程最后的叶子节点。根据叶子节点键值的个数，我们有两种情况：</p><ol><li>叶子节点是2-节点。那么我们只需将新节点的值加入进去，变为3-节点即可。</li><li>叶子节点是3-节点。同上，我们先暂时将该节点变为4-节点。由于其不符合规则，我们再将其分裂为三个2-节点——以中值为键的节点作为父节点，较小值的为左子树，较大值的为右子树。<strong>注意：若该节点的父节点已经是3-节点，那么提出来的父节点会再融入进去，重复这一过程，以此类推</strong>。</li></ol><p>（放出三个情况的图）</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>树是保持平衡且有序的</li><li>根节点到任一空节点的链接（links）数相同</li></ul><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>由于需要在一个节点内维护可变个数的键值，以及分裂节点的可能情况较多，我们并不直接实现2-3树。1979年Guibas和Sedgewick（Algorithms的作者）提出了左倾红黑树（left-leaning red-black tree），将2-3树表示为BST，较易实现。</p><h2 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h2><p>为了将2-3树映射为BST，红黑树的链接（links）用红与黑两种颜色表示不同的情况。红链接连接的节点融合起来就是2-3树的3-节点，黑链接是2-3树的普通链接。</p><p>（给出映射图）</p><p>红黑树简化了树的结构，当然会有一定的约束：</p><ol><li>不能存在节点有两个红链接。因为在这种时候，对应到2-3树就是一个4-节点，不符合规则。</li><li>根节点必须为黑色。原因见：<a href="https://www.quora.com/Why-is-the-root-in-a-red-black-tree-always-black" target="_blank" rel="noopener">Why is the root in a red-black tree always black?</a></li></ol><h2 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h2><p>由上述可知，红黑树的表现就是BST，因此搜索过程与BST完全一致。</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>插入新节点可能会破坏原树的定义与平衡性，所以我们需要旋转和翻转颜色等操作来修复。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><h3 id="翻转颜色"><a href="#翻转颜色" class="headerlink" title="翻转颜色"></a>翻转颜色</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/questions/13852870/red-black-tree-over-avl-tree" target="_blank" rel="noopener">Red black tree over avl tree</a></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week4: Priority Queues</title>
    <link href="/week4-Priority-Queues.html"/>
    <url>/week4-Priority-Queues.html</url>
    
    <content type="html"><![CDATA[<p>如果我们有$N$个数据，希望找到其中最大的$M$个，该怎么做？或许你想到了排序，时间复杂度为$O(NlogN)$，空间复杂度为$O(N)$，当$N$很大的时候，这并不是一个好的选择。一个更好的方法是使用优先队列（堆）。</p><p>我们可以写出如下代码：</p><pre><code class="hljs java">MinPQ&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> MinPQ&lt;&gt;();<span class="hljs-keyword">while</span> (!StdIn.isEmpty()) &#123;    <span class="hljs-keyword">int</span> num = StdIn.readInt();    pq.insert(num);    <span class="hljs-keyword">if</span> (pq.size() &gt; M)        pq.delMin();&#125;</code></pre><p>这样，时间复杂度便降到了$O(NlogM)$，空间复杂度降为$O(M)$。</p><p>优先队列还有其他许多应用，常见的有数据压缩，图的搜索，事件驱动仿真等。本文主要讨论其中的两个应用：事件驱动仿真、A*搜索算法，后者也就是完成本周assignment的关键。</p><h1 id="事件驱动仿真"><a href="#事件驱动仿真" class="headerlink" title="事件驱动仿真"></a>事件驱动仿真</h1><h2 id="时间驱动与事件驱动"><a href="#时间驱动与事件驱动" class="headerlink" title="时间驱动与事件驱动"></a>时间驱动与事件驱动</h2><p>仿真有两种常见的方法，一为时间驱动（time-driven），二为事件驱动（event-driven）。</p><h3 id="时间驱动"><a href="#时间驱动" class="headerlink" title="时间驱动"></a>时间驱动</h3><p>概述：系统以固定的时间间隔dt往前运行，每次时间间隔后检查是否已有事件发生，若有则作出相应的处理。</p><p>优点：实现简单。</p><p>缺点：dt若过大，可能会略过了事件的发生；dt若太小，又会有过多的无用检查。</p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>概述：系统预测该时间点后各个事件发生的时间，然后每次将时间推进到最近将发生的事件，作出相应处理，再预测以后事件的发生。</p><p>优点：由于两个相邻事件之间的时间内系统状态不会发生改变，所以系统时间可以直接从一个事件发生的时间推进到下一个事件发生的时间，这样也就不会又多余的检查。</p><p>缺点：实现较为复杂。</p><h2 id="事件驱动的构件（ingredients）"><a href="#事件驱动的构件（ingredients）" class="headerlink" title="事件驱动的构件（ingredients）"></a>事件驱动的构件（ingredients）</h2><ul><li><p>事件的优先队列</p><p>因为优先队列（堆）这一数据结构可以快速提取到最近将发生的事件。</p></li><li><p>事件的循环（预测+处理）</p><p>每次提取出最近将发生的事件，时间推进到那一刻并作出处理，再进行预测，直至优先队列为空。</p></li></ul><h2 id="样例：Collision-system"><a href="#样例：Collision-system" class="headerlink" title="样例：Collision system"></a>样例：Collision system</h2><p>这里以碰撞系统为例来讨论仿真，我们的目标是根据弹性碰撞的规律，模拟$N$个物体在方盒中的运动情况。详细的介绍与物理公式见coursera上的lecture slides。</p><h2 id="时间驱动？"><a href="#时间驱动？" class="headerlink" title="时间驱动？"></a>时间驱动？</h2><p>若我们使用时间驱动，那么我们每次在时间间隔dt后，都需要大约$1/2N^2$次的碰撞检查。且如前所述，dt取的很小的话仿真会很慢，取得很大的话又可能错过某次碰撞。</p><h2 id="事件驱动？"><a href="#事件驱动？" class="headerlink" title="事件驱动？"></a>事件驱动？</h2><p>若我们使用事件驱动，就不会有以上的烦恼，因为系统的状态仅会在碰撞发生时改变。实现的核心在于完成碰撞的预测及处理。</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>已知了物体的速度、质量、半径与位置，只需利用高中物理的公式就可以计算出当前物体与其余物体以及墙碰撞的时间。</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>碰撞发生后，我们需要改变碰撞物体的速度（还是用高中物理的公式），再以此速度去预测与其他物体以及墙碰撞的时间。</p><h1 id="A-算法-amp-Assignment-8-Puzzle"><a href="#A-算法-amp-Assignment-8-Puzzle" class="headerlink" title="A*算法 &amp; Assignment: 8 Puzzle"></a>A*算法 &amp; Assignment: 8 Puzzle</h1><p>关于A*算法，之前在<a href="https://seineo.github.io/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html">图论：常用的最短路算法详解</a>这篇博客就已经详细讨论过了，在这里我们只是讨论这次的assignment是如何将A*算法应用到8 puzzle上的。</p><p>我们可以将这一问题映射到图的搜索过程：</p><ul><li>出发点：初始给定的板</li><li>目的地：以行为序的板</li><li>出发点到当前点的距离：初始板到当前板的移动次数</li><li>当前点到目的地的距离：<ul><li>汉明距离（hamming）：板上对应块值却不同的个数（不包括空块）</li><li>曼哈顿距离（manhattan）：当前板上各个块到目标板上对应值的块的距离之和</li></ul></li><li>优先级：出发点到当前点的距离+当前点到目标点的距离</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://blog.sina.com.cn/s/blog_675cd6f60102xky0.html" target="_blank" rel="noopener">OOP编程的基于事件驱动的离散系统仿真</a></li><li><a href="https://www.cs.princeton.edu/courses/archive/fall11/cos323/notes/cos323_f11_lecture20_simulation.pdf" target="_blank" rel="noopener">COS 323 Simulation</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week3: Mergesort &amp; Quicksort</title>
    <link href="/week3-Mergesort-Quicksort.html"/>
    <url>/week3-Mergesort-Quicksort.html</url>
    
    <content type="html"><![CDATA[<h1 id="Mergesort"><a href="#Mergesort" class="headerlink" title="Mergesort"></a>Mergesort</h1><p>归并排序是一种基于分治思想的稳定排序算法，其时间复杂度为$O(nlogn)$。</p><p>我们在此不详细讨论算法本身的设计与实现，而注重于证明其时间复杂度的正确性。</p><p>若我们用比较的次数来表示时间的复杂度，那么对于长度为$N$的数组，我们可写出如下不等式：</p><script type="math/tex;mode=display">C(N) \leq C(N/2) + C(N/2) + N</script><p>其中$C(N)$是整个数组的比较次数，最后的$N$是归并操作的比较次数。</p><p>为了便于求解，我们仅讨论$N = 2^k, k = 0,1,…$的情况（结论适用于所有$N$），则式子转化为</p><script type="math/tex;mode=display">D(N) = 2*D(N/2) + N, D(1) = 0</script><p>对于上式我们可以画出递归树来帮助理解过程：</p><p><img src="img/posts/week3_1.png" srcset="/img/loading.gif" alt=""></p><p>算法从$N$个数一直处理到两个数，每次对半分开处理，所以递归深度为$log_2N$，树的高度也就为$log_2N$，每次递归处理最终归并的比较次数都是$N$次，所以最终比较次数也就是$Nlog_2N$次，则该算法的时间复杂度也就是$O(NlogN)$。</p><h1 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h1><p>快速排序是一种基于分治思想的不稳定排序算法，其平均时间复杂度为$O(NlogN)$，最差情况为$O(N^2)$。</p><p>同样，我们在这里也只是证明算法的时间复杂度，而不讨论该算法的设计与实现。</p><h2 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h2><p>对于<strong>不重复元素</strong>的数组(distinct numbers)，划分的比较次数恒为$N+1$，且我们假定划分的各种情况概率均等，即划分出的两个子数组元素个数为0与$N-1$、1与$N-2$…的概率都相等。则我们可以得出以下等式：</p><script type="math/tex;mode=display">C_N = (N+1) + (\frac{C_0+C_{N-1}}{N}) + (\frac{C_1+C_{N-2}}{N}) + ...+ (\frac{C_{N-1}+C_{0}}{N})</script><p>方程两边同乘$N$，得</p><script type="math/tex;mode=display">NC_N = N(N+1)+2(C_0+C_1+...+C_{N-1})</script><p>令</p><script type="math/tex;mode=display">NC_N - (N-1)C_{N-1}</script><p>再方程两边同除$N(N+1)$，得</p><script type="math/tex;mode=display">\begin{aligned}\frac{C_N}{N+1} &= \frac{C_{N-1}}{N}+\frac{2}{N+1} \\                &= \frac{C_{N-2}}{N-1} + \frac{2}{N} + \frac{2}{N+1} \\                &=... \\                &=\frac{2}{3}+\frac{2}{4}+\frac{2}{5}+...+\frac{2}{N+1}\end{aligned}</script><p>则</p><script type="math/tex;mode=display">\begin{aligned}C_N &= 2(N+1)(\frac{1}{3}+\frac{1}{4}+...+\frac{1}{N+1}) \\    &\sim 2(N+1)\int_{3}^{N+1}\frac{1}{x}dx\end{aligned}</script><p>最终可得</p><script type="math/tex;mode=display">C_N \sim 2(N+1)lnN \approx 1.39NlogN</script><p>所以平均时间复杂度为$O(NlogN)$。</p><h2 id="最差情况"><a href="#最差情况" class="headerlink" title="最差情况"></a>最差情况</h2><p>最差情况是数组已经完全有序（顺序或逆序），此时总的比较次数为</p><script type="math/tex;mode=display">N+(N-1)+(N-2)+...+1 \sim \frac{1}{2}N^2</script><h1 id="基于比较的排序算法的最优时间复杂度"><a href="#基于比较的排序算法的最优时间复杂度" class="headerlink" title="基于比较的排序算法的最优时间复杂度"></a>基于比较的排序算法的最优时间复杂度</h1><p>任何<strong>基于比较</strong>的排序算法<strong>在最坏情况下</strong>都<strong>至少</strong>需要大约$NlogN$次比较。</p><p>证明：</p><p><img src="img/posts/week3_2.png" srcset="/img/loading.gif" alt=""></p><p>最坏情况即需遍历所有的可能排列，共$N!$种排列情况。对于决策树而言，也就是至少有$N!$个叶节点。比较次数就是树的高度$h$，则树最少有$2^h$个叶节点。</p><p>综上，我们可以得出以下不等式：</p><script type="math/tex;mode=display">2^h \ge num \space of \space leaves \ge N! \\h \ge lg(N!) \sim NlogN</script><p>所以，至少需要$NlogN$次比较次数。</p><h1 id="Assignment-Collinear-Points"><a href="#Assignment-Collinear-Points" class="headerlink" title="Assignment: Collinear Points"></a>Assignment: Collinear Points</h1><p>代码见<a href="https://github.com/seineo/Algorithms/blob/master/Part1/week3/README.md" target="_blank" rel="noopener">这里</a>。在这主要说明下完成作业的几个关键点：</p><ul><li>该数据类型需要是不可变的(immutable)，即无论中间有多少不同的操作，内部数据都不应有变化。</li><li><strong>避免重复</strong>。在我们根据斜率排序然后加入满足条件的线时，可能会加入前面已经加入过的线。为了避免这一点，我们可以对满足条件的线加一个条件判断，若该线的出发点（即当前点）是整条线上坐标最小的点，才加入，否则跳过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主成分分析</title>
    <link href="/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html"/>
    <url>/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>主成分分析主要应用于降维。如下图所示，若干三维空间的点都落在同一平面上，那么我们就可以使用二维坐标来表示它们，而无需三维，这就是降维。</p><p><img src="img/posts/主成分分析1.png" srcset="/img/loading.gif" alt=""></p><p>由于本文是讨论如何建模，有较多的数学抽象，初识主成分分析的朋友可以先看看<a href="https://www.matongxue.com/madocs/1025/" target="_blank" rel="noopener">这篇文章</a>的前半部分以获得感性的认识再继续往下看。</p><p>降维可以描述如下：设</p><script type="math/tex;mode=display">x_i = \{x_{i1}, x_{i2}, ..., x_{in}\}^T \in R^n</script><p>为第$i$个样本，其为$n$维列向量，而</p><script type="math/tex;mode=display">X = \{x_1, x_2, ..., x_m\}</script><p>为有$m$个样本的样本空间。当样本点$x_i$的维数很高时，这些数据样本在$n$维空间的分布通常是稀疏的，这些$n$维样本实际可能只属于一个低维的子空间，如属于某个$d$维子空间（$d &lt; n$）。</p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><p><img src="img/posts/主成分分析2.png" srcset="/img/loading.gif" alt=""></p><p>如上图所示，假设$n$维样本点$x_i$投影到$d$维子空间的投影点为$\hat{x_i}$，$d$维子空间的一组标准正交基为$w_1, w_2,…,w_d$，其中</p><script type="math/tex;mode=display">w_i = \{w_{i1}, w_{i2},...,w_{in}\}^T</script><p>以$w_1,w_2,…,w_d$为列的矩阵记为</p><script type="math/tex;mode=display">W = \{w_1, w_2,...,w_d\}</script><p>由于$W$由标准正交基组成，则$W^TW=E$，$E$为$d$阶单位矩阵。有了标准正交基，我们就可以将$\hat{x_i}$表示如下：</p><script type="math/tex;mode=display">\begin{aligned}\hat{x_i} &= z_{i1}w_1 + z_{i2}w_2 + ... + z_{id}w_d \\          &= Wz_i\end{aligned}</script><p>其中，</p><script type="math/tex;mode=display">z_i = \{z_{i1}, z_{i2},...,z_{id}\}^T</script><p>为$\hat{x_i}$在基$w_1,w_2,…,w_d$下的坐标，其第$j$个坐标就是$x_i$在$w_j$上的投影z<sub>ij</sub>，它的值为$x_i$和$w_j$的内积，即z<sub>ij</sub> $=w_j^Tx_i$（$j=1,..,d$）。或者我们可以不用向量相乘的表示方式，而用高中的知识，内积z<sub>ij</sub> $= x_i \cdot w_j = |x_i||w_j|cos\theta$，如下图所示。</p><p><img src="img/posts/主成分分析3.png" srcset="/img/loading.gif" alt=""></p><p>在知道了原样本投影到子空间的坐标后，我们便可以建立模型了。我们的目标是降维后的值与原样本值的误差尽可能小，那么也就是两者在空间上的坐标要尽可能地近。即目标函数为：</p><script type="math/tex;mode=display">min \sum_{i=1}^m\|\hat{x_i}-x_i\Vert_2^2</script><p>这个形式不利于求解，我们需要进一步处理，使用矩阵形式表达。为了下面计算的方便，我们对$\hat{x_i} = Wz_i$方程两边同时右乘一个$W^T$，又$W^TW=E$，得</p><script type="math/tex;mode=display">\begin{aligned}\hat{x_i} &= Wz_i \\W^T\hat{x_i} &= W^TWz_i \\W^T\hat{x_i} &= z_i \\\end{aligned}</script><p>因此，</p><script type="math/tex;mode=display">\begin{aligned}\|\hat{x_i}-x_i\Vert_2^2 &= (\hat{x_i}-x_i)^T(\hat{x_i} - x_i)\\&= \hat{x_i}^T\hat{x_i}-2\hat{x_i}x_i+x_i^Tx_i \\&= z_i^TW^TWz_i - 2z^TW^Tx_i + x_i^Tx_i \\&= z_i^Tz_i - 2x_i^TW^Tx_i + x_i^Tx_i \\&= x_i^TWW^Tx_i - 2x_i^TWW^Tx_i + x_i^Tx_i \\&= -x_i^TWW^Tx_i + x_i^Tx_i \end{aligned}</script><p>由于$x_i$均为给定的样本点，所以$x_i^Tx_i$为常数，于是</p><script type="math/tex;mode=display">\begin{aligned}\sum_{i=1}^m\|\hat{x_i}-x_i\Vert_2^2 &= \sum_{i=1}^m-x_i^TWW^Tx_i + x_i^Tx_i \\&= \sum_{i=1}^m-x_i^TWW^Tx_i + C\end{aligned}</script><p>其中$C$为常数。为了进一步的简化矩阵的表达，我们注意到对于一个列向量$S_i$有这样的性质：$S_i^TS_i=tr(S_iS_i^T)$，其中$tr()$表示对矩阵的对角线求和。那么</p><script type="math/tex;mode=display">\begin{aligned}\sum_{i=1}^mS_i^TS_i &= tr\left (  \begin{array}{c}  [S_1,S_2,...,S_m]\left [  \begin{array}{c}  S_1^T \\  S_2^T \\  ... \\  S_m^T  \end{array}  \right]  \end{array}\right) \\&= tr(SS^T) \\&= tr(S^TS)\end{aligned}</script><p>其中$S=[S_1,S_2,…,S_m]$为以$S_1,S_2,…,S_m$为列的矩阵。令$S_i=z_i=W^Tx_i$，则有$S=W^TX$，</p><script type="math/tex;mode=display">\begin{aligned}\sum_{i=1}^m\|\hat{x_i}-x_i\Vert_2^2 &= C-\sum_{i=1}^mS_i^TS_i \\&= C - tr(SS^T) \\&= C - tr(W^TXX^TW)\end{aligned}</script><p>我们要</p><script type="math/tex;mode=display">min \sum_{i=1}^m\|\hat{x_i}-x_i\Vert_2^2</script><p>也就是要</p><script type="math/tex;mode=display">max \space tr(W^TXX^TW)</script><p>于是主成分分析的数学模型为</p><script type="math/tex;mode=display">\begin{aligned}\left\{\begin{array}{l}max \space tr(W^TXX^TW) \\s.t. W^TW=E\end{array}\right.\end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k-means聚类</title>
    <link href="/k-means%E8%81%9A%E7%B1%BB.html"/>
    <url>/k-means%E8%81%9A%E7%B1%BB.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>聚类应用于生活的方方面面，如人脸识别，每一个人就是一个类，将数据库中的照片与现拍的照片进行特征值的比较后划分到一个类中（即确定一个人）；又如疫情健康码，有绿码、黄码和红码三个类，根据人的居住地、最近去向、接触人群等属性将其划分到一个类中（即分配一个健康码）。</p><p>聚类问题可以描述如下：假设有$n$个无标记样本</p><script type="math/tex;mode=display">D = \{x_1,x_2,...,x_n\}</script><p>任一样本为$d$维向量</p><script type="math/tex;mode=display">x_i = \{x_{i1},x_{i2}, ..., x_{id}\}^T</script><p>将其按照某种<strong>相似性准则</strong>划分为若干个互不相交 的子集。</p><p>k-means聚类就是指定$k$，将其划分为$k$个互不相交的子集。</p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><h2 id="简单的想法"><a href="#简单的想法" class="headerlink" title="简单的想法"></a>简单的想法</h2><p>k-means聚类的<strong>相似性准则</strong>为样本间的<strong>欧式距离</strong>，将离得近的样本看作一个类，离得远的看作不同类。</p><p>因此，对于一个划分</p><script type="math/tex;mode=display">C=\{C_1,C_2,...,C_k\}</script><p>要使其最优，所有类样本到各自类中心的距离之和就应该最小。</p><p>对于类$C_i$，其类中心为</p><script type="math/tex;mode=display">M_i=\frac{1}{|c_i|}\sum_{x \in C_i}x, 1 \leq i \leq k</script><p>即类中心是该类所有类样本和的平均值，则该类所有类样本到类中心的距离之和为</p><script type="math/tex;mode=display">\sum_{x \in C_i}\|x-M_i\Vert_2</script><p>上式是用$l_2$-范数表示欧式距离，这是十分常见的，更多关于范数的知识可参见：<a href="https://zhuanlan.zhihu.com/p/26884695" target="_blank" rel="noopener">如何通俗易懂地解释「范数」？</a></p><p>将$k$个类累加起来，就可以得到所有类样本到各自类中心的距离之和为</p><script type="math/tex;mode=display">\sum_{i=1}^k\sum_{x \in C_i}\|x-M_i\Vert_2</script><p>那么，我们的模型就可以写出来了：</p><script type="math/tex;mode=display">\begin{aligned}min \sum_{i=1}^k\sum_{x \in C_i} \|x-M_i\Vert_2^2 \\\begin{equation}s.t. \left\{\begin{array}{l}\cup_{i=1}^k C_i = D \\C_i \cap C_j = \varnothing \\i,j \in {1, 2, ..., k} \\i \neq j\end{array} \right.\end{equation}\end{aligned}</script><p>注意，我们这里目标函数写成平方是为了求解方便，若不加平方，求距离就会带开方，计算不便。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面的模型有一个明显的缺陷：只考虑了同类的聚集，却没有考虑不同类的分散。</p><p>因此我们可以添加一个目标加以优化：让不同类间的类中点距离之和最大。那么我们就可以得出以下目标函数：</p><script type="math/tex;mode=display">max \sum_{1 \leq i \lt j \leq k} \|M_i-M_j\Vert_2^2</script><p>模型也就变成了多目标优化模型。为了求解的简便，我们先利用倒数将第二个目标函数转为求最小值，然后采用线性加权法将多目标转为单目标，得以下目标函数：</p><script type="math/tex;mode=display">min \sum_{i=1}^k\sum_{x \in C_i}\|x-M_i\Vert_2^2 + \sum_{1 \leq i \lt j \leq k} \frac{1}{\|M_i-M_j\Vert_2^2}</script><p>至此，我们得到了优化后的k-means聚类模型。</p><h2 id="相似性准则"><a href="#相似性准则" class="headerlink" title="相似性准则"></a>相似性准则</h2><p>如前所述，k-means聚类使用欧式距离作为相似性准则，这其实只适用于圆形或椭圆形聚集的数据聚类，如下图所示。</p><p><img src="img/posts/聚类1.png" srcset="/img/loading.gif" alt=""></p><p>而无法对其他多样分类需求的数据进行聚类，如下图，以欧式距离作为相似性准则是无法做到这样的分类的。</p><p><img src="img/posts/聚类2.png" srcset="/img/loading.gif" alt=""></p><p>因此，相似性准则并不是普适的，而是各有专攻。如今，人们已经提出了种类繁多的相似性准则，适用于不同的应用场景，若有兴趣，可以去查询相关资料。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2: Stacks and Queues &amp; Elementary Sorts</title>
    <link href="/week2-Stacks-and-Queues-Elementary-Sorts.html"/>
    <url>/week2-Stacks-and-Queues-Elementary-Sorts.html</url>
    
    <content type="html"><![CDATA[<h1 id="泛型与可迭代的数据结构"><a href="#泛型与可迭代的数据结构" class="headerlink" title="泛型与可迭代的数据结构"></a>泛型与可迭代的数据结构</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在java中实现泛型十分简单，只需定义类时在类名后加上<code>&lt;类型名&gt;</code>，然后在类中用到此类型数据时通通使用<code>类型名</code>修饰即可。如</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Item[] s;    ...&#125;</code></pre><h2 id="可迭代"><a href="#可迭代" class="headerlink" title="可迭代"></a>可迭代</h2><p>若想自定义的数据结构是可迭代的，那么就需要实现<code>Iterable</code>接口，重写<code>iterator()</code>方法，其会返回一个迭代器，定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">// Iterable interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function">Iterator&lt;Item&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>当然，我们需要自己定义这个迭代器是如何遍历我们所写的数据结构的。java提供了<code>Iterator</code>接口，我们实现它即可。</p><pre><code class="hljs java"><span class="hljs-comment">// Iterator interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Item <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// optional; use at your own risk</span>&#125;</code></pre><p>在client程序中，可以使用范围for循环来进行迭代遍历：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : stack)    StdOut.println(s);</code></pre><p>其等价于：</p><pre><code class="hljs java">Iterator&lt;String&gt; i = stack.iterator();<span class="hljs-keyword">while</span> (i.hasNext()) &#123;    String s = i.next();    StdOut.println(s);&#125;</code></pre><h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><h2 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h2><p>我们的排序方法在不知道传入的数据类型是什么时，是如何在排序中比较各个元素的呢？使用回调函数。</p><p>客户程序传入需要排序的数组，我们的排序方法在比较元素时会调用该元素对象的<code>compareTo()</code>方法来完成比较。</p><p>即对于一个以比较元素为基础的排序方法而言，传进来的对象需自己是<code>可比较的（Comparable）</code>，在java中就是需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。</p><pre><code class="hljs java"><span class="hljs-comment">// Comparable interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Item that)</span></span>;&#125;</code></pre><p>然后我们的排序方法将传进来的数组当成可比较对象的数组即可，如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span> </span>&#123;    ...&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>在这几个基础排序算法中，我们着重讨论下插入排序。</p><p>插入排序是时间复杂度为$O(n^2)$、稳定（stable）且原地（in place）的排序算法，它在<strong>数组接近有序</strong>和<strong>数组较小</strong>时常被选用来排序。为什么呢？</p><ol><li>数组接近有序。插入排序是每次将当前元素与前面的元素一一比较，直到找到小于等于它的元素就在该位置插入。若数组接近有序，那么插入排序比较和交换的次数就很少，能在$O(n)$的时间内完成。</li><li>数组较小。当数组较小时，插入排序是很快的，因为它是原地的（in place），没有较多的开销。此时它常用来代替归并排序（merge sort）和快速排序（quick sort），因为这两个排序的递归调用对带来额外的栈开销。</li></ol><h1 id="Assignment-Deques-and-Randomized-Queues"><a href="#Assignment-Deques-and-Randomized-Queues" class="headerlink" title="Assignment: Deques and Randomized Queues"></a>Assignment: Deques and Randomized Queues</h1><p>代码见<a href="https://github.com/seineo/Algorithms/blob/master/Part1/week2/README.md" target="_blank" rel="noopener">这里</a>。在这主要说明下完成作业的几个关键点：</p><ol><li><strong>loitering</strong>。在链表实现deque的过程中，由于有<code>next</code>和<code>prev</code>两个引用，稍有不慎就会出现loitering。以<code>addFirst</code>函数为例，添加一个新的first节点后，如果仅仅设置了该节点的<code>next</code>和<code>prev</code>引用，是会出现loitering的。若链表不止有这一个新增的节点，那么原来的first节点的<code>prev</code>应该指向它，即<code>oldFirst.prev = first</code>。</li><li><strong>随机队列的<code>dequeue</code>函数</strong>。由于随机队列是随机删除一个元素，若用数组实现，那一下标直接就空了，如果置之不理，仍然是在后面入列，则出列操作不好实现。为了解决这一问题，我们可以交换删除元素位置的值和队尾元素的值。</li><li><strong>bonus</strong>：bonus的问题我也不会，是在论坛上了解到的方法——水塘抽样。水塘抽样是一种统计的随机算法，在这里不作探讨，不了解的朋友可以参见：<a href="https://blog.csdn.net/javastart/article/details/50610868" target="_blank" rel="noopener">Reservoir sampling（水塘抽样）</a>。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/736920/is-there-ever-a-good-reason-to-use-insertion-sort" target="_blank" rel="noopener">Is there ever a good reason to use Insertion Sort?</a></li><li><a href="https://stackoverflow.com/questions/8101546/why-is-insertion-sort-better-than-quick-sort-for-small-list-of-elements" target="_blank" rel="noopener">Why is Insertion sort better than Quick sort for small list of elements?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旅行商问题与最可靠路径问题</title>
    <link href="/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E5%8F%AF%E9%9D%A0%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html"/>
    <url>/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E5%8F%AF%E9%9D%A0%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol><li>旅行商问题（TSP）：从一点出发遍历其余点各一次再回到该点，要求总路径最短。</li><li>最可靠路径问题：图中的任一条边都有其可靠的概率，求任意两点间的最可靠路径。</li></ol><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><p>若图中有$n$个点，我们可将它们编号为$0,…,n-1$（<strong>本文讨论都默认0为起点</strong>）,构造对应的邻接矩阵c<sub>nxn</sub>，令x<sub>nxn</sub>为0-1矩阵，若x<sub>ij</sub>为1，则点$i$到点$j$属于当前选择路径的一部分，反之不属于。那么我们就可以很容易写出如下目标函数</p><script type="math/tex;mode=display">min \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}</script><p>显然，在此题中一条合法的路径应该是类似下方这样的回路。</p><p><img src="img/posts/tsp1.png" srcset="/img/loading.gif" alt=""></p><p>这样的一条回路，其中各点的入度、出度都应为0。所以我们可以写出以下两条约束条件</p><script type="math/tex;mode=display">\begin{equation}s.t. \left\{\begin{aligned}\sum_{i=1}^{n}x_{ij} = 1, j = 1,...,n \\\sum_{j=1}^{n}x_{ij} = 1, i = 1,...,n \end{aligned} \right.\end{equation}</script><p>但是仅仅满足这两个条件的路径可能并不是合法路径，因为它可能是多条回路的并集而非一个回路。如下图所示。</p><p><img src="img/posts/tsp2.png" srcset="/img/loading.gif" alt=""></p><p>因此我们还需要第三个约束条件</p><script type="math/tex;mode=display">u_i - u_j + nx_{ij} \leq n - 1， 1< i \neq j < n</script><p>其中$u_i$表示编号为$i$的点在当前选择路径的序号（该点为<strong>非起点</strong>，在本文中即非0）。加上这一约束条件，我们就可以确定合法路径，证明如下。</p><h3 id="约束三的证明"><a href="#约束三的证明" class="headerlink" title="约束三的证明"></a>约束三的证明</h3><ol><li><p>必要条件</p><p><img src="img/posts/tsp3.png" srcset="/img/loading.gif" alt=""></p></li></ol><p><strong>（注意：起点0并没有对应的$u$值，它不参与计算。）</strong></p><p>对于一条合法路径，根据$x_{ij}$的取值，我们有两种情况要讨论</p><ul><li>若$x_{ij}=1$，即点$i$与点$j$相邻，则$|u_i-u_j| \leq 1$，所以$u_i-u_j+n \times 1 \leq n-1$，成立。</li><li>若$x_{ij}=0$，即点$i$与点$j$不相邻，而$max \space u_i=n$，$min \space u_j = 2$，那么$max \space (u_i-u_j) + n \times 0=n-2 &lt; n-1$，也成立。</li></ul><p>因此，加上约束三后的约束条件是确定合法路径的必要条件。</p><ol><li>充分条件</li></ol><p><img src="img/posts/tsp4.png" srcset="/img/loading.gif" alt=""></p><p>我们使用反证法。满足前两个约束的非法路径肯定是多条回路的并集，我们选择<strong>不包含起点的某个回路</strong>来讨论。比如我们选中上图的右回路，我们假定其中各点对应$u$值如图所示（其实对应$u$值具体为多少并不重要，只要是连续的即可）。我们可以写出以下式子：</p><script type="math/tex;mode=display">\begin{aligned}\left\{\begin{aligned}u_2 - u_3 + n \times 1 \leq n - 1 \\u_3 - u_4 + n \times 1 \leq n - 1 \\ u_4 - u_2 + n \times 1 \leq n - 1\end{aligned} \right.\end{aligned}</script><p>全部式子加和，可得</p><script type="math/tex;mode=display">k \times n \leq k \times (n - 1)</script><p>显然，该式不成立。因此，加上约束三后的约束条件是确定合法路径的充分条件。</p><p>综上，加上约束三后的约束条件是确定合法路径的充分必要条件。</p><h2 id="最可靠路径问题"><a href="#最可靠路径问题" class="headerlink" title="最可靠路径问题"></a>最可靠路径问题</h2><p>对一个图G&lt; V, E &gt;，其任意一条边$e_i \in E$都有其可靠的概率$p_i$，任意两点的最可靠路径我们的目标函数大致可以写成</p><script type="math/tex;mode=display">max \sum p_i</script><p>这个最大值其实并不好求，我们可以将其转化为最短路径问题。</p><p>令各边长为$l_i = log_2 \frac{1}{p_i}$，$p_i$越大，$\frac{1}{p_i}$就越小，由于$log$函数是单调递增的函数，那么$l_i$也就越小。</p><p>即，我们的目标函数变为</p><script type="math/tex;mode=display">\begin{aligned}max \sum p_i &= min \space log_2\frac{1}{p_i} \\             &= min \space -log_2p_i\end{aligned}</script><p>这就完成了从最可靠路径问题到最短路径问题的转化。求解最短路径的方法多样，就不在此多加探讨了。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元线性回归</title>
    <link href="/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html"/>
    <url>/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我们使用$n$个属性描述事物$y$，已测得$m$组属性值</p><script type="math/tex;mode=display">\begin{equation}x_{k}=(x_{1k},x_{2k},...,x_{nk})^T\end{equation}, k = 1,...,m</script><p>和其对应$m$个$Y$值，试构造函数$y=f(x)$以解释、预测该事物的变化。</p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><p>显然，对于每个$y_i,i=1,…,m$，我们需要构造以下函数形式：</p><script type="math/tex;mode=display">y_i = w_1x_{1i}+...+w_nx_{ni}+b</script><p>为了表述的简洁与计算的方便，我们尽量将其化简为向量或矩阵形式。</p><p>令$w$=$(w_1,…,w_n)^T$，则</p><script type="math/tex;mode=display">y_i = w^Tx_i + b</script><p>我们还可以再简化，令</p><script type="math/tex;mode=display">\bar{w}=\left(\begin{matrix}w \\ b\end{matrix}\right),\bar{x}_i = \left(\begin{matrix}x_i \\ 1\end{matrix}\right)</script><p>则得</p><script type="math/tex;mode=display">y_i = \bar{w}^T\bar{x_i}</script><p>对于全部m组测量值，我们可以写出以下式子</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}\left (  \begin{array}{c}  y_1 \\  \cdots \\  y_m  \end{array}\right) &= \left(  \begin{array}{c}  \bar{w}^T\bar{x}_1 \\  \cdots \\  \bar{w}^T\bar{x}_m  \end{array}\right) \\&=\bar{w}^T\left(  \begin{array}{c}  \bar{x}_1 \\  \cdots \\  \bar{x}_m  \end{array}\right)\end{aligned}\end{equation}</script><p>由于此问题中$\bar{w}$才是自变量，我们可以令$y = (y_1, …, y_m)^T$，$D=(\bar{x}_1,…,\bar{x}_m)^T$，写成以下形式</p><script type="math/tex;mode=display">y = D^T\bar{w}</script><p>由于已知样本值，我们可以使用最小二乘法，对以下式子求解即可。</p><script type="math/tex;mode=display">min \space (Y - y)^T(Y-y)</script>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实模式与保护模式</title>
    <link href="/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.html"/>
    <url>/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><p>早期CPU（如8086）是16位的CPU，寄存器是16位的，数据总线是16位的，也就是说在8086内部，能够一次性处理与传输的数据最长为16位比特，那么它的寻址能力仅为2<sup>16</sup>=64 KB。但是地址总线却是20位的，即其寻址能力为2<sup>20</sup>=1 MB。</p><p>为了解决寻址能力不匹配这一问题，引入了地址加法器，以如下公式进行地址的换算：<strong>内存地址 = (段地址 &lt;&lt; 4) + 段内偏移地址</strong>。</p><p>由于寄存器为16位，则其中存的段地址/段内偏移地址为16位，段地址向左偏移4位即得20位的地址，再加上段内偏移即可得到内存中实际的物理地址。</p><p>这样的寻址方式是很直接的，相当于物理地址直接暴露在程序员面前，程序员可以随意的修改内存各处的内容，有着较大的安全隐患。或许这就是为什么叫做实模式吧。</p><p>另外，还有一点值得注意：<code>段地址+段内偏移地址</code>这样的寻址方式对于16位CPU而言是可以“越界”的。对于16位而言，最大地址即为FFFF，因此可取得内存地址：</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}memory \space address &= FFFF << 4 + FFFF \\                      &= FFFF0 + FFFF \\                      &= 10FFEF\end{aligned}\end{equation}</script><p>若想访问到10FFEF，需要21根地址总线，但是实际地址总线仅有20根，内存地址实际最大仅为100000 &lt; 10FFEF，越界了。但是系统并不认为其访问越界而抛出异常，而是将访问大于等于100000的地址均对100000取模，因此此时访问到的就是较小的内存地址了。</p><p>再后来，CPU发展到了80286，此时地址总线已有24根，那么10FFEF就是可以访问到的了，但是<strong>在实模式下</strong>，为了向下兼容，系统表现的行为又应同8086一样，即仿佛“只有20根地址总线”。为了能够自由选择<strong>实模式下</strong>寻址能力的大小，便出现了A20 Gate。</p><h2 id="A20-Gate"><a href="#A20-Gate" class="headerlink" title="A20 Gate"></a>A20 Gate</h2><p>A20 Gate是第21根地址总线，它有一个开关，<strong>对于实模式而言</strong>：</p><ul><li>开关打开时，这根地址总线可用，程序员可以访问到100000～10FFEF的地址</li><li>开关关闭时，这根地址总线不可用，程序员不可以访问到100000～10FFEF的地址</li></ul><p>因此在实模式下要想访问高端内存区，这个开关必须打开。在保护模式下，如果A20关闭，那么系统只能访问奇数兆的内存，即只能访问0～1M、2～3M……，所以在保护模式下，这个开关一般也会打开。</p><h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>在后续更高系列的CPU中，即使A20 Gate被打开，在实模式下所能够访问的内存最大也只能为10FFEF，而内存的寻址能力远不止如此。为了能够访问更大的地址，则必须进入保护模式。</p><p>虽然后续一般寄存器和地址总线都有着相同的位数，但系统并没有使用寄存器直接指定内存地址，而是沿用了<code>段地址+段内偏移地址</code>的寻址方式。段值存入段寄存器，而该值作为索引，用于在<code>全局描述符表</code>（GDT）中寻找到对应的一个表项（<code>段描述符</code>），该表项中含有段地址、段大小、访问控制等信息，得到其中的段地址后再加上合法的段内偏移，即可访问到对应的物理地址。</p><p>GDT条目结构如下所示：</p><p><img src="/img/posts/实模式与保护模式1.png" srcset="/img/loading.gif" alt=""></p><center>图源自https://en.wikipedia.org/wiki/Global_Descriptor_Table</center><p>综上可知，在保护模式下，物理地址并不是直接暴露在程序员面前了，寻址有了更多的检查步骤，这是属于虚拟内存的范畴了，在此就不再深入。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/trochiluses/article/details/8954527" target="_blank" rel="noopener">实模式与保护模式解惑之（一）——二者的起源与区别</a></li><li><a href="https://blog.csdn.net/lightseed/article/details/4305865#commentBox" target="_blank" rel="noopener">Gate A20与保护模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week1: union-find</title>
    <link href="/week1-union-find.html"/>
    <url>/week1-union-find.html</url>
    
    <content type="html"><![CDATA[<h1 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h1><p>现实世界中，人际关系时常变化，如何快速判断两个人是否是朋友关系？路径不断增删，如何快速判断两个地点是否互通？这些都是动态连通性问题，现在已经有很好的算法来解决他们，即并查集算法。</p><h2 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h2><p>在这一问题中，显然最关键的就是<strong>物体</strong>和<strong>连通</strong>。对于各个物体，我们可以用整数表示，如N个物体，使用0～N-1表示；对于连通，学过离散数学的朋友应该能很自然地想到连通性是一种等价关系（满足自反性、对称性和传递性），这一关系将物体分为一个个等价类（连通集）。</p><h2 id="算法解决"><a href="#算法解决" class="headerlink" title="算法解决"></a>算法解决</h2><h3 id="简单的想法：quick-find"><a href="#简单的想法：quick-find" class="headerlink" title="简单的想法：quick-find"></a>简单的想法：quick-find</h3><p>对于N个物体，显然可以使用一个一维的数组来储存，而对于连通性的判断，我们可以对一个连通集维护一个值，即当两个节点存储的值相等时，认为它们在同一连通集中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">return</span> id[p] == id[q];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">int</span> pid = id[p];    <span class="hljs-keyword">int</span> qid = id[q];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; id.length; i++) &#123;        <span class="hljs-keyword">if</span> (id[i] == pid)            id[i] = qid;    &#125;&#125;</code></pre><p>这样判断连通性仅需O(1)，但合并操作却需要O(N)，我们需要对合并操作做一定的优化。</p><h3 id="优化1：quick-union"><a href="#优化1：quick-union" class="headerlink" title="优化1：quick-union"></a>优化1：quick-union</h3><p>quick-find的合并操作较慢是由于需要遍历数组来寻找在同一连通集的元素并加以修改，而quick-union为了解决这一问题换了一种思路：将N个物体看作森林，每一个连通集是一棵树，这样我们只需判断两个节点是否在一颗树上，即根节点是否相等，就可以知道它们是不是在同一连通集中。</p><p>令id[p]为节点p的父节点，若id[p] == p，则p为根节点：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">while</span> (i != id[i])        i = id[i];    <span class="hljs-keyword">return</span> i;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">return</span> root(p) == root(q);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = root(p);    <span class="hljs-keyword">int</span> j = root(q);    id[i] = j;&#125;</code></pre><p>这样一来，在已求出两节点的根节点时，合并操作是O(1)的。但是如果表示连通集的树退化成链表，求根节点的操作还会是O(N)的，因此我们需要寻找办法来降低树的高度。</p><h3 id="优化2：weighted-quick-union"><a href="#优化2：weighted-quick-union" class="headerlink" title="优化2：weighted quick-union"></a>优化2：weighted quick-union</h3><p>方法一就是对树赋权值（表示大小），在每次合并操作中，将小树的根连接到大树的根上，以此达到平衡树高度的目的，如下图所示。</p><p><img src="/img/posts/week1_union-find_1.png" srcset="/img/loading.gif" alt=""></p><p>实现的方法也很简单，只需像维护id数组一样维护一个表示连通集大小的sz数组即可（这里只给出union的实现，其他基本不变）：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123; <span class="hljs-keyword">int</span> i  = root(p);    <span class="hljs-keyword">int</span> j = root(q);    <span class="hljs-keyword">if</span> (i == j)         <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (sz[i] &lt; sz[j]) &#123;        id[i] = j;        sz[j] += sz[i];    &#125; <span class="hljs-keyword">else</span> &#123;        id[j] = i;        sz[i] += sz[j];    &#125;&#125;</code></pre><p>经过这样的加权平衡操作，我们求根节点的操作仅需O(lg N)了，证明如下：</p><p>对于一个节点x，<strong>它所在的深度</strong>仅会在它所在的连通集作为子树连到另一连通集上时<strong>加一</strong>，如下图，x的深度仅会在它所在的连通集T1作为子树连到T2上时会加一。在合并操作后，T1和T2会作为一个新的连通集T继续以后的操作，它的大小至少是原来T1大小的两倍。总共有N个节点，翻倍的次数最多为lg N次，因此求根节点操作为O(lg N)。</p><p><img src="/img/posts/week1_union-find_2.png" srcset="/img/loading.gif" alt=""></p><h3 id="优化3：path-compression"><a href="#优化3：path-compression" class="headerlink" title="优化3：path compression"></a>优化3：path compression</h3><p>在求根节点的过程中，我们可以顺便进行路径的压缩以达到降低树高度的目的。由于我们之前定义过：“若id[p] == p，则p为根节点”，因此我们可以让路径上的每个点指向其祖父节点，即id[p] = id[id[p]]，这样可以使寻根的路径减半，也不会影响根节点。在不断的合并操作下，树的高度可以趋近于1。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">while</span> (i != id[i]) &#123;        id[i] = id[id[i]];        i = id[i];    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre><p>综合运用weighted quick-union和path compression的情况下，摊还分析表示判断连通性与合并操作都为常数时间。</p><h1 id="Assignment-Percolation"><a href="#Assignment-Percolation" class="headerlink" title="Assignment: Percolation"></a>Assignment: Percolation</h1><p>这周的大作业是判断一个正方形渗透模型的动态连通性，代码见<a href="https://github.com/seineo/Algorithms/blob/master/Part1/week1/README.md" target="_blank" rel="noopener">这里</a>。在这主要说明下完成作业的两个关键点：</p><ol><li><strong>二维转一维</strong>。对于这样一个N x N的正方形渗透模型，其本质是判断第一行与最后一行是否有元素在一个连通集中，因此也就是一个并查集问题。我们需要将二维的坐标对应到一维的、大小为N x N + 2的数组坐标上。（2是用于减少计算量的上下两个虚拟节点）</li><li><strong>解决backwash</strong>。完成任务的朋友可能会发现，测试<code>input10.txt</code>时显示的图像与参考答案不符，与最后一行相连的open的块集合均变为了蓝色，其实这就是所谓的backwash。这是因为渗透时，上面的虚拟节点与下面的虚拟节点在同一连通集中，最后一行与下面的虚拟节点也在同一连通集中，这就导致与最后一行相连的open块集合就会直接与上面的虚拟节点在同一连通集中，因此对这些块<code>isFull</code>函数都判断为true，它们也就显示为蓝色了。解决方法有两个：<ol><li><strong>去掉下面的虚拟节点</strong>。这样最后一行就不会与下面的虚拟节点在同一连通集中，模型渗透时也就不会直接与上面的虚拟节点在同一连通集了。但这样判断模型是否渗透时就需要上面的虚拟节点与最后一行的元素进行一一判断，时间复杂度为O(N)。</li><li><strong>增加一个并查集</strong>。新的并查集与原来的并查集差别只在于新的并查集没有虚拟节点。在平时的操作中，需要对两个并查集都进行操作，而判断模型是否渗透时，只判断新的并查集。这一方法就是用空间换时间了，时间复杂度仅为O(1)。</li></ol></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u010665051/article/details/35334157" target="_blank" rel="noopener">动态连通性问题的并查集算法（上）</a></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论：最大流最小割详解</title>
    <link href="/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E8%AF%A6%E8%A7%A3.html"/>
    <url>/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E8%AF%A6%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>想象这样的情形：水厂（图中的消防栓）通过流向、容量各不相同的水管供水到你所在的小区（图中的水桶），每次供水最多可以供多少呢？如果想切断到你所在小区的供水，我们最少该切断哪几根水管呢（如果切断成本与水管容量成正比）？</p><p><img src="/img/posts/waterflow.png" srcset="/img/loading.gif" alt=""></p><center>图源自https://brilliant.org/wiki/max-flow-min-cut-algorithm/</center><p>其实这就是图论中的最大流-最小割问题，本文用“水流”与“水管”类比，先讨论最大流问题，然后再说明最大流与最小割的特殊关系，我们还将讨论一些实际中会使用的相关算法及其实现。</p><h1 id="直觉"><a href="#直觉" class="headerlink" title="直觉"></a>直觉</h1><p>每次供水量的最大值显然取决于传输路径中各根水管容量的最小值（类似<a href="https://baike.baidu.com/item/%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94/870962" target="_blank" rel="noopener">木桶效应</a>），不然当通过那根水管时，水管有可能会破裂。因此我们可以很快地想出这样的方法：每次寻找一条从出发点到目的地的可行路径，累加每条路径中水管容量的最小值，最后便是供水量的最大值。（<strong>注意：这并不完全正确</strong>）</p><p>我们可以找几个简单的例子试一试：</p><p><img src="/img/posts/max_flow_example1.png" srcset="/img/loading.gif" alt=""></p><p>这只有一条路径，而其路径中最小值为2，那么我们每次供水量的最大值就是2，这显然是正确的。</p><p>再来看一个复杂些的例子：</p><p><img src="/img/posts/max_flow_example2.png" srcset="/img/loading.gif" alt=""></p><p>假如我们先找到的是s-&gt;u-&gt;v-&gt;t这一路径，那么其中最小值即为2，更新供水量为2，而后该图就变成了这样:</p><p><img src="/img/posts/max_flow_example3.png" srcset="/img/loading.gif" alt=""></p><p>这里我们定义<code>x/y</code>表示容量最大值为y，我们已经用了x。由更新后的图，我们可以发现，已经没有可行的路径了，所以最后得出的供水量最大值即为2。但这是正确的吗？如果你仔细观察，你会发现，其实供水量的最大值应该是3，上方流量为2的水流一个走s-&gt;u-&gt;t，一个走s-&gt;u-&gt;v-&gt;t，下方流量为1的水流走s-&gt;v-&gt;t，如下图所示：</p><p><img src="/img/posts/max_flow_example4.png" srcset="/img/loading.gif" alt=""></p><p>由此可见，我们单纯地寻找路径然后叠加不一定能得到正确的最大流，因为我们在流向选择时很可能是做出了错误的决定，比如上个例子，我们流量为2的水流本应分流但我们没有，这时我们就需要<strong>残留网络</strong>（residual graph）来让我们可以<strong>撤销</strong>（undo）错误的决定。</p><h1 id="残留网络（residual-graph）"><a href="#残留网络（residual-graph）" class="headerlink" title="残留网络（residual graph）"></a>残留网络（residual graph）</h1><p>残留网络是解决问题的关键，也是最让人疑惑的地方，在这里我尽量用易懂的语言和图示来说明。</p><p>个人认为，残留网络的<strong>关键思想</strong>在于：为了可以撤销（undo）先前的流向决定，我们就需要减小原先路径的可流量并对应地增加反向路径的可流量。为什么还可以增加反向路径的可流量？<strong>因为在残留网络中，反向路径的流量并不是说明我们真的可以倒着流，而只是说明我们可以撤销（undo）先前在这条路径过来的这么多流量，让它流向其他路径</strong>。下面我们再用上一个例子来讲解利用残留网络是如何成功地找到最大流的。</p><p>在第一次寻找路径时，我们找到了s-&gt;u-&gt;v-&gt;t，其最小值为2，那么我们就将路径中各根水管的可流量（最初就是容量）减2，对应反向路径加2。</p><p>我们在这给个图（注意：为了清晰美观，对于残留网络中的权值，我们不再使用<code>x/y</code>这种形式，而换用可流量表示，且可流量为0的边直接删去）：</p><p><img src="/img/posts/max_flow_example5.png" srcset="/img/loading.gif" alt=""></p><p>这张图是怎么来的呢？我们按边来一一解释。在路径s-&gt;u-&gt;v-&gt;t中的每条边可流量都减2，那么s-&gt;u的可流量便从2降为0，我们将其删去，并加上可流量为2的反向路径，这一反向路径是说明，我们之前在这通入了<code>2</code>的水流，那么以后我们最多可以撤销<code>2</code>的水流。u-&gt;v的可流量从3降为1，反向路径也是2，最后v-&gt;t与s-&gt;u情形一样。</p><p>我们再尝试寻找一条路径，可以找到s-&gt;v-&gt;u-&gt;t，其最小值为1，那么我们就将路径中各根水管的可流量减1，对应反向路径加1，得到下面这个图：</p><p><img src="/img/posts/max_flow_example6.png" srcset="/img/loading.gif" alt=""></p><p>在这里着重说下v&lt;-&gt;u路径，本来是u-&gt;v可流量为1，可撤回流量为2，现在我们撤回了流量为1的u-&gt;v水流并让其走u-&gt;t路径，所以u-&gt;v可流量变为2，可撤回流量为1，即最初我们到u的<code>2</code>水流，现在<code>1</code>走u-&gt;v，<code>1</code>走u-&gt;t。</p><p>再次寻找路径，发现没有可行的路径，结束。因此最终最大流为2+1=3。</p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p>其实前面我们求解最大流的方法就是Ford-Fulkerson方法。 这一方法只需重复以下步骤：</p><ol><li>寻找一条从出发点到目的地的可行路径，称为<strong>增广路径</strong>（argumenting path），没有则结束</li><li>找出该路径中权值的最小值</li><li>用这一最小值更新该路径中的前向边与反向边</li><li>将这一最小值累加到<code>max_flow</code>上（<code>max_flow</code>初始为0）</li></ol><p>最终得到的<code>max_flow</code>就是最大流。</p><p>Ford-Fulkerson为什么是称为方法而不是算法呢？因为它并没有指定如何寻找一条增广路径。一般而言有两种实现方法:</p><ol><li>DFS，总时间复杂度为$O(EC)$，$E$为图的边数，$C$为出发点$s$邻接边的权值之和$C:=\sum\limits_{e\,leaving\,s}C_e$。</li><li>BFS，总时间复杂度为$O(VE^2)$，$V$为图的顶点个数，是较优的算法，称为<strong>Edmonds-Karp算法</strong>。</li></ol><h2 id="为什么BFS优于DFS？"><a href="#为什么BFS优于DFS？" class="headerlink" title="为什么BFS优于DFS？"></a>为什么BFS优于DFS？</h2><p>我们可以看这样一个例子，显然最大流为20000：</p><p><img src="/img/posts/max_flow_example7.png" srcset="/img/loading.gif" alt=""></p><p>DFS寻找路径是不稳定的，我们在这里讨论最坏情况。假如我们第一次寻找到的路径为s-&gt;u-&gt;v-&gt;t，那么更新<code>max_flow</code>为1，得到下图：</p><p><img src="/img/posts/max_flow_example8.png" srcset="/img/loading.gif" alt=""></p><p>此时如果再寻找到的路径为s-&gt;v-&gt;u-&gt;t，那么更新<code>max_flow</code>为2，又会得到下图:</p><p><img src="/img/posts/max_flow_example9.png" srcset="/img/loading.gif" alt=""></p><p>我们可以发现，若如此反复，我们需要20000次迭代寻找路径，才能达到最大流。这就是使用DFS的弊端，由于寻找路径的不稳定，当出发点邻接边权值之和很大时，效率有可能极低。</p><p>而如果我们使用BFS，<strong>将流图当成无权图</strong>，那么我们每次都可以确定地找到<strong>最短路径</strong>，这样时间复杂度也就仅与顶点数、边数有关了，没有潜在的低效率风险。</p><h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><p>在这里我们给出伪代码（若需要多语言版本的实现，可参见<a href="https://www.programiz.com/dsa/ford-fulkerson-algorithm" target="_blank" rel="noopener">这里</a>）：</p><pre><code class="hljs cpp">rGraph = graph   <span class="hljs-comment">// 用原图初始化残留网络</span>max_flow = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> finding a path p from s to t in rGraph with DFS <span class="hljs-keyword">or</span> BFS &#123;    min_edge = min&#123;e(u, v) <span class="hljs-keyword">for</span> all e（u, v) in p&#125;;    <span class="hljs-function"><span class="hljs-keyword">for</span> each edge <span class="hljs-title">e</span><span class="hljs-params">(u, v)</span> in p </span>&#123;        rGraph[u][v] -= min_edge;   <span class="hljs-comment">// 更新前向边</span>        rGraph[v][u] += min_edge;   <span class="hljs-comment">// 更新后向边</span>    &#125;    max_flow += min_edge;&#125;<span class="hljs-keyword">return</span> max_flow;</code></pre><h1 id="最大流与最小割的关系"><a href="#最大流与最小割的关系" class="headerlink" title="最大流与最小割的关系"></a>最大流与最小割的关系</h1><p>最大流最小割定理：最大流=最小割。为了彻底理解这一定理，我们这里不得不涉及一些数学证明。</p><p>什么是割？简单来说，割就是将一个图切割为互不相连的子图。最小割是s-t割，是将一个图分为两个子集$S$和$T$，它们满足以下关系：</p><ol><li>$S \cup T = V$</li><li>$S \cap T = \varnothing$</li><li>$s \in S \, and \, t \in T$</li></ol><p>我们还需要知道什么是s-t割的容量，即从$S$集合指向$T$集合的边的权值之和（$T$集合指向$S$集合的不算），可以表示为</p><script type="math/tex;mode=display">c(S,T)=\sum\limits_{u \in S} \sum\limits_{v \in T}e(u,v)</script><p>最小割的目的就是让s-t割的容量最小。</p><p>对于一个s-t流，多少是从$S$集合<strong>真正</strong>流到$T$集合的呢？显然是它从$S$集合流到$T$集合的量减去从$T$集合流到$S$集合的量，即</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}f(S,T) &= \sum\limits_{u \in S} \sum\limits_{v \in T} f(u,v) -  \sum\limits_{v \in T} \sum\limits_{u \in S} f(v,u) \\    &= f^{out}(S) - f^{in}(S)\end{aligned}\end{equation}</script><p>有了以上这些定义的铺垫，我们可以很容易地写出以下关系式：</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}f(S,T) &= f^{out}(S) - f^{in}(S) \\       &\leq f^{out}(S) \\       &= \sum\limits_{e \, leaving \, S}f(e) \\       &\leq \sum\limits_{e\, leaving\, s} c(e)  \\       &= C(S,T)\end{aligned}\end{equation}</script><p>也就是当没有从$T$集合流入$S$集合的流量时，s-t流达到了最大值，而一条边的流量最大就是等于其容量，那么我们就得到了最大流=最小割。</p><h1 id="如何寻找最小割对应边？"><a href="#如何寻找最小割对应边？" class="headerlink" title="如何寻找最小割对应边？"></a>如何寻找最小割对应边？</h1><p>我们找到了最大流，根据最大流最小割定理，它的值也就是最小割，因此当我们找到了最大流，也就是没有s-&gt;t的增广路径时，剩下的残留网络刚好将$S$集合与$T$集合分割开来，这就是最小割。寻找最小割对应边也就十分简单了：</p><ol><li>找到最大流<code>max_flow</code></li><li>对最后的残留网络进行DFS/BFS遍历，可达的点集合为$S$，不可达的为$T$</li><li>从$S$集合到$T$集合的边，即$\forall e(u,v),\,u \in S, v \in T$就是最小割对应边</li></ol><h1 id="参考与推荐"><a href="#参考与推荐" class="headerlink" title="参考与推荐"></a>参考与推荐</h1><ul><li><p><a href="https://www.youtube.com/watch?v=oHy3ddI9X3o" target="_blank" rel="noopener">Network Flows: Max-Flow Min-Cut Theorem (&amp; Ford-Fulkerson Algorithm)</a> 如果还没理解的朋友，我强烈推荐观看这一个视频</p></li><li><p><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/netflow.pdf" target="_blank" rel="noopener">CMSC 451: Network Flows</a>、<a href="https://brilliant.org/wiki/edmonds-karp-algorithm/#complexity-proof" target="_blank" rel="noopener">Complexity Proof of Edmonds-Karp Algorithm</a> 规范的数学表述与证明</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论：常用的最短路算法详解</title>
    <link href="/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <url>/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文将讨论最常用的几个最短路算法，它们的用处各不相同，我们将探讨它们的原理，并给出伪代码实现。如果你通过这篇文章彻底理解了这些算法，那么将伪代码转换为可运行的源代码应该也不成问题:)</p><p>伪代码的规定：</p><ol><li>出发点：s</li><li>目的地(如果只有一个目的地）：d</li></ol><h1 id="Breath-first-Search"><a href="#Breath-first-Search" class="headerlink" title="Breath-first Search"></a>Breath-first Search</h1><p>Breath First Search（BFS），即广度优先搜索，刚学图论算法的朋友可能只用它进行图的遍历，但其实它也可以用来查找无权图的最短路径，只需加个<code>parent</code>数组记录前驱节点即可。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>广度优先搜索的原理十分简单，它从出发点一圈一圈地向外探索，直到遍历完所有点或遇到目的地。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了实现这一算法，我们只需重复以下步骤：</p><ol><li>从探索的前沿<code>frontier</code>中取出一个点<code>cur</code>，如果<code>cur</code>就是目的地，结束探索。</li><li>查看<code>cur</code>的各个邻接点，若该邻接点尚未访问过，则将其加入<code>frontier</code>，并将其标记为访问过。（对于未访问过的节点i，<code>parent[i]</code>恰好为-1，因此我们可以不需要多余的<code>visit</code>数组判断访问过与否）</li></ol><p>了解了实现的大致步骤，我们便可以写下如下伪代码：</p><pre><code class="hljs cpp">parent[s] = sparent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v != sfrontier = an empty <span class="hljs-built_in">queue</span>frontier.enqueue(s)<span class="hljs-keyword">while</span> !frontier.isEmpty() &#123;    cur = frontier.dequeue()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> parent[next] == <span class="hljs-number">-1</span> &#123;            parent[next] = cur            frontier.enqueue(next)        &#125;    &#125;&#125;</code></pre><h1 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h1><p>BFS只能处理无权图，但在很多时候，各条路径所需的开销是不同的，当开销不为负时，我们就可以使用Dijkstra算法了。（为什么开销一定不能为负呢？下面原理有解释）</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Dijkstra是贪心算法（每次都想取目前的最优），从出发点开始，它每次从不在最短路径树上的点集合中寻找最近的点，将其加入最短路径树，并从该点<strong>松弛</strong>它的邻接边，直到遍历完所有点或遇到目的地。</p><h3 id="松弛（relaxation）"><a href="#松弛（relaxation）" class="headerlink" title="松弛（relaxation）"></a>松弛（relaxation）</h3><p>本文讨论的对于有权图的最短路算法均用到了松弛。所以，到底什么是松弛？我们可以看一个简单的例子。</p><p><img src="/img/posts/relaxation.png" srcset="/img/loading.gif" alt="relaxation"></p><p>如图，当前从s到d的已知开销还是无穷大（即暂时不可达），但如果我们走经过x点的路径，<code>4 + 5 = 9 &lt; inf</code>,因此我们就可以更新s到d的开销为9，这一过程就称为松弛。我们可以由这个例子写出如下典型的代码：</p><pre><code class="hljs cpp"><span class="hljs-comment">// dist[n]存储的是从出发点到点n已知的开销, l(x, y)是x点到y点边所带的权</span><span class="hljs-keyword">if</span> (dist[d] &gt; dist[x] + l(x, d))    dist[d] = dist[x] + l(x, d);<span class="hljs-comment">// 也可以再简化下：</span>dist[d] = min(dist[d], dist[x] + l(x, d));</code></pre><h3 id="为什么不能有负权边？"><a href="#为什么不能有负权边？" class="headerlink" title="为什么不能有负权边？"></a>为什么不能有负权边？</h3><p>前面我们说到，若一个图要用Dijkstra算法，这个图必须没有负权边。这是由该算法的原理决定的，当我们从不在最短路径树上的点集合中找到一个最近的点时，我们会将其加入最短路径树，不再更改它的值。这样对没有负权值的图是合理的，但是若有负权值，这样最后的结果可能不是最短路径。我们可以考虑这样的情况：</p><p><img src="/img/posts/whycantnegative.png" srcset="/img/loading.gif" alt="why can&#39;t have negative edges"></p><p>y点已经在最短路径树上了，开销为3，按照算法，我们不会再修改它的值，但由于x点到y点是负权值，<code>4 - 2 = 2 &lt; 3</code>，实际的最短路径应该是s-&gt;x-&gt;y，距离为2，而不是3，这是Dijkstra算法无法处理的情况。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>其实Dijkstra和BFS是类似的，只不过因为边是有权值的，所以Dijkstra需要每次找到最近的点然后松弛它的邻接边。</p><p>这里我们使用优先队列这一数据结构来帮我们寻找不在最短路径树中最近的点，伪代码如下：</p><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; spriority_queue.insert(s)<span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;    cur = priority_queue.deletemin()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> dist[next] &gt; dist[cur] + l(cur, next) &#123;            parent[next] = cur            dist[next] = dist[cur] + l(cur, next)            priority_queue.insert(next)        &#125;    &#125;&#125;</code></pre><h1 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h1><p>BFS和Dijkstra算法是向四周一圈一圈地往外探索，当用于求解到其他多个点的最短路径时，这是合理的，但如果我们只是想求两个点之间的最短路径，这样就会做许多无用功，这时候我们就可以使用A*算法。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>A*算法较于Dijkstra算法就是多了一个<strong>启发函数</strong>（heuristic），它在计算时提供了一个目的地的导向，使我们能往那个方向探索。</p><h3 id="启发函数"><a href="#启发函数" class="headerlink" title="启发函数"></a>启发函数</h3><p>启发函数<strong>计算了当前解决问题的大概开销</strong>，在最短路径问题中，也就是当前点到目的地的距离。将到目的地的距离纳入考虑可以使我们更好地确定前往目的地的方向。</p><p>启发函数必须是可以简单快速计算出来的，否则会十分影响性能。关于启发函数，更多的内容可见：<a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" target="_blank" rel="noopener">Heuristics</a>。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>正如前面所说，A*算法与Dijkstra算法几乎一致，只是在优先队列排序中不仅仅考虑该点到出发点的距离，还要考虑到目的地的距离（启发函数）。因此我们可以很快地写出如下伪代码：</p><pre><code class="hljs cpp">heuristic(cur, d):    <span class="hljs-keyword">return</span> distance from cur to dmain:    dist[s] = <span class="hljs-number">0</span>    dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; s    priority_queue.insert(s)    <span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;        cur = priority_queue.deletemin()         <span class="hljs-keyword">if</span> (cur == d)             <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span> all neighbors next of cur &#123;            new_cost = dist[cur] + l(cur, next)            <span class="hljs-keyword">if</span> dist[next] &gt; new_cost &#123;                parent[next] = cur                dist[next] = new_cost                priority = new_cost + heuristic(next, d)                priority_queue.insert(next)            &#125;        &#125;    &#125;</code></pre><h1 id="Bellman-Ford-Algorithm"><a href="#Bellman-Ford-Algorithm" class="headerlink" title="Bellman-Ford Algorithm"></a>Bellman-Ford Algorithm</h1><p>Dijkstra算法和A*算法可以处理无负权值的最短路径问题，如果有负权值，我们就需要使用Bellman-Ford算法了，它还可以检测<strong>负权回路</strong>。</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>对于一个顶点数为n的图，从一点到另一点的最短路径长度不会大于n-1，因此我们只要进行n-1次的遍历操作，对所有的边都尝试松弛，如果没有负权回路，我们就能得到出发点到其余各点的最短路径。</p><p>或许与Dijkstra算法对比更好理解：Dijkstra算法是从出发点开始向外扩张，依次处理邻接边，并且如果一个点加入了最短路径树，它就不会再修改这个点的值了；而Bellman-Ford算法每次都是从出发点重新开始依次进行”松弛”更新操作，<strong>可能修改各点的值，这样也就能应对负权边了</strong>(可以回看下<a href="https://seineo.github.io/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9C%89%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%9F">这里</a>)。所以其实Bellman-Ford算法就是比Dijkstra算法多做了一些松弛操作，正常情况是肯定可以得到最短路径的。</p><p>Bellman-Ford是动态规划算法，为了处理<strong>从出发点到其余各点的最短路</strong>这一大问题，先解决<strong>从出发点到一目的地最多用了k条边的最短路</strong>这一小的子问题。</p><p>定义：$f(d,k)$=从$s$点到$d$点最多用了$k$条边的最短路径长度</p><p>那么对于基准情况——不使用一条边：</p><script type="math/tex;mode=display">\begin{equation}f(d,k) = \left\{    \begin{array}{l}    0 &d=s \\    \infty &d \neq s    \end{array}\right.\end{equation}</script><p>根据松弛操作，我们可以写出以下递推式：</p><script type="math/tex;mode=display">f(d,k) = \min \left\{    f(d,k-1), \min\limits_{w:(w,d)\in E} \left\{ f(w,k-1)+l(w,d) \right\}\right\}</script><p>由此我们便可以递推得出到其余各点$v$的最短路径$f(d,n-1)$。</p><h3 id="负权回路"><a href="#负权回路" class="headerlink" title="负权回路"></a>负权回路</h3><p>负权回路并不是含有负权边的回路，而是权值之和为负的回路。</p><p>为什么有负权回路就不能求解正确的最短路径呢？可以看下面这个例子，我们只关注b点：</p><p><img src="/img/posts/negativecycle.png" srcset="/img/loading.gif" alt="negetive cycle"></p><p>这个图中有4个顶点，因此我们需要遍历3次。在第一次的遍历中，到b的最短距离一开始是3，后面经过d点的松弛后变为了2，在以后的遍历中，每次遍历结束，到b的最短距离都减一，因此我们可以发现，如果存在负权回路，相关点的“最短路径”就可以一直减小下去（这也是我们检验是否存在负权回路的方法）。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>大致步骤：</p><ol><li>遍历vertex_num - 1次，对所有边都尝试松弛操作</li><li>再遍历一次，如果某些点还能更新最短路径，则说明有负权回路，该图不存在最短路径</li></ol><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF <span class="hljs-keyword">for</span> all v &lt;&gt; s<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;    <span class="hljs-keyword">for</span> all edge (v, w) &#123;        dist[w] = min(dist[w], dist[v] + l(v, w))    &#125;&#125;<span class="hljs-keyword">for</span> all edge (v, w) &#123;    <span class="hljs-keyword">if</span> dist[w] &gt; dist[v] + l(v, w)        output <span class="hljs-string">"negative cycle found"</span>&#125;</code></pre><h1 id="Floyd-Warshall-Algorithm"><a href="#Floyd-Warshall-Algorithm" class="headerlink" title="Floyd-Warshall Algorithm"></a>Floyd-Warshall Algorithm</h1><p>上述算法都是单源最短路算法，即从给定一点到另一点或其余各点，如果要求从任意一点到其余各点的最短路呢？当然，我们可以对每一个点调用上述算法，但Floyd-Warshall算法更为简洁优雅。</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>和Bellman-Ford算法一样，Floyd-Warshall算法也是动态规划算法，只不过前者是与边相关，而后者与点相关。因此如果你理解了上一算法的动态规划思想，那么这一算法你也就能很快的理解了，我们在这里就不过多解释了。</p><p>定义：$f(i,j,k)$ = 从点$i$到点$j$中途最多经过了$1,…,k$这些点的最短路径长度</p><p>基准情况——不经过任何点：</p><script type="math/tex;mode=display">\begin{equation}f(i,j,0) =\left\{             \begin{array}{l}             0 &i=j \\             l(i,j) &(i,j) \in E\\             \infty, &otherwise             \end{array}\right.\end{equation}</script><p>由松弛操作，我们可以得出以下递推式：</p><script type="math/tex;mode=display">f(i,j,k) = \min \left\{f(i,j,k-1),f(i,k,k-1)+f(k,j,k-1)\right\}</script><p>由此我们便可以递推出从任意点$i$到任意点$j$的最短路径$f(i,j,k)$。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>算法的核心代码其实就五行，十分简洁，思想就是对任意两点尝试经过各个点松弛。</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>;j &lt;= n;j++)             dist[i,j] = min(dist[i, j], dist[i, k] + dist[k, j])&#125;&#125;</code></pre><h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><div class="table-container"><table><thead><tr><th>算法</th><th>用处</th></tr></thead><tbody><tr><td>BFS</td><td>无权图，1-&gt;all</td></tr><tr><td>Dijkstra’s Algorithm</td><td>有权图，无负权边，1-&gt;all</td></tr><tr><td>A* Algorithm</td><td>有权图，无负权边，1-&gt;1</td></tr><tr><td>Bellman-Ford Algorithm</td><td>有权图，无负权回路，1-&gt;all</td></tr><tr><td>Floyd-Warshall Algorithm</td><td>有权图，all-&gt;all</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Introduction to the A* Algorithm</a></li><li><a href="https://stackoverflow.com/questions/26137239/what-is-a-heuristic-function" target="_blank" rel="noopener">What is a Heuristic Function</a></li><li><a href="https://downey.io/notes/omscs/cs6515/dynamic-programming-shortests-paths/" target="_blank" rel="noopener">dynamic programming - bellman-ford algorithm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms and Data Structures</title>
    <link href="/Algorithms-and-Data-Structures.html"/>
    <url>/Algorithms-and-Data-Structures.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>算法和数据结构是程序的基石，几乎每一个程序都需要它们，但绝大多数程序都不需要发明新的算法和数据结构。</p><p>为了方便后面的讨论，我们先在这里给出HTML中<code>name-value</code>键值对的定义：<br><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> <span class="hljs-title">Nameval</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> &#123;</span>    <span class="hljs-keyword">char</span> *name;    <span class="hljs-keyword">int</span> value;&#125;;</code></pre></p><h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><p>这里我们讨论一个现被广泛使用的排序算法：快排（quicksort）。</p><h2 id="快排的递归实现"><a href="#快排的递归实现" class="headerlink" title="快排的递归实现"></a>快排的递归实现</h2><p>快排的核心思想就是分治，它每次选出一个枢轴点（pivot），然后将数组中比这一点值小的数放在它左边，比它大的数放在它右边，再递归处理左边的数组和右边的数组。由此我们可以轻松地写出以下优雅的递归代码（枢轴点随机）：<br><pre><code class="hljs c"><span class="hljs-comment">/* swap - swap arr[i] and arr[j] */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp;    temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;<span class="hljs-comment">/* quicksort - sort the array into increasing order recursively */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n_arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (n_arr &lt;= <span class="hljs-number">1</span>)    <span class="hljs-comment">/* if array size &lt; 1, then no need for sorting */</span>        <span class="hljs-keyword">return</span>;    swap(arr, <span class="hljs-number">0</span>, rand() % n_arr); <span class="hljs-comment">/* generate pivot and move it to v[0] */</span>    <span class="hljs-comment">/* move the elements smaller than pivot */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n_arr; ++i) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[<span class="hljs-number">0</span>])            swap(arr, ++last, i);    &#125;    <span class="hljs-comment">/* restore povit */</span>    swap(arr, <span class="hljs-number">0</span>, last);    <span class="hljs-comment">/* recursively sort each part */</span>    quicksort(arr, last);    quicksort(arr + last + <span class="hljs-number">1</span>, n_arr - last - <span class="hljs-number">1</span>);&#125;</code></pre></p><h2 id="快排的迭代实现"><a href="#快排的迭代实现" class="headerlink" title="快排的迭代实现"></a>快排的迭代实现</h2><p>快排一般都是用递归形式写的，那么它如何用迭代的方式来写呢？</p><p>对于可以用分治解决的问题，我们一般都可以用辅助栈来将递归转换为迭代。这里我使用C++来实现，这样可以让我们更专注于算法思想而非语言的细枝末节。<br><pre><code class="hljs cpp"><span class="hljs-comment">// keep the range being sorted</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SortRange</span> &#123;</span>    <span class="hljs-comment">// constructor</span>    SortRange(<span class="hljs-keyword">size_t</span> s, <span class="hljs-keyword">size_t</span> e) : start(s), end(e) &#123;&#125;    <span class="hljs-keyword">size_t</span> start;    <span class="hljs-keyword">size_t</span> end;  <span class="hljs-comment">// exclude index end</span>&#125;;<span class="hljs-comment">// quicksort_iter - sort the array into increasing order iteratively</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort_iter</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;    <span class="hljs-built_in">stack</span>&lt;SortRange&gt; helper;    <span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-literal">nullptr</span>))</span></span>;    helper.push(&#123;<span class="hljs-number">0</span>, arr.size()&#125;);    <span class="hljs-comment">// sort until the stack is empty</span>    <span class="hljs-keyword">while</span> (!helper.empty()) &#123;        <span class="hljs-keyword">size_t</span> last, start, end;        start = helper.top().start;        end = helper.top().end;        last = start;        <span class="hljs-comment">// generate uniform distribution random numbers from [start, end-1]</span>        <span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-keyword">size_t</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(start, end - <span class="hljs-number">1</span>)</span></span>;        helper.pop();        <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">// if array size &lt;= 1, no need for sorting</span>            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// generate pivot and move it to arr[start]</span>        swap(arr[start], arr[u(e)]);        <span class="hljs-comment">// move the elements smaller than pivot</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = start + <span class="hljs-number">1</span>; i != end; ++i)            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[start])                swap(arr[++last], arr[i]);        <span class="hljs-comment">// restore pivot</span>        swap(arr[start], arr[last]);        <span class="hljs-comment">// put each part into stack for next loop</span>        helper.push(&#123;start, last&#125;);        helper.push(&#123;last + <span class="hljs-number">1</span>, end&#125;);    &#125;&#125;</code></pre><br>那么是不是我们应该避免用递归实现快排呢？毕竟“迭代快于递归”嘛。其实，快排可以说是递归优于迭代的典例了，既优雅又高效，可以放心地用递归版本。两者效率的讨论详见：<a href="https://stackoverflow.com/questions/12553238/quicksort-iterative-or-recursive" target="_blank" rel="noopener">Quicksort:Iterative or Recursive</a></p><h2 id="快排的性能"><a href="#快排的性能" class="headerlink" title="快排的性能"></a>快排的性能</h2><p>显然快排是效率较高的排序算法，因为它不需要接连地与每一个其他数组元素比较，而每次只需与枢轴点的值比较，比它小就放左边，比它大就放右边。这一点就使得快排优于插入排序和冒泡排序。</p><p>若每轮都能较为平均地分为两部分，那么当整个数组共有n个元素时，n + 2 <em>n / 2 + 3 </em>n / 3 + ……共有logn轮，因此时间复杂度为O(nlogn)。但现实中是会有一些特殊的输入序列会使快排的划分完全不均匀，致使较差的性能表现，主要有以下三种：</p><ol><li>已经接近顺序</li><li>已经接近逆序</li><li>所有元素都相等（其实是前两种的特殊情况）</li></ol><p>在这些时候，若枢轴点选择不当，可以达到最差时间复杂度O(n<sup>2</sup>)。</p><h1 id="Growing-Arrays"><a href="#Growing-Arrays" class="headerlink" title="Growing Arrays"></a>Growing Arrays</h1><p>这一节主要是讨论如何用C实现一个动态数组（类似C++中的vector），相比于实现的算法思路，我认为书中的一个设计细节更为引人注目。</p><p>当数组元素的个数要超出现有已分配的数组大小时，我们需要再分配更多的内存来容纳元素，在C语言中也就需要<code>realloc</code>函数。若实现动态数组的数据结构如下：<br><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NVtab</span> &#123;</span>    <span class="hljs-keyword">int</span> nval;   <span class="hljs-comment">/* current number of values */</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">/* allocated number of values */</span>    Nameval *nameval;    <span class="hljs-comment">/* array of name-value pairs */</span>&#125;nvtab;</code></pre><br>那么在增添数组元素的函数中，我们很可能写出这样的代码：<br><pre><code class="hljs c">...<span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    nvtab.nameval = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    ...&#125;</code></pre><br>当分配内存成功时，这段代码是没问题的。但如果分配失败的话，<code>nvtab.namval</code>所指向的数组就会丢失了。因此，我们应该用一个局部变量来暂存分配的结果，若分配成功了，再由<code>nvtab.nameval</code>接管分配好的数组。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    Nameval *tmp = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    nvtab.nameval = tmp;    ...&#125;</code></pre></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><blockquote><p><strong>Exercise 2-8.</strong> Write recursive and iterative versions of <code>reverse</code>, which reverses a list. Do not create new list items; re-use the existing ones.</p></blockquote><p>这是一个很典型的数据结构题。我们在稍加思索后可以很容易地想出迭代的解法：遍历链表，将每一个节点指向它的前一个节点，第一个节点指向<code>NULL</code>。转换为代码：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_iter - reverse the whole list iteratively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_iter</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *next;    Nameval *prev = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> (listp != <span class="hljs-literal">NULL</span>) &#123;        next = listp-&gt;next;        listp-&gt;next = prev;        prev = listp;        listp = next;    &#125;    <span class="hljs-keyword">return</span> prev; &#125;</code></pre><br>那么如何递归地求解呢？写递归，最关键就是要牢记两条基本准则：</p><blockquote><ol><li><strong>基准情形</strong>。必须要有某些基准情形，它无须递归就能解出。</li><li><strong>不断推进</strong>。对于需要递归求解的情形，每一次递归调用都必须朝着接近基准情形的方向推进。</li></ol><p>摘录自《数据结构与算法分析——C语言描述》</p></blockquote><p>在这一道题目中，基准情况就是链表的第一个节点和最后一个节点。</p><ol><li>若链表为空，则返回空。</li><li>若链表只有一个节点或到达了最后一个节点，这个节点就是头结点，它应指向前一个节点或<code>NULL</code>。</li></ol><p>链表是单向的，它无法在顺序遍历时不记住前一个节点的情况下，指向前一个节点，因此我们应该在递归回溯时从后往前修改指针以达到指向前一个节点的目的。如：<br><pre><code class="hljs c">node-&gt;next-&gt;next = node;</code></pre><br>这样便实现了让后一个节点指向前一个节点。</p><p>综上，我们便可以写出递归的解法：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_recur_helper - help to reverse the list recursively and get the head node */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse_recur_helper</span><span class="hljs-params">(Nameval *listp, Nameval **head)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (listp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (listp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;        *head = listp;        <span class="hljs-keyword">return</span>;    &#125;    reverse_recur_helper(listp-&gt;next, head);    listp-&gt;next-&gt;next = listp;    listp-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">/* reverse_recur - reverse the list recursively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_recur</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *head;    reverse_recur_helper(listp, &amp;head);    <span class="hljs-keyword">return</span> head;&#125;</code></pre></p><h1 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h1><p>在实现哈希表的查找时，我们很容易想到这样实现：<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><br>但这样的实现会使得如下的操作进行两次<code>hash</code>计算：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (lookup(<span class="hljs-string">"name"</span>) == <span class="hljs-literal">NULL</span>)    additem(newitem(<span class="hljs-string">"name"</span>, value));</code></pre><br>因此，将查找和插入选项结合起来是一个更好的选择。<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> create, <span class="hljs-keyword">int</span> value)</span></span>;</code></pre></p><h1 id="将整型转换为字符串"><a href="#将整型转换为字符串" class="headerlink" title="将整型转换为字符串"></a>将整型转换为字符串</h1><p>在创建HTML<code>name-value</code>键值对时，为了方便，我想将<code>name</code>直接表示为<code>value</code>的字符串形式。在C++中，这是十分容易实现的：<br><pre><code class="hljs cpp">name = to_string(value);</code></pre><br>在C语言当中，我以前一直都是使用<code>itoa</code>函数的，但最近才发现该函数并不属于C语言标准，标准的写法应为：<br><pre><code class="hljs c"><span class="hljs-comment">/* to_string - convert an int to string */</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">char</span> *buf;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;    <span class="hljs-built_in">size</span> = <span class="hljs-built_in">snprintf</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"%d"</span>, value);  <span class="hljs-comment">/* get length of string */</span>    buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">/* allocate one character more for null-terminator */</span>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>, <span class="hljs-string">"%d"</span>, value);    <span class="hljs-keyword">return</span> buf;&#125;name = to_string(value);</code></pre></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bamsoftware.com/computers/tpop-answers.html" target="_blank" rel="noopener">Answers to the exercises in tpop</a></li><li><a href="https://www.youtube.com/watch?reload=9&amp;v=MRe3UsRadKw" target="_blank" rel="noopener">Reverse a Linked List Recursively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style</title>
    <link href="/Style.html"/>
    <url>/Style.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>代码风格是十分重要的，一个好的代码风格可以帮助读者更好地理解代码，也能帮助自己在写程序时及时排错。</p><h1 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h1><blockquote><p>Use descriptive names for globals, short names for locals.</p></blockquote><p>学习第一门程序语言时，我们总被教导道：要使用足够长的变量命名，这样读者才好理解这个变量的用途。其实这样是不对的。</p><p>全局变量的名字是需要足够长、足够具体的，因为他们可能出现在程序的各个地方，这样的名字可以帮助作者和读者回想起这个变量的用途。而局部变量简短些即可，比如要表示学生的人数，<code>n</code>也许就够了，<code>n_stu</code>也不错，但是<code>number_of_stu</code>就没必要，会显得代码冗长。</p><blockquote><p>Use active names for functions.</p></blockquote><p>函数名应该是动态的。比如要打印数组，<code>print_arr</code>就很好，而单独一个<code>arr</code>就让人不知道该函数的用途。名字中的动词也需要足够直白，比如返回布尔值的函数，<code>check_even</code>是模棱两可的，因为它并没有说明如果是偶数返回真还是假，而<code>is_even</code>就让人清楚地知道如果是偶数，该函数返回真。</p><h1 id="Expressions-and-Statements"><a href="#Expressions-and-Statements" class="headerlink" title="Expressions and Statements"></a>Expressions and Statements</h1><blockquote><p>Parenthesize to reslove ambiguity.</p></blockquote><p>括号可以清晰的划分结构与优先级，即使不需要的时候我们也可以加上以避免不必要的错误和增加可读性。</p><p>比如<code>if (x&amp;MASK == BITS)</code>，显然其本意是想判断<code>x</code>和掩码进行与运算后是否等于<code>BITS</code>，但由于位操作符的优先级低于等于号，这段代码实际上等价于<code>if (x &amp; (MASK == BITS))</code>，这也就发生了意料之外的错误，因此这个表达式需要加上括号，即<code>if ((x&amp;MASK) == BITS)</code>。</p><p>又如这样一个表达式：<br><pre><code class="hljs c">leap_year = y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != || y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;</code></pre><br>这当然是没错的，但第一眼看去，我们难以把握结构，若按如下修改会清晰得多：<br><pre><code class="hljs c">leap_year = ((y%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (y%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (y%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>));</code></pre><br>注意到，我们移去了一些空格，使高优先级的操作符更紧凑，这样可以帮助读者更快地把握结构。</p><blockquote><p>Be careful with side effects.</p></blockquote><p>不了解序列点(sequence point)、副作用(side effect)和未定义行为(undefined behavior)的朋友可先参见：<a href="https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points" target="_blank" rel="noopener">Undefined behavior and sequence points</a></p><p>在C和C++中，一个序列点前副作用的执行顺序是未定义的。如：<br><pre><code class="hljs c">str[i++] = str[i++] = <span class="hljs-string">' '</span>;</code></pre><br>在这里，<code>;</code>就是一个序列点，而我们知道，<code>++</code>操作符是有副作用的，它不仅返回一个值，还会修改该变量的值。所以在这一语句中对同一个变量多次<code>++</code>操作导致了未定义行为。因为虽然我们心里想的是<code>i</code>增加两次，但编译器不知道到底<code>i</code>是增加一次还是两次，也不知道是左边的<code>i</code>是使用右边的<code>i</code>递增后的值还是原来的值，这就导致了<code>warning: multiple unsequenced modification to i</code>。</p><p>再看一个我从书本Exercise 1-5改编的例子，以下代码片段有什么问题呢？<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ip)</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, ip);    <span class="hljs-keyword">return</span> *ip;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, a, b); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">read</span>(&amp;a), <span class="hljs-built_in">read</span>(&amp;b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><br>我们可以先看看当输入为<code>2 3</code>时，不同编译器下的输出结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">编译器</th><th style="text-align:left">输出结果</th></tr></thead><tbody><tr><td style="text-align:left">gcc</td><td style="text-align:left">3 2</td></tr><tr><td style="text-align:left">clang</td><td style="text-align:left">2 3</td></tr></tbody></table></div><p><code>scanf</code>函数不是分别运行的吗？为什么会产生这样的奇怪的结果呢？原因是<em>函数调用计算完所有参数后且执行被调用函数前</em>也是一个序列点，而我们这里的函数参数计算里含有I/O操作，I/O操作也有副作用，所以这里函数参数的计算顺序也是未定义的，因此如果先计算第一个参数，那么<code>2</code>就会被写入参数<code>a</code>中，<code>3</code>就会被写入<code>b</code>中，输出结果同clang；但如果先计算第二个参数，<code>2</code>和<code>3</code>就会被分别写入<code>b</code>和<code>a</code>中，输出结果同gcc。</p><h1 id="Consistency-and-Idioms"><a href="#Consistency-and-Idioms" class="headerlink" title="Consistency and Idioms"></a>Consistency and Idioms</h1><p>在这一节中，基本都是熟知的准则，不再赘述。但下面这个代码示例告诉了我们一种优雅处理嵌套的<code>if else</code>错误判断语句的方式。</p><p>我们很可能写出类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>)     <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)                putc(c,fout);            fclose(fin);            fclose(fout);        &#125; <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);</code></pre></p><p>使用递进的<code>if</code>判断，最终是前期准备无错误的处理代码，然后再用多个<code>else</code>分别处理各种错误情况。这段代码并不优雅，并且有资源泄露的可能——如果<code>fout</code>打开文件失败，那么<code>fin</code>打开的文件就不会显式关闭，未显式关闭文件可能导致的问题可参见：<a href="https://www.quora.com/Why-do-we-need-to-close-files-in-programming-after-performing-a-read-or-write-operation" target="_blank" rel="noopener">Why do we need to close files?</a><br>那么如何改进呢？我们可以使用<code>if, else if</code>来推进，先处理错误情况，最终才是正常情况下的代码。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    fclose(fin); <span class="hljs-comment">/* release the resource fin occupied */</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)        putc(c,fout);    fclose(fin);    fclose(fout);&#125;</code></pre></p><h1 id="Function-Macros"><a href="#Function-Macros" class="headerlink" title="Function Macros"></a>Function Macros</h1><blockquote><p>Avoid function macros.</p></blockquote><p>宏是进行文本的替换，因此如果函数宏定义中参数出现了多次，那么它就会被计算多次，这在大多数时候都不是我们想要的。如：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isupper(c) ((c) &gt;= <span class="hljs-meta-string">'A'</span> &amp;&amp; (c) &lt;= <span class="hljs-meta-string">'Z'</span>)</span>...<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(c = getchar()))    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c is uppercase\n"</span>, c);</code></pre><br>那么实际<code>if</code>的判断语句等价于<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (((c = getchar()) &gt;= <span class="hljs-string">'A'</span> &amp;&amp; (c = getchar()) &lt;= <span class="hljs-string">'Z'</span>))</code></pre><br>这显然是错误的，假定我们输入一个字符然后回车，那么只要这个字符的ASCII码值大于等于A的码值就会有输出，因为逻辑与表达式的第二部分程序又读了一个字符，这个字符就是留在缓冲区的<code>\n</code>字符，其ASCII码值为<code>0xa</code>，小于<code>Z</code>的码值。</p><p>很多人习惯使用宏来管理幻数/魔数(Magic Numbers)，其实尽量不要用C预处理器来做这件事，让语言本身来处理是更好的。在C++中可以用<code>const</code>来声明常量：<br><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ARR_SIZE = <span class="hljs-number">5</span>;</code></pre><br>C中当然也有<code>const</code>，值得注意的是，用<code>const</code>修饰的值是无法作为<code>静态数组</code>的边界的（因为这是<code>运行时常量</code>），但<code>enum</code>可以实现这一点：<br><pre><code class="hljs c"><span class="hljs-keyword">enum</span> &#123;ARR_SIZE = <span class="hljs-number">5</span>&#125;;</code></pre></p><p>那这是不是意味着我们永远不能使用宏呢？并不是，我们应该让宏做函数做不了的事情。典型的例子就是仅由声明计算数组的长度：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NELEMS(array) (sizeof(array) / sizeof(array[0]))</span></code></pre><br>在这里，<code>sizeof(array)</code>计算的就是数组本身的长度，而在函数中，数组参数退化为指针，<code>sizeof(array)</code>就只能计算出指针的大小了。对数组和指针关系不太明确的朋友可参考：<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">is an array name a pointer?</a></p><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><blockquote><p>Comment functions and global data.</p></blockquote><p>给每个函数和全局变量写适当的注释是一个好习惯。在我接触的好的代码风格中，也有的还在文件开头写一个文件的注释，告诉读者这一个文件的主要用途以及注意事项等，个人认为这也值得学习。</p><blockquote><p>Don’t comment bad code, rewrite it.</p></blockquote><p>这一准则给出了一个有意思的判断，即当注释的字数多过于要注释的代码段时，这段代码可能就是<code>bad code</code>。这时应该看看是否需要改善代码而不是坚持注释。</p><p>至此，第一章就结束了，希望我们都能形成一个好的代码风格。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int ch = getchar()?</title>
    <link href="/int-ch-getchar.html"/>
    <url>/int-ch-getchar.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>也许你看过/写过类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这段代码看起来没什么问题，但实际上代码中的循环有可能永不终止，也有可能提前结束。</p><h1 id="函数与EOF介绍"><a href="#函数与EOF介绍" class="headerlink" title="函数与EOF介绍"></a>函数与EOF介绍</h1><p>在解释之前，我们先了解下相关内容。C语言常用的字符读取函数如下：<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getchar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre><br>这三个函数都是从文件流中读取一个字符，正常情况下把该字符从<code>unsigned char</code>转换为<code>int</code>类型返回，若出错或读到文件结尾则返回<code>EOF</code>。</p><p><code>EOF</code>又是什么呢？<code>EOF</code>只是一个宏定义的负整数而已，一般为<code>-1</code>(hex:0xffffffff)。</p><p>由于上述函数区别不大，此文便只用最常见的<code>getchar</code>函数来讨论。</p><h1 id="char-ch-getchar-错在哪里？"><a href="#char-ch-getchar-错在哪里？" class="headerlink" title="char ch = getchar()错在哪里？"></a>char ch = getchar()错在哪里？</h1><p>看到这，你可能会说：既然<code>EOF</code>只是值为<code>-1</code>的负整数，这不是在<code>char</code>的表示范围-128~127内吗？用<code>char</code>保存返回值有何不可？</p><p><code>-1</code>真的一定在<code>char</code>的表示范围内吗？我们可以在头文件<code>limits.h</code>中看到如下定义：<br><pre><code class="hljs c"><span class="hljs-comment">/* Minimum and maximum values a `signed char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MIN(-128)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MAX127</span><span class="hljs-comment">/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UCHAR_MAX255</span><span class="hljs-comment">/* Minimum and maximum values a `char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CHAR_UNSIGNED__</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MIN0</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXUCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MINSCHAR_MIN</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXSCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br>由此可见，标准并未规定<code>char</code>是有符号的，而是留给各个编译器自己实现。</p><p>所以当<code>char</code>默认为无符号时，<code>-1</code>就不在其表示范围内，这时使用<code>char</code>保存返回值也就有问题了。实际上即使你所用的编译器默认定义<code>char</code>是有符号的，文章开头的那段代码依然有潜在的bug。下面我们分为<code>char</code>默认无符号和有符号两种情况讨论，利用计算机组成原理的知识来详细解释为什么不应该用<code>char</code>保存<code>getchar</code>的返回值。</p><h2 id="1-char默认是无符号的"><a href="#1-char默认是无符号的" class="headerlink" title="1. char默认是无符号的"></a>1. char默认是无符号的</h2><p><strong>这种情况会导致循环无法终止。</strong>假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，这时由于<code>ch</code>是<code>char</code>类型，只有一个字节，而<code>EOF</code>是<code>int</code>类型，有四个字节却要保存在一个字节中，<code>EOF</code>的值会被截断，<code>ch</code>也就等于<code>0xff</code>，又因为<code>ch</code>要与<code>EOF</code>比较，<code>ch</code>符号扩展得<code>0x000000ff</code>（因为<code>ch</code>是无符号的，也就是0扩展），永远不可能等于<code>EOF</code>，循环也就永远不会终止。</p><h2 id="2-char默认是有符号的"><a href="#2-char默认是有符号的" class="headerlink" title="2. char默认是有符号的"></a>2. char默认是有符号的</h2><p><strong>这种情况可能导致循环提前终止。</strong>同样假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，前面都一样，但是在符号扩展的时候，由于<code>ch</code>是有符号的，其扩展得<code>0xffffffff</code>，等于<code>EOF</code>。因此循环是可以终止的，但是如果我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，循环就会同碰到<code>EOF</code>一样终止。</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>那么如何修改代码才是正确的呢？其实只需要用<code>int</code>来保存返回值即可。<br><pre><code class="hljs c"><span class="hljs-keyword">int</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这种情况就不会有问题。即使我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，由于<code>ch</code>是<code>int</code>类型，而<code>getchar</code>是将读到的字符由<code>unsigned char</code>转为<code>int</code>作返回值，则该字节的值经符号扩展再赋值给<code>ch</code>，<code>ch</code>就等于<code>0x000000ff</code>，不会等于<code>EOF</code>，也就不会提前终止了。</p><p>综上，这就是为什么要用<code>int</code>类型而不是<code>char</code>类型来保存C语言字符读取函数的返回值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default" target="_blank" rel="noopener">is char signed or unsigned by default?</a></li><li><a href="https://stackoverflow.com/questions/13694394/while-c-getcfile-eof-loop-wont-stop-executing" target="_blank" rel="noopener">why the loop won’t stop executing?</a></li><li><a href="https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284351&amp;answer=1048865140" target="_blank" rel="noopener">Definition of EOF and how to use it effectively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
