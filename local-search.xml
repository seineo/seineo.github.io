<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图论：常用的最短路算法详解</title>
    <link href="/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <url>/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文将讨论最常用的几个最短路算法，它们的用处各不相同，我们将探讨它们的原理，并给出伪代码实现。如果你通过这篇文章彻底理解了这些算法，那么将伪代码转换为可运行的源代码应该也不成问题:)</p><p>伪代码的规定：</p><ol><li>出发点：s</li><li>目的地(如果只有一个目的地）：d</li></ol><h1 id="Breath-first-Search"><a href="#Breath-first-Search" class="headerlink" title="Breath-first Search"></a>Breath-first Search</h1><p>Breath First Search（BFS），即广度优先搜索，刚学图论算法的朋友可能只用它进行图的遍历，但其实它也可以用来查找无权图的最短路径。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>广度优先搜索的原理十分简单，它从出发点一圈一圈地向外探索，直到遍历完所有点或遇到目的地。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了实现这一算法，我们只需重复以下步骤：</p><ol><li>从探索的前沿<code>frontier</code>中取出一个点<code>cur</code>，如果<code>cur</code>就是目的地，结束探索。</li><li>查看<code>cur</code>的各个邻接点，若该邻接点尚未访问过，则将其加入<code>frontier</code>，并将其标记为访问过。</li></ol><p>了解了实现的大致步骤，我们便可以写下如下伪代码：</p><pre><code class="hljs cpp">parent[s] = sparent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; sfrontier = an empty <span class="hljs-built_in">queue</span><span class="hljs-keyword">while</span> !frontier.isEmpty() &#123;    cur = frontier.dequeue()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> parent[next] == <span class="hljs-number">-1</span> &#123;            parent[next] = cur            frontier.enqueue(next)        &#125;    &#125;&#125;</code></pre><h1 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h1><p>BFS只能处理无权图，但在很多时候，各条路径所需的开销是不同的，当开销不为负时，我们就可以使用Dijkstra算法了。（为什么开销一定不能为负呢？下面原理有解释）</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Dijkstra是贪心算法（每次都想取目前的最优），从出发点开始，它每次从不在最短路径树上的点集合中寻找最近的点，将其加入最短路径树，并从该点<strong>松弛</strong>它的邻接边，直到遍历完所有点或遇到目的地。</p><h3 id="松弛（relaxation）"><a href="#松弛（relaxation）" class="headerlink" title="松弛（relaxation）"></a>松弛（relaxation）</h3><p>本文讨论的对于有权图的最短路算法均用到了松弛。所以，到底什么是松弛？我们可以看一个简单的例子。</p><p><img src="/img/posts/relaxation.png" srcset="/img/loading.gif" alt="relaxation"></p><p>如图，当前从s到d的已知开销还是无穷大（即暂时不可达），但如果我们走经过x点的路径，<code>4 + 5 = 9 &lt; inf</code>,因此我们就可以更新s到d的开销为9，这一过程就称为松弛。我们可以由这个例子写出如下典型的代码：</p><pre><code class="hljs cpp"><span class="hljs-comment">// dist[n]存储的是从出发点到点n已知的开销, l(x, y)是x点到y点边所带的权</span><span class="hljs-keyword">if</span> (dist[d] &gt; dist[x] + l(x, d))    dist[d] = dist[x] + l(x, d);<span class="hljs-comment">// 也可以再简化下：</span>dist[d] = min(dist[d], dist[x] + l(x, d));</code></pre><h3 id="为什么不能有负权边？"><a href="#为什么不能有负权边？" class="headerlink" title="为什么不能有负权边？"></a>为什么不能有负权边？</h3><p>前面我们说到，若一个图要用Dijkstra算法，这个图必须没有负权边。这是由该算法的原理决定的，当我们从不在最短路径树上的点集合中找到一个最近的点时，我们会将其加入最短路径树，不再更改它的值。这样对没有负权值的图是合理的，但是若有负权值，这样最后的结果可能不是最短路径。我们可以考虑这样的情况：</p><p><img src="/img/posts/whycantnegative.png" srcset="/img/loading.gif" alt="why can&#39;t have negative edges"></p><p>y点已经在最短路径树上了，开销为3，按照算法，我们不会再修改它的值，但由于x点到y点是负权值，<code>4 - 2 = 2 &lt; 3</code>，实际的最短路径应该是s-&gt;x-&gt;y，距离为2，而不是3，这是Dijkstra算法无法处理的情况。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>其实Dijkstra和BFS是类似的，只不过因为边是有权值的，所以Dijkstra需要每次找到最近的点然后松弛它的邻接边。</p><p>这里我们使用优先队列这一数据结构来帮我们寻找最近的点，伪代码如下：</p><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; spriority_queue.insert(s)<span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;    cur = priority_queue.deletemin()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> dist[next] &gt; dist[cur] + l(cur, next) &#123;            parent[next] = cur            dist[next] = dist[cur] + l(cur, next)            priority_queue.insert(next)        &#125;    &#125;&#125;</code></pre><h1 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h1><p>BFS和Dijkstra算法是向四周一圈一圈地往外探索，当用于求解到其他多个点的最短路径时，这是合理的，但如果我们只是想求两个点之间的最短路径，这样就会做许多无用功，这时候我们就可以使用A*算法。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>A*算法较于Dijkstra算法就是多了一个<strong>启发函数</strong>（heuristic），它在计算时提供了一个目的地的导向，使我们能往那个方向探索。</p><h3 id="启发函数"><a href="#启发函数" class="headerlink" title="启发函数"></a>启发函数</h3><p>启发函数<strong>计算了当前解决问题的大概开销</strong>，在最短路径问题中，也就是当前点到目的地的距离。将到目的地的距离纳入考虑可以使我们更好地确定前往目的地的方向。</p><p>启发函数必须是可以简单快速计算出来的，否则会十分影响性能。关于启发函数，更多的内容可见：<a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" target="_blank" rel="noopener">Heuristics</a>。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>正如前面所说，A*算法与Dijkstra算法几乎一致，只是在优先队列排序中不仅仅考虑该点到出发点的距离，还要考虑到目的地的距离（启发函数）。因此我们可以很快地写出如下伪代码：</p><pre><code class="hljs cpp">heuristic(cur, d):    <span class="hljs-keyword">return</span> distance from cur to dmain:    dist[s] = <span class="hljs-number">0</span>    dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; s    priority_queue.insert(s)    <span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;        cur = priority_queue.deletemin()        <span class="hljs-keyword">for</span> all neighbors next of cur &#123;            new_cost = dist[cur] + l(cur, next)            <span class="hljs-keyword">if</span> dist[next] &gt; new_cost &#123;                parent[next] = cur                dist[next] = new_cost                priority = new_cost + heuristic(next, d)                priority_queue.insert(next)            &#125;        &#125;    &#125;</code></pre><h1 id="Bellman-Ford-Algorithm"><a href="#Bellman-Ford-Algorithm" class="headerlink" title="Bellman-Ford Algorithm"></a>Bellman-Ford Algorithm</h1><p>Dijkstra算法和A*算法可以处理无负权值的最短路径问题，如果有负权值，我们就需要使用Bellman-Ford算法了，它还可以检测<strong>负权回路</strong>。</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>对于一个顶点数为n的图，从一点到另一点的最短路径长度不会大于n-1，因此我们只要进行n-1次的遍历操作，对所有的边都尝试松弛，如果没有负权回路，我们就能得到出发点到其余各点的最短路径。</p><p>或许与Dijkstra算法对比更好理解：Dijkstra算法是从出发点开始向外扩张，依次处理相邻的节点，如果一个点加入了最短路径树，它就不会再修改这个点的值了；而Bellman-Ford算法每次都是从出发点重新开始依次进行”松弛”更新操作，<strong>可能修改各点的值，这样也就能应对负权边了</strong>(可以回看下<a href="https://seineo.github.io/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9C%89%E8%B4%9F%E6%9D%83%E8%BE%B9">这里</a>)。所以其实Bellman-Ford算法就是比Dijkstra算法多做了一些松弛操作，正常情况是肯定可以得到最短路径的。</p><p>Bellman-Ford是动态规划算法，为了处理<strong>从出发点到其余各点的最短路</strong>这一大问题，先解决<strong>从出发点到一目的地最多用了k条边的最短路</strong>这一小的子问题。</p><p>定义：$f(d,k)$=从$s$点到$d$点最多用了$k$条边的最短路径长度</p><p>那么对于基准情况——不使用一条边：</p><script type="math/tex;mode=display">\begin{equation}f(d,k) = \left\{    \begin{array}{l}    0 &d=s \\    \infty &d \neq s    \end{array}\right.\end{equation}</script><p>根据松弛操作，我们可以写出以下递推式：</p><script type="math/tex;mode=display">f(d,k) = \min \left\{    f(d,k-1), \min\limits_{w:(w,d)\in E} \left\{ f(w,k-1)+l(w,d) \right\}\right\}</script><p>由此我们便可以递推得出到其余各点$v$的最短路径$f(d,n-1)$。</p><h3 id="负权回路"><a href="#负权回路" class="headerlink" title="负权回路"></a>负权回路</h3><p>负权回路并不是含有负权边的回路，而是权值之和为负的回路。</p><p>为什么有负权回路就不能求解正确的最短路径呢？可以看下面这个例子，我们只关注b点：</p><p><img src="/img/posts/negativecycle.png" srcset="/img/loading.gif" alt="negetive cycle"></p><p>这个图中有4个顶点，因此我们需要遍历3次。在第一次的遍历中，到b的最短距离一开始是3，后面经过d点的松弛后变为了2，在以后的遍历中，每次遍历结束，到b的最短距离都减一，因此我们可以发现，如果存在负权回路，相关点的“最短路径”就可以一直减小下去（这也是我们检验是否存在负权回路的方法）。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>大致步骤：</p><ol><li>遍历vertex_num - 1次，对所有边都尝试松弛操作</li><li>再遍历一次，如果某些点还能更新最短路径，则说明有负权回路，该图不存在最短路径</li></ol><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF <span class="hljs-keyword">for</span> all v &lt;&gt; s<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;    <span class="hljs-keyword">for</span> all edge (v, w) &#123;        dist[w] = min(dist[w], dist[v] + l(v, w))    &#125;&#125;<span class="hljs-keyword">for</span> all edge (v, w) &#123;    <span class="hljs-keyword">if</span> dist[w] &gt; dist[v] + l(v, w)        output <span class="hljs-string">"negative cycle found"</span>&#125;</code></pre><h1 id="Floyd-Warshall-Algorithm"><a href="#Floyd-Warshall-Algorithm" class="headerlink" title="Floyd-Warshall Algorithm"></a>Floyd-Warshall Algorithm</h1><p>上述算法都是单源最短路算法，即从给定一点到另一点或其余各点，如果要求从任意一点到其余各点的最短路呢？当然，我们可以对每一个点调用上述算法，但Floyd-Warshall算法更为简洁优雅。</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>和Bellman-Ford算法一样，Floyd-Warshall算法也是动态规划算法，只不过前者是与边相关，而后者与点相关。因此如果你理解了上一算法的动态规划思想，那么这一算法你也就能很快的理解了，我们在这里就不过多解释了。</p><p>定义：$f(i,j,k)$ = 从点$i$到点$j$中途最多经过了$1,…,k$这些点的最短路径长度</p><p>基准情况——不经过任何点：</p><script type="math/tex;mode=display">\begin{equation}f(i,j,0) =\left\{             \begin{array}{l}             0 &i=j \\             l(i,j) &(i,j) \in E\\             \infty, &otherwise             \end{array}\right.\end{equation}</script><p>由松弛操作，我们可以得出以下递推式：</p><script type="math/tex;mode=display">f(i,j,k) = \min \left\{f(i,j,k-1),f(i,k,k-1)+f(k,j,k-1)\right\}</script><p>由此我们便可以递推出从任意点$i$到任意点$j$的最短路径$f(i,j,k)$。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>算法的核心代码其实就五行，十分简洁，思想就是对任意两点尝试经过各个点松弛。</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>;j &lt;= n;j++)             dist[i,j] = min(dist[i, j], dist[i, k] + dist[k, j])&#125;&#125;</code></pre><h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><div class="table-container"><table><thead><tr><th>算法</th><th>用处</th></tr></thead><tbody><tr><td>BFS</td><td>无权图，1-&gt;all</td></tr><tr><td>Dijkstra’s Algorithm</td><td>有权图，无负权边，1-&gt;all</td></tr><tr><td>A* Algorithm</td><td>有权图，无负权边，1-&gt;1</td></tr><tr><td>Bellman-Ford Algorithm</td><td>有权图，无负权回路，1-&gt;all</td></tr><tr><td>Floyd-Warshall Algorithm</td><td>有权图，all-&gt;all</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Introduction to the A* Algorithm</a></li><li><a href="https://stackoverflow.com/questions/26137239/what-is-a-heuristic-function" target="_blank" rel="noopener">What is a Heuristic Function</a></li><li><a href="https://downey.io/notes/omscs/cs6515/dynamic-programming-shortests-paths/" target="_blank" rel="noopener">dynamic programming - bellman-ford algorithm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms and Data Structures</title>
    <link href="/Algorithms-and-Data-Structures.html"/>
    <url>/Algorithms-and-Data-Structures.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>算法和数据结构是程序的基石，几乎每一个程序都需要它们，但绝大多数程序都不需要发明新的算法和数据结构。</p><p>为了方便后面的讨论，我们先在这里给出HTML中<code>name-value</code>键值对的定义：<br><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> <span class="hljs-title">Nameval</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> &#123;</span>    <span class="hljs-keyword">char</span> *name;    <span class="hljs-keyword">int</span> value;&#125;;</code></pre></p><h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><p>这里我们讨论一个现被广泛使用的排序算法：快排（quicksort）。</p><h2 id="快排的递归实现"><a href="#快排的递归实现" class="headerlink" title="快排的递归实现"></a>快排的递归实现</h2><p>快排的核心思想就是分治，它每次选出一个枢轴点（pivot），然后将数组中比这一点值小的数放在它左边，比它大的数放在它右边，再递归处理左边的数组和右边的数组。由此我们可以轻松地写出以下优雅的递归代码（枢轴点随机）：<br><pre><code class="hljs c"><span class="hljs-comment">/* swap - swap arr[i] and arr[j] */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp;    temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;<span class="hljs-comment">/* quicksort - sort the array into increasing order recursively */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n_arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (n_arr &lt;= <span class="hljs-number">1</span>)    <span class="hljs-comment">/* if array size &lt; 1, then no need for sorting */</span>        <span class="hljs-keyword">return</span>;    swap(arr, <span class="hljs-number">0</span>, rand() % n_arr); <span class="hljs-comment">/* generate pivot and move it to v[0] */</span>    <span class="hljs-comment">/* move the elements smaller than pivot */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n_arr; ++i) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[<span class="hljs-number">0</span>])            swap(arr, ++last, i);    &#125;    <span class="hljs-comment">/* restore povit */</span>    swap(arr, <span class="hljs-number">0</span>, last);    <span class="hljs-comment">/* recursively sort each part */</span>    quicksort(arr, last);    quicksort(arr + last + <span class="hljs-number">1</span>, n_arr - last - <span class="hljs-number">1</span>);&#125;</code></pre></p><h2 id="快排的迭代实现"><a href="#快排的迭代实现" class="headerlink" title="快排的迭代实现"></a>快排的迭代实现</h2><p>快排一般都是用递归形式写的，那么它如何用迭代的方式来写呢？</p><p>对于可以用分治解决的问题，我们一般都可以用辅助栈来将递归转换为迭代。这里我使用C++来实现，这样可以让我们更专注于算法思想而非语言的细枝末节。<br><pre><code class="hljs cpp"><span class="hljs-comment">// keep the range being sorted</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SortRange</span> &#123;</span>    <span class="hljs-comment">// constructor</span>    SortRange(<span class="hljs-keyword">size_t</span> s, <span class="hljs-keyword">size_t</span> e) : start(s), end(e) &#123;&#125;    <span class="hljs-keyword">size_t</span> start;    <span class="hljs-keyword">size_t</span> end;  <span class="hljs-comment">// exclude index end</span>&#125;;<span class="hljs-comment">// quicksort_iter - sort the array into increasing order iteratively</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort_iter</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;    <span class="hljs-built_in">stack</span>&lt;SortRange&gt; helper;    <span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-literal">nullptr</span>))</span></span>;    helper.push(&#123;<span class="hljs-number">0</span>, arr.size()&#125;);    <span class="hljs-comment">// sort until the stack is empty</span>    <span class="hljs-keyword">while</span> (!helper.empty()) &#123;        <span class="hljs-keyword">size_t</span> last, start, end;        start = helper.top().start;        end = helper.top().end;        last = start;        <span class="hljs-comment">// generate uniform distribution random numbers from [start, end-1]</span>        <span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-keyword">size_t</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(start, end - <span class="hljs-number">1</span>)</span></span>;        helper.pop();        <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">// if array size &lt;= 1, no need for sorting</span>            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// generate pivot and move it to arr[start]</span>        swap(arr[start], arr[u(e)]);        <span class="hljs-comment">// move the elements smaller than pivot</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = start + <span class="hljs-number">1</span>; i != end; ++i)            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[start])                swap(arr[++last], arr[i]);        <span class="hljs-comment">// restore pivot</span>        swap(arr[start], arr[last]);        <span class="hljs-comment">// put each part into stack for next loop</span>        helper.push(&#123;start, last&#125;);        helper.push(&#123;last + <span class="hljs-number">1</span>, end&#125;);    &#125;&#125;</code></pre><br>那么是不是我们应该避免用递归实现快排呢？毕竟“迭代快于递归”嘛。其实，快排可以说是递归优于迭代的典例了，既优雅又高效，可以放心地用递归版本。两者效率的讨论详见：<a href="https://stackoverflow.com/questions/12553238/quicksort-iterative-or-recursive" target="_blank" rel="noopener">Quicksort:Iterative or Recursive</a></p><h2 id="快排的性能"><a href="#快排的性能" class="headerlink" title="快排的性能"></a>快排的性能</h2><p>显然快排是效率较高的排序算法，因为它不需要接连地与每一个其他数组元素比较，而每次只需与枢轴点的值比较，比它小就放左边，比它大就放右边。这一点就使得快排优于插入排序和冒泡排序。</p><p>若每轮都能较为平均地分为两部分，那么当整个数组共有n个元素时，n + 2 <em>n / 2 + 3 </em>n / 3 + ……共有logn轮，因此时间复杂度为O(nlogn)。但现实中是会有一些特殊的输入序列会使快排的划分完全不均匀，致使较差的性能表现，主要有以下三种：</p><ol><li>已经接近顺序</li><li>已经接近逆序</li><li>所有元素都相等（其实是前两种的特殊情况）</li></ol><p>在这些时候，若枢轴点选择不当，可以达到最差时间复杂度O(n<sup>2</sup>)。</p><h1 id="Growing-Arrays"><a href="#Growing-Arrays" class="headerlink" title="Growing Arrays"></a>Growing Arrays</h1><p>这一节主要是讨论如何用C实现一个动态数组（类似C++中的vector），相比于实现的算法思路，我认为书中的一个设计细节更为引人注目。</p><p>当数组元素的个数要超出现有已分配的数组大小时，我们需要再分配更多的内存来容纳元素，在C语言中也就需要<code>realloc</code>函数。若实现动态数组的数据结构如下：<br><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NVtab</span> &#123;</span>    <span class="hljs-keyword">int</span> nval;   <span class="hljs-comment">/* current number of values */</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">/* allocated number of values */</span>    Nameval *nameval;    <span class="hljs-comment">/* array of name-value pairs */</span>&#125;nvtab;</code></pre><br>那么在增添数组元素的函数中，我们很可能写出这样的代码：<br><pre><code class="hljs c">...<span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    nvtab.nameval = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    ...&#125;</code></pre><br>当分配内存成功时，这段代码是没问题的。但如果分配失败的话，<code>nvtab.namval</code>所指向的数组就会丢失了。因此，我们应该用一个局部变量来暂存分配的结果，若分配成功了，再由<code>nvtab.nameval</code>接管分配好的数组。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    Nameval *tmp = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    nvtab.nameval = tmp;    ...&#125;</code></pre></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><blockquote><p><strong>Exercise 2-8.</strong> Write recursive and iterative versions of <code>reverse</code>, which reverses a list. Do not create new list items; re-use the existing ones.</p></blockquote><p>这是一个很典型的数据结构题。我们在稍加思索后可以很容易地想出迭代的解法：遍历链表，将每一个节点指向它的前一个节点，第一个节点指向<code>NULL</code>。转换为代码：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_iter - reverse the whole list iteratively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_iter</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *next;    Nameval *prev = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> (listp != <span class="hljs-literal">NULL</span>) &#123;        next = listp-&gt;next;        listp-&gt;next = prev;        prev = listp;        listp = next;    &#125;    <span class="hljs-keyword">return</span> prev; &#125;</code></pre><br>那么如何递归地求解呢？写递归，最关键就是要牢记两条基本准则：</p><blockquote><ol><li><strong>基准情形</strong>。必须要有某些基准情形，它无须递归就能解出。</li><li><strong>不断推进</strong>。对于需要递归求解的情形，每一次递归调用都必须朝着接近基准情形的方向推进。</li></ol><p>摘录自《数据结构与算法分析——C语言描述》</p></blockquote><p>在这一道题目中，基准情况就是链表的第一个节点和最后一个节点。</p><ol><li>若链表为空，则返回空。</li><li>若链表只有一个节点或到达了最后一个节点，这个节点就是头结点，它应指向前一个节点或<code>NULL</code>。</li></ol><p>链表是单向的，它无法在顺序遍历时不记住前一个节点的情况下，指向前一个节点，因此我们应该在递归回溯时从后往前修改指针以达到指向前一个节点的目的。如：<br><pre><code class="hljs c">node-&gt;next-&gt;next = node;</code></pre><br>这样便实现了让后一个节点指向前一个节点。</p><p>综上，我们便可以写出递归的解法：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_recur_helper - help to reverse the list recursively and get the head node */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse_recur_helper</span><span class="hljs-params">(Nameval *listp, Nameval **head)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (listp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (listp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;        *head = listp;        <span class="hljs-keyword">return</span>;    &#125;    reverse_recur_helper(listp-&gt;next, head);    listp-&gt;next-&gt;next = listp;    listp-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">/* reverse_recur - reverse the list recursively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_recur</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *head;    reverse_recur_helper(listp, &amp;head);    <span class="hljs-keyword">return</span> head;&#125;</code></pre></p><h1 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h1><p>在实现哈希表的查找时，我们很容易想到这样实现：<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><br>但这样的实现会使得如下的操作进行两次<code>hash</code>计算：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (lookup(<span class="hljs-string">"name"</span>) == <span class="hljs-literal">NULL</span>)    additem(newitem(<span class="hljs-string">"name"</span>, value));</code></pre><br>因此，将查找和插入选项结合起来是一个更好的选择。<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> create, <span class="hljs-keyword">int</span> value)</span></span>;</code></pre></p><h1 id="将整型转换为字符串"><a href="#将整型转换为字符串" class="headerlink" title="将整型转换为字符串"></a>将整型转换为字符串</h1><p>在创建HTML<code>name-value</code>键值对时，为了方便，我想将<code>name</code>直接表示为<code>value</code>的字符串形式。在C++中，这是十分容易实现的：<br><pre><code class="hljs cpp">name = to_string(value);</code></pre><br>在C语言当中，我以前一直都是使用<code>itoa</code>函数的，但最近才发现该函数并不属于C语言标准，标准的写法应为：<br><pre><code class="hljs c"><span class="hljs-comment">/* to_string - convert an int to string */</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">char</span> *buf;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;    <span class="hljs-built_in">size</span> = <span class="hljs-built_in">snprintf</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"%d"</span>, value);  <span class="hljs-comment">/* get length of string */</span>    buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">/* allocate one character more for null-terminator */</span>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>, <span class="hljs-string">"%d"</span>, value);    <span class="hljs-keyword">return</span> buf;&#125;name = to_string(value);</code></pre></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bamsoftware.com/computers/tpop-answers.html" target="_blank" rel="noopener">Answers to the exercises in tpop</a></li><li><a href="https://www.youtube.com/watch?reload=9&amp;v=MRe3UsRadKw" target="_blank" rel="noopener">Reverse a Linked List Recursively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style</title>
    <link href="/Style.html"/>
    <url>/Style.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>代码风格是十分重要的，一个好的代码风格可以帮助读者更好地理解代码，也能帮助自己在写程序时及时排错。</p><h1 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h1><blockquote><p>Use descriptive names for globals, short names for locals.</p></blockquote><p>学习第一门程序语言时，我们总被教导道：要使用足够长的变量命名，这样读者才好理解这个变量的用途。其实这样是不对的。</p><p>全局变量的名字是需要足够长、足够具体的，因为他们可能出现在程序的各个地方，这样的名字可以帮助作者和读者回想起这个变量的用途。而局部变量简短些即可，比如要表示学生的人数，<code>n</code>也许就够了，<code>n_stu</code>也不错，但是<code>number_of_stu</code>就没必要，会显得代码冗长。</p><blockquote><p>Use active names for functions.</p></blockquote><p>函数名应该是动态的。比如要打印数组，<code>print_arr</code>就很好，而单独一个<code>arr</code>就让人不知道该函数的用途。名字中的动词也需要足够直白，比如返回布尔值的函数，<code>check_even</code>是模棱两可的，因为它并没有说明如果是偶数返回真还是假，而<code>is_even</code>就让人清楚地知道如果是偶数，该函数返回真。</p><h1 id="Expressions-and-Statements"><a href="#Expressions-and-Statements" class="headerlink" title="Expressions and Statements"></a>Expressions and Statements</h1><blockquote><p>Parenthesize to reslove ambiguity.</p></blockquote><p>括号可以清晰的划分结构与优先级，即使不需要的时候我们也可以加上以避免不必要的错误和增加可读性。</p><p>比如<code>if (x&amp;MASK == BITS)</code>，显然其本意是想判断<code>x</code>和掩码进行与运算后是否等于<code>BITS</code>，但由于位操作符的优先级低于等于号，这段代码实际上等价于<code>if (x &amp; (MASK == BITS))</code>，这也就发生了意料之外的错误，因此这个表达式需要加上括号，即<code>if ((x&amp;MASK) == BITS)</code>。</p><p>又如这样一个表达式：<br><pre><code class="hljs c">leap_year = y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != || y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;</code></pre><br>这当然是没错的，但第一眼看去，我们难以把握结构，若按如下修改会清晰得多：<br><pre><code class="hljs c">leap_year = ((y%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (y%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (y%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>));</code></pre><br>注意到，我们移去了一些空格，使高优先级的操作符更紧凑，这样可以帮助读者更快地把握结构。</p><blockquote><p>Be careful with side effects.</p></blockquote><p>不了解序列点(sequence point)、副作用(side effect)和未定义行为(undefined behavior)的朋友可先参见：<a href="https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points" target="_blank" rel="noopener">Undefined behavior and sequence points</a></p><p>在C和C++中，一个序列点前副作用的执行顺序是未定义的。如：<br><pre><code class="hljs c">str[i++] = str[i++] = <span class="hljs-string">' '</span>;</code></pre><br>在这里，<code>;</code>就是一个序列点，而我们知道，<code>++</code>操作符是有副作用的，它不仅返回一个值，还会修改该变量的值。所以在这一语句中对同一个变量多次<code>++</code>操作导致了未定义行为。因为虽然我们心里想的是<code>i</code>增加两次，但编译器不知道到底<code>i</code>是增加一次还是两次，也不知道是左边的<code>i</code>是使用右边的<code>i</code>递增后的值还是原来的值，这就导致了<code>warning: multiple unsequenced modification to i</code>。</p><p>再看一个我从书本Exercise 1-5改编的例子，以下代码片段有什么问题呢？<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ip)</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, ip);    <span class="hljs-keyword">return</span> *ip;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, a, b); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">read</span>(&amp;a), <span class="hljs-built_in">read</span>(&amp;b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><br>我们可以先看看当输入为<code>2 3</code>时，不同编译器下的输出结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">编译器</th><th style="text-align:left">输出结果</th></tr></thead><tbody><tr><td style="text-align:left">gcc</td><td style="text-align:left">3 2</td></tr><tr><td style="text-align:left">clang</td><td style="text-align:left">2 3</td></tr></tbody></table></div><p><code>scanf</code>函数不是分别运行的吗？为什么会产生这样的奇怪的结果呢？原因是<em>函数调用计算完所有参数后且执行被调用函数前</em>也是一个序列点，而我们这里的函数参数计算里含有I/O操作，I/O操作也有副作用，所以这里函数参数的计算顺序也是未定义的，因此如果先计算第一个参数，那么<code>2</code>就会被写入参数<code>a</code>中，<code>3</code>就会被写入<code>b</code>中，输出结果同clang；但如果先计算第二个参数，<code>2</code>和<code>3</code>就会被分别写入<code>b</code>和<code>a</code>中，输出结果同gcc。</p><h1 id="Consistency-and-Idioms"><a href="#Consistency-and-Idioms" class="headerlink" title="Consistency and Idioms"></a>Consistency and Idioms</h1><p>在这一节中，基本都是熟知的准则，不再赘述。但下面这个代码示例告诉了我们一种优雅处理嵌套的<code>if else</code>错误判断语句的方式。</p><p>我们很可能写出类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>)     <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)                putc(c,fout);            fclose(fin);            fclose(fout);        &#125; <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);</code></pre></p><p>使用递进的<code>if</code>判断，最终是前期准备无错误的处理代码，然后再用多个<code>else</code>分别处理各种错误情况。这段代码并不优雅，并且有资源泄露的可能——如果<code>fout</code>打开文件失败，那么<code>fin</code>打开的文件就不会显式关闭，未显式关闭文件可能导致的问题可参见：<a href="https://www.quora.com/Why-do-we-need-to-close-files-in-programming-after-performing-a-read-or-write-operation" target="_blank" rel="noopener">Why do we need to close files?</a><br>那么如何改进呢？我们可以使用<code>if, else if</code>来推进，先处理错误情况，最终才是正常情况下的代码。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    fclose(fin); <span class="hljs-comment">/* release the resource fin occupied */</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)        putc(c,fout);    fclose(fin);    fclose(fout);&#125;</code></pre></p><h1 id="Function-Macros"><a href="#Function-Macros" class="headerlink" title="Function Macros"></a>Function Macros</h1><blockquote><p>Avoid function macros.</p></blockquote><p>宏是进行文本的替换，因此如果函数宏定义中参数出现了多次，那么它就会被计算多次，这在大多数时候都不是我们想要的。如：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isupper(c) ((c) &gt;= <span class="hljs-meta-string">'A'</span> &amp;&amp; (c) &lt;= <span class="hljs-meta-string">'Z'</span>)</span>...<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(c = getchar()))    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c is uppercase\n"</span>, c);</code></pre><br>那么实际<code>if</code>的判断语句等价于<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (((c = getchar()) &gt;= <span class="hljs-string">'A'</span> &amp;&amp; (c = getchar()) &lt;= <span class="hljs-string">'Z'</span>))</code></pre><br>这显然是错误的，假定我们输入一个字符然后回车，那么只要这个字符的ASCII码值大于等于A的码值就会有输出，因为逻辑与表达式的第二部分程序又读了一个字符，这个字符就是留在缓冲区的<code>\n</code>字符，其ASCII码值为<code>0xa</code>，小于<code>Z</code>的码值。</p><p>很多人习惯使用宏来管理幻数/魔数(Magic Numbers)，其实尽量不要用C预处理器来做这件事，让语言本身来处理是更好的。在C++中可以用<code>const</code>来声明常量：<br><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ARR_SIZE = <span class="hljs-number">5</span>;</code></pre><br>C中当然也有<code>const</code>，值得注意的是，用<code>const</code>修饰的值是无法作为<code>静态数组</code>的边界的（因为这是<code>运行时常量</code>），但<code>enum</code>可以实现这一点：<br><pre><code class="hljs c"><span class="hljs-keyword">enum</span> &#123;ARR_SIZE = <span class="hljs-number">5</span>&#125;;</code></pre></p><p>那这是不是意味着我们永远不能使用宏呢？并不是，我们应该让宏做函数做不了的事情。典型的例子就是仅由声明计算数组的长度：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NELEMS(array) (sizeof(array) / sizeof(array[0]))</span></code></pre><br>在这里，<code>sizeof(array)</code>计算的就是数组本身的长度，而在函数中，数组参数退化为指针，<code>sizeof(array)</code>就只能计算出指针的大小了。对数组和指针关系不太明确的朋友可参考：<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">is an array name a pointer?</a></p><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><blockquote><p>Comment functions and global data.</p></blockquote><p>给每个函数和全局变量写适当的注释是一个好习惯。在我接触的好的代码风格中，也有的还在文件开头写一个文件的注释，告诉读者这一个文件的主要用途以及注意事项等，个人认为这也值得学习。</p><blockquote><p>Don’t comment bad code, rewrite it.</p></blockquote><p>这一准则给出了一个有意思的判断，即当注释的字数多过于要注释的代码段时，这段代码可能就是<code>bad code</code>。这时应该看看是否需要改善代码而不是坚持注释。</p><p>至此，第一章就结束了，希望我们都能形成一个好的代码风格。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int ch = getchar()?</title>
    <link href="/int-ch-getchar.html"/>
    <url>/int-ch-getchar.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>也许你看过/写过类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这段代码看起来没什么问题，但实际上代码中的循环有可能永不终止，也有可能提前结束。</p><h1 id="函数与EOF介绍"><a href="#函数与EOF介绍" class="headerlink" title="函数与EOF介绍"></a>函数与EOF介绍</h1><p>在解释之前，我们先了解下相关内容。C语言常用的字符读取函数如下：<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getchar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre><br>这三个函数都是从文件流中读取一个字符，正常情况下把该字符从<code>unsigned char</code>转换为<code>int</code>类型返回，若出错或读到文件结尾则返回<code>EOF</code>。</p><p><code>EOF</code>又是什么呢？<code>EOF</code>只是一个宏定义的负整数而已，一般为<code>-1</code>(hex:0xffffffff)。</p><p>由于上述函数区别不大，此文便只用最常见的<code>getchar</code>函数来讨论。</p><h1 id="char-ch-getchar-错在哪里？"><a href="#char-ch-getchar-错在哪里？" class="headerlink" title="char ch = getchar()错在哪里？"></a>char ch = getchar()错在哪里？</h1><p>看到这，你可能会说：既然<code>EOF</code>只是值为<code>-1</code>的负整数，这不是在<code>char</code>的表示范围-128~127内吗？用<code>char</code>保存返回值有何不可？</p><p><code>-1</code>真的一定在<code>char</code>的表示范围内吗？我们可以在头文件<code>limits.h</code>中看到如下定义：<br><pre><code class="hljs c"><span class="hljs-comment">/* Minimum and maximum values a `signed char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MIN(-128)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MAX127</span><span class="hljs-comment">/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UCHAR_MAX255</span><span class="hljs-comment">/* Minimum and maximum values a `char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CHAR_UNSIGNED__</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MIN0</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXUCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MINSCHAR_MIN</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXSCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br>由此可见，标准并未规定<code>char</code>是有符号的，而是留给各个编译器自己实现。</p><p>所以当<code>char</code>默认为无符号时，<code>-1</code>就不在其表示范围内，这时使用<code>char</code>保存返回值也就有问题了。实际上即使你所用的编译器默认定义<code>char</code>是有符号的，文章开头的那段代码依然有潜在的bug。下面我们分为<code>char</code>默认无符号和有符号两种情况讨论，利用计算机组成原理的知识来详细解释为什么不应该用<code>char</code>保存<code>getchar</code>的返回值。</p><h2 id="1-char默认是无符号的"><a href="#1-char默认是无符号的" class="headerlink" title="1. char默认是无符号的"></a>1. char默认是无符号的</h2><p><strong>这种情况会导致循环无法终止。</strong>假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，这时由于<code>ch</code>是<code>char</code>类型，只有一个字节，而<code>EOF</code>是<code>int</code>类型，有四个字节却要保存在一个字节中，<code>EOF</code>的值会被截断，<code>ch</code>也就等于<code>0xff</code>，又因为<code>ch</code>要与<code>EOF</code>比较，<code>ch</code>符号扩展得<code>0x000000ff</code>（因为<code>ch</code>是无符号的，也就是0扩展），永远不可能等于<code>EOF</code>，循环也就永远不会终止。</p><h2 id="2-char默认是有符号的"><a href="#2-char默认是有符号的" class="headerlink" title="2. char默认是有符号的"></a>2. char默认是有符号的</h2><p><strong>这种情况可能导致循环提前终止。</strong>同样假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，前面都一样，但是在符号扩展的时候，由于<code>ch</code>是有符号的，其扩展得<code>0xffffffff</code>，等于<code>EOF</code>。因此循环是可以终止的，但是如果我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，循环就会同碰到<code>EOF</code>一样终止。</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>那么如何修改代码才是正确的呢？其实只需要用<code>int</code>来保存返回值即可。<br><pre><code class="hljs c"><span class="hljs-keyword">int</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这种情况就不会有问题。即使我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，由于<code>ch</code>是<code>int</code>类型，而<code>getchar</code>是将读到的字符由<code>unsigned char</code>转为<code>int</code>作返回值，则该字节的值经符号扩展再赋值给<code>ch</code>，<code>ch</code>就等于<code>0x000000ff</code>，不会等于<code>EOF</code>，也就不会提前终止了。</p><p>综上，这就是为什么要用<code>int</code>类型而不是<code>char</code>类型来保存C语言字符读取函数的返回值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default" target="_blank" rel="noopener">is char signed or unsigned by default?</a></li><li><a href="https://stackoverflow.com/questions/13694394/while-c-getcfile-eof-loop-wont-stop-executing" target="_blank" rel="noopener">why the loop won’t stop executing?</a></li><li><a href="https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284351&amp;answer=1048865140" target="_blank" rel="noopener">Definition of EOF and how to use it effectively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
