<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k-means聚类</title>
    <link href="/k-means%E8%81%9A%E7%B1%BB.html"/>
    <url>/k-means%E8%81%9A%E7%B1%BB.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>聚类应用于生活的方方面面，如人脸识别，每一个人就是一个类，将数据库中的照片与现拍的照片进行特征值的比较后划分到一个类中（即确定一个人）；又如疫情健康码，有绿码、黄码和红码三个类，根据人的居住地、最近去向、接触人群等属性将其划分到一个类中（即分配一个健康码）。</p><p>聚类问题可以描述如下：假设有$n$个无标记样本</p><script type="math/tex;mode=display">D = \{x_1,x_2,...,x_n\}</script><p>任一样本为$d$维向量</p><script type="math/tex;mode=display">x_i = \{x_{i1},x_{i2}, ..., x_{id}\}^T</script><p>将其按照某种<strong>相似性准则</strong>划分为若干个互不相交 的子集。</p><p>k-means聚类就是指定$k$，将其划分为$k$个互不相交的子集。</p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><h2 id="简单的想法"><a href="#简单的想法" class="headerlink" title="简单的想法"></a>简单的想法</h2><p>k-means聚类的<strong>相似性准则</strong>为样本间的<strong>欧式距离</strong>，将离得近的样本看作一个类，离得远的看作不同类。</p><p>因此，对于一个划分</p><script type="math/tex;mode=display">C=\{C_1,C_2,...,C_k\}</script><p>要使其最优，所有类样本到各自类中心的距离之和就应该最小。</p><p>对于类$C_i$，其类中心为</p><script type="math/tex;mode=display">M_i=\frac{1}{|c_i|}\sum_{x \in C_i}x, 1 \leq i \leq k</script><p>即类中心是该类所有类样本和的平均值，则该类所有类样本到类中心的距离之和为</p><script type="math/tex;mode=display">\sum_{x \in C_i}\|x-M_i\Vert</script><p>将$k$个类累加起来，就可以得到所有类样本到各自类中心的距离之和为</p><script type="math/tex;mode=display">\sum_{i=1}^k\sum_{x \in C_i}\|x-M_i\Vert</script><p>那么，我们的模型就可以写出来了：</p><script type="math/tex;mode=display">\begin{aligned}min \sum_{i=1}^k\sum_{x \in C_i} \|x-M_i\Vert^2 \\\begin{equation}s.t. \left\{\begin{array}{l}\cup_{i=1}^k C_i = D \\C_i \cap C_j = \varnothing \\i,j \in {1, 2, ..., k} \\i \neq j\end{array} \right.\end{equation}\end{aligned}</script><p>注意，我们这里目标函数写成平方是为了求解方便，若不加平方，求距离就会带开方，计算不便。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面的模型有一个明显的缺陷：只考虑了同类的聚集，却没有考虑不同类的分散。</p><p>因此我们可以添加一个目标加以优化：让不同类间的类中点距离之和最大。那么我们就可以得出以下目标函数：</p><script type="math/tex;mode=display">max \sum_{1 \leq i \lt j \leq k} \|M_i-M_j\Vert^2</script><p>模型也就变成了多目标优化模型。为了求解的简便，我们先利用倒数将第二个目标函数转为求最小值，然后采用线性加权法将多目标转为单目标，得以下目标函数：</p><script type="math/tex;mode=display">min \sum_{i=1}^k\sum_{x \in C_i}\|x-M_i\Vert^2 + \sum_{1 \leq i \lt j \leq k} \frac{1}{\|M_i-M_j\Vert^2}</script><p>至此，我们得到了优化后的k-means聚类模型。</p><h2 id="相似性准则"><a href="#相似性准则" class="headerlink" title="相似性准则"></a>相似性准则</h2><p>如前所述，k-means聚类使用欧式距离作为相似性准则，这其实只适用于圆形或椭圆形聚集的数据聚类，如下图所示。</p><p><img src="img/posts/聚类1.png" srcset="/img/loading.gif" alt=""></p><p>而无法对其他多样分类需求的数据进行聚类，如下图，以欧式距离作为相似性准则是无法做到下图这样的分类的。</p><p><img src="posts/聚类2.png" srcset="/img/loading.gif" alt=""></p><p>因此，相似性准则并不是普适的，而是各有专攻。如今，人们已经提出了种类繁多的相似性准则，适用于不同的应用场景，若有兴趣，可以去查询相关资料。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2: Stacks and Queues &amp; Elementary Sorts</title>
    <link href="/week2-Stacks-and-Queues-Elementary-Sorts.html"/>
    <url>/week2-Stacks-and-Queues-Elementary-Sorts.html</url>
    
    <content type="html"><![CDATA[<h1 id="泛型与可迭代的数据结构"><a href="#泛型与可迭代的数据结构" class="headerlink" title="泛型与可迭代的数据结构"></a>泛型与可迭代的数据结构</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在java中实现泛型十分简单，只需定义类时在类名后加上<code>&lt;类型名&gt;</code>，然后在类中用到此类型数据时通通使用<code>类型名</code>修饰即可。如</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Item[] s;    ...&#125;</code></pre><h2 id="可迭代"><a href="#可迭代" class="headerlink" title="可迭代"></a>可迭代</h2><p>若想自定义的数据结构是可迭代的，那么就需要实现<code>Iterable</code>接口，重写<code>iterator()</code>方法，其会返回一个迭代器，定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">// Iterable interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function">Iterator&lt;Item&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>当然，我们需要自己定义这个迭代器是如何遍历我们所写的数据结构的。java提供了<code>Iterator</code>接口，我们实现它即可。</p><pre><code class="hljs java"><span class="hljs-comment">// Iterator interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Item <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// optional; use at your own risk</span>&#125;</code></pre><p>在client程序中，可以使用范围for循环来进行迭代遍历：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : stack)    StdOut.println(s);</code></pre><p>其等价于：</p><pre><code class="hljs java">Iterator&lt;String&gt; i = stack.iterator();<span class="hljs-keyword">while</span> (i.hasNext()) &#123;    String s = i.next();    StdOut.println(s);&#125;</code></pre><h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><h2 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h2><p>我们的排序方法在不知道传入的数据类型是什么时，是如何在排序中比较各个元素的呢？使用回调函数。</p><p>客户程序传入需要排序的数组，我们的排序方法在比较元素时会调用该元素对象的<code>compareTo()</code>方法来完成比较。</p><p>即对于一个以比较元素为基础的排序方法而言，传进来的对象需自己是<code>可比较的（Comparable）</code>，在java中就是需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。</p><pre><code class="hljs java"><span class="hljs-comment">// Comparable interface, built in to java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Item that)</span></span>;&#125;</code></pre><p>然后我们的排序方法将传进来的数组当成可比较对象的数组即可，如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span> </span>&#123;    ...&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>在这几个基础排序算法中，我们着重讨论下插入排序。</p><p>插入排序是时间复杂度为O($n^2$)、稳定（stable）且原地（in place）的排序算法，它在<strong>数组接近有序</strong>和<strong>数组较小</strong>时常被选用来排序。为什么呢？</p><ol><li>数组接近有序。插入排序是每次将当前元素与前面的元素一一比较，直到找到小于等于它的元素就在该位置插入。若数组接近有序，那么插入排序比较和交换的次数就很少，能在O(n)的时间内完成。</li><li>数组较小。当数组较小时，插入排序是很快的，因为它是原地的（in place），没有较多的开销。此时它常用来代替归并排序（merge sort）和快速排序（quick sort），因为这两个排序的递归调用对带来额外的栈开销。</li></ol><h1 id="Assignment-Deques-and-Randomized-Queues"><a href="#Assignment-Deques-and-Randomized-Queues" class="headerlink" title="Assignment: Deques and Randomized Queues"></a>Assignment: Deques and Randomized Queues</h1><p>代码见<a href="https://github.com/seineo/Algorithms/blob/master/Part1/week2/README.md" target="_blank" rel="noopener">这里</a>。在这主要说明下完成作业的几个关键点：</p><ol><li><strong>loitering</strong>。在链表实现deque的过程中，由于有<code>next</code>和<code>prev</code>两个引用，稍有不慎就会出现loitering。以<code>addFirst</code>函数为例，添加一个新的first节点后，如果仅仅设置了该节点的<code>next</code>和<code>prev</code>引用，是会出现loitering的。若链表不止有这一个新增的节点，那么原来的first节点的<code>prev</code>应该指向它，即<code>oldFirst.prev = first</code>。</li><li><strong>随机队列的<code>dequeue</code>函数</strong>。由于随机队列是随机删除一个元素，若用数组实现，那一下标直接就空了，如果置之不理，仍然是在后面入列，则出列操作不好实现。为了解决这一问题，我们可以交换删除元素位置的值和队尾元素的值。</li><li><strong>bonus</strong>：bonus的问题我也不会，是在论坛上了解到的方法——水塘抽样。水塘抽样是一种统计的随机算法，在这里不作探讨，不了解的朋友可以参见：<a href="https://blog.csdn.net/javastart/article/details/50610868" target="_blank" rel="noopener">Reservoir sampling（水塘抽样）</a>。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/736920/is-there-ever-a-good-reason-to-use-insertion-sort" target="_blank" rel="noopener">Is there ever a good reason to use Insertion Sort?</a></li><li><a href="https://stackoverflow.com/questions/8101546/why-is-insertion-sort-better-than-quick-sort-for-small-list-of-elements" target="_blank" rel="noopener">Why is Insertion sort better than Quick sort for small list of elements?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旅行商问题与最可靠路径问题</title>
    <link href="/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E5%8F%AF%E9%9D%A0%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html"/>
    <url>/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E5%8F%AF%E9%9D%A0%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol><li>旅行商问题（TSP）：从一点出发遍历其余点各一次再回到该点，要求总路径最短。</li><li>最可靠路径问题：图中的任一条边都有其可靠的概率，求任意两点间的最可靠路径。</li></ol><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><p>若图中有$n$个点，我们可将它们编号为$0,…,n-1$（<strong>本文讨论都默认0为起点</strong>）,构造对应的邻接矩阵c<sub>nxn</sub>，令x<sub>nxn</sub>为0-1矩阵，若x<sub>ij</sub>为1，则点$i$到点$j$属于当前选择路径的一部分，反之不属于。那么我们就可以很容易写出如下目标函数</p><script type="math/tex;mode=display">min \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}x_{ij}</script><p>显然，在此题中一条合法的路径应该是类似下方这样的回路。</p><p><img src="img/posts/tsp1.png" srcset="/img/loading.gif" alt=""></p><p>这样的一条回路，其中各点的入度、出度都应为0。所以我们可以写出以下两条约束条件</p><script type="math/tex;mode=display">\begin{equation}s.t. \left\{\begin{aligned}\sum_{i=1}^{n}x_{ij} = 1, j = 1,...,n \\\sum_{j=1}^{n}x_{ij} = 1, i = 1,...,n \end{aligned} \right.\end{equation}</script><p>但是仅仅满足这两个条件的路径可能并不是合法路径，因为它可能是多条回路的并集而非一个回路。如下图所示。</p><p><img src="img/posts/tsp2.png" srcset="/img/loading.gif" alt=""></p><p>因此我们还需要第三个约束条件</p><script type="math/tex;mode=display">u_i - u_j + nx_{ij} \leq n - 1， 1< i \neq j < n</script><p>其中$u_i$表示编号为$i$的点在当前选择路径的序号（该点为<strong>非起点</strong>，在本文中即非0）。加上这一约束条件，我们就可以确定合法路径，证明如下。</p><h3 id="约束三的证明"><a href="#约束三的证明" class="headerlink" title="约束三的证明"></a>约束三的证明</h3><ol><li><p>必要条件</p><p><img src="img/posts/tsp3.png" srcset="/img/loading.gif" alt=""></p></li></ol><p><strong>（注意：起点0并没有对应的$u$值，它不参与计算。）</strong></p><p>对于一条合法路径，根据$x_{ij}$的取值，我们有两种情况要讨论</p><ul><li>若$x_{ij}=1$，即点$i$与点$j$相邻，则$|u_i-u_j| \leq 1$，所以$u_i-u_j+n \times 1 \leq n-1$，成立。</li><li>若$x_{ij}=0$，即点$i$与点$j$不相邻，而$max \space u_i=n$，$min \space u_j = 2$，那么$max \space (u_i-u_j) + n \times 0=n-2 &lt; n-1$，也成立。</li></ul><p>因此，加上约束三后的约束条件是确定合法路径的必要条件。</p><ol><li>充分条件</li></ol><p><img src="img/posts/tsp4.png" srcset="/img/loading.gif" alt=""></p><p>我们使用反证法。满足前两个约束的非法路径肯定是多条回路的并集，我们选择<strong>不包含起点的某个回路</strong>来讨论。比如我们选中上图的右回路，我们假定其中各点对应$u$值如图所示（其实对应$u$值具体为多少并不重要，只要是连续的即可）。我们可以写出以下式子：</p><script type="math/tex;mode=display">\begin{aligned}\left\{\begin{aligned}u_2 - u_3 + n \times 1 \leq n - 1 \\u_3 - u_4 + n \times 1 \leq n - 1 \\ u_4 - u_2 + n \times 1 \leq n - 1\end{aligned} \right.\end{aligned}</script><p>全部式子加和，可得</p><script type="math/tex;mode=display">k \times n \leq k \times (n - 1)</script><p>显然，该式不成立。因此，加上约束三后的约束条件是确定合法路径的充分条件。</p><p>综上，加上约束三后的约束条件是确定合法路径的充分必要条件。</p><h2 id="最可靠路径问题"><a href="#最可靠路径问题" class="headerlink" title="最可靠路径问题"></a>最可靠路径问题</h2><p>对一个图G&lt; V, E &gt;，其任意一条边$e_i \in E$都有其可靠的概率$p_i$，任意两点的最可靠路径我们的目标函数大致可以写成</p><script type="math/tex;mode=display">max \sum p_i</script><p>这个最大值其实并不好求，我们可以将其转化为最短路径问题。</p><p>令各边长为$l_i = log_2 \frac{1}{p_i}$，$p_i$越大，$\frac{1}{p_i}$就越小，由于$log$函数是单调递增的函数，那么$l_i$也就越小。</p><p>即，我们的目标函数变为</p><script type="math/tex;mode=display">\begin{aligned}max \sum p_i &= min \space log_2\frac{1}{p_i} \\             &= min \space -log_2p_i\end{aligned}</script><p>这就完成了从最可靠路径问题到最短路径问题的转化。求解最短路径的方法多样，就不在此多加探讨了。</p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元线性回归</title>
    <link href="/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html"/>
    <url>/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我们使用$n$个属性描述事物$y$，已测得$m$组属性值</p><script type="math/tex;mode=display">\begin{equation}x_{k}=(x_{1k},x_{2k},...,x_{nk})^T\end{equation}, k = 1,...,m</script><p>和其对应$m$个$Y$值，试构造函数$y=f(x)$以解释、预测该事物的变化。</p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><p>显然，对于每个$y_i,i=1,…,m$，我们需要构造以下函数形式：</p><script type="math/tex;mode=display">y_i = w_1x_{1i}+...+w_nx_{ni}+b</script><p>为了表述的简洁与计算的方便，我们尽量将其化简为向量或矩阵形式。</p><p>令$w$=$(w_1,…,w_n)^T$，则</p><script type="math/tex;mode=display">y_i = w^Tx_i + b</script><p>我们还可以再简化，令</p><script type="math/tex;mode=display">\bar{w}=\left(\begin{matrix}w \\ b\end{matrix}\right),\bar{x}_i = \left(\begin{matrix}x_i \\ 1\end{matrix}\right)</script><p>则得</p><script type="math/tex;mode=display">y_i = \bar{w}^T\bar{x_i}</script><p>对于全部m组测量值，我们可以写出以下式子</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}\left (  \begin{array}{c}  y_1 \\  \cdots \\  y_m  \end{array}\right) &= \left(  \begin{array}{c}  \bar{w}^T\bar{x}_1 \\  \cdots \\  \bar{w}^T\bar{x}_m  \end{array}\right) \\&=\bar{w}^T\left(  \begin{array}{c}  \bar{x}_1 \\  \cdots \\  \bar{x}_m  \end{array}\right)\end{aligned}\end{equation}</script><p>由于此问题中$\bar{w}$才是自变量，我们可以令$y = (y_1, …, y_m)^T$，$D=(\bar{x}_1,…,\bar{x}_m)^T$，写成以下形式</p><script type="math/tex;mode=display">y = D^T\bar{w}</script><p>由于已知样本值，我们可以使用最小二乘法，对以下式子求解即可。</p><script type="math/tex;mode=display">min \space (Y - y)^T(Y-y)</script>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>大数据优化建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实模式与保护模式</title>
    <link href="/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.html"/>
    <url>/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><p>早期CPU（如8086）是16位的CPU，寄存器是16位的，数据总线是16位的，也就是说在8086内部，能够一次性处理与传输的数据最长为16位比特，那么它的寻址能力仅为2<sup>16</sup>=64 KB。但是地址总线却是20位的，即其寻址能力为2<sup>20</sup>=1 MB。</p><p>为了解决寻址能力不匹配这一问题，引入了地址加法器，以如下公式进行地址的换算：<strong>内存地址 = (段地址 &lt;&lt; 4) + 段内偏移地址</strong>。</p><p>由于寄存器为16位，则其中存的段地址/段内偏移地址为16位，段地址向左偏移4位即得20位的地址，再加上段内偏移即可得到内存中实际的物理地址。</p><p>这样的寻址方式是很直接的，相当于物理地址直接暴露在程序员面前，程序员可以随意的修改内存各处的内容，有着较大的安全隐患。或许这就是为什么叫做实模式吧。</p><p>另外，还有一点值得注意：<code>段地址+段内偏移地址</code>这样的寻址方式对于16位CPU而言是可以“越界”的。对于16位而言，最大地址即为FFFF，因此可取得内存地址：</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}memory \space address &= FFFF << 4 + FFFF \\                      &= FFFF0 + FFFF \\                      &= 10FFEF\end{aligned}\end{equation}</script><p>若想访问到10FFEF，需要21根地址总线，但是实际地址总线仅有20根，内存地址实际最大仅为100000 &lt; 10FFEF，越界了。但是系统并不认为其访问越界而抛出异常，而是将访问大于等于100000的地址均对100000取模，因此此时访问到的就是较小的内存地址了。</p><p>再后来，CPU发展到了80286，此时地址总线已有24根，那么10FFEF就是可以访问到的了，但是<strong>在实模式下</strong>，为了向下兼容，系统表现的行为又应同8086一样，即仿佛“只有20根地址总线”。为了能够自由选择<strong>实模式下</strong>寻址能力的大小，便出现了A20 Gate。</p><h2 id="A20-Gate"><a href="#A20-Gate" class="headerlink" title="A20 Gate"></a>A20 Gate</h2><p>A20 Gate是第21根地址总线，它有一个开关，<strong>对于实模式而言</strong>：</p><ul><li>开关打开时，这根地址总线可用，程序员可以访问到100000～10FFEF的地址</li><li>开关关闭时，这根地址总线不可用，程序员不可以访问到100000～10FFEF的地址</li></ul><p>因此在实模式下要想访问高端内存区，这个开关必须打开。在保护模式下，如果A20关闭，那么系统只能访问奇数兆的内存，即只能访问0～1M、2～3M……，所以在保护模式下，这个开关一般也会打开。</p><h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>在后续更高系列的CPU中，即使A20 Gate被打开，在实模式下所能够访问的内存最大也只能为10FFEF，而内存的寻址能力远不止如此。为了能够访问更大的地址，则必须进入保护模式。</p><p>虽然后续一般寄存器和地址总线都有着相同的位数，但系统并没有使用寄存器直接指定内存地址，而是沿用了<code>段地址+段内偏移地址</code>的寻址方式。段值存入段寄存器，而该值作为索引，用于在<code>全局描述符表</code>（GDT）中寻找到对应的一个表项（<code>段描述符</code>），该表项中含有段地址、段大小、访问控制等信息，得到其中的段地址后再加上合法的段内偏移，即可访问到对应的物理地址。</p><p>GDT条目结构如下所示：</p><p><img src="/img/posts/实模式与保护模式1.png" srcset="/img/loading.gif" alt=""></p><center>图源自https://en.wikipedia.org/wiki/Global_Descriptor_Table</center><p>综上可知，在保护模式下，物理地址并不是直接暴露在程序员面前了，寻址有了更多的检查步骤，这是属于虚拟内存的范畴了，在此就不再深入。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/trochiluses/article/details/8954527" target="_blank" rel="noopener">实模式与保护模式解惑之（一）——二者的起源与区别</a></li><li><a href="https://blog.csdn.net/lightseed/article/details/4305865#commentBox" target="_blank" rel="noopener">Gate A20与保护模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week1: union-find</title>
    <link href="/week1-union-find.html"/>
    <url>/week1-union-find.html</url>
    
    <content type="html"><![CDATA[<h1 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h1><p>现实世界中，人际关系时常变化，如何快速判断两个人是否是朋友关系？路径不断增删，如何快速判断两个地点是否互通？这些都是动态连通性问题，现在已经有很好的算法来解决他们，即并查集算法。</p><h2 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h2><p>在这一问题中，显然最关键的就是<strong>物体</strong>和<strong>连通</strong>。对于各个物体，我们可以用整数表示，如N个物体，使用0～N-1表示；对于连通，学过离散数学的朋友应该能很自然地想到连通性是一种等价关系（满足自反性、对称性和传递性），这一关系将物体分为一个个等价类（连通集）。</p><h2 id="算法解决"><a href="#算法解决" class="headerlink" title="算法解决"></a>算法解决</h2><h3 id="简单的想法：quick-find"><a href="#简单的想法：quick-find" class="headerlink" title="简单的想法：quick-find"></a>简单的想法：quick-find</h3><p>对于N个物体，显然可以使用一个一维的数组来储存，而对于连通性的判断，我们可以对一个连通集维护一个值，即当两个节点存储的值相等时，认为它们在同一连通集中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">return</span> id[p] == id[q];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">int</span> pid = id[p];    <span class="hljs-keyword">int</span> qid = id[q];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; id.length; i++) &#123;        <span class="hljs-keyword">if</span> (id[i] == pid)            id[i] = qid;    &#125;&#125;</code></pre><p>这样判断连通性仅需O(1)，但合并操作却需要O(N)，我们需要对合并操作做一定的优化。</p><h3 id="优化1：quick-union"><a href="#优化1：quick-union" class="headerlink" title="优化1：quick-union"></a>优化1：quick-union</h3><p>quick-find的合并操作较慢是由于需要遍历数组来寻找在同一连通集的元素并加以修改，而quick-union为了解决这一问题换了一种思路：将N个物体看作森林，每一个连通集是一棵树，这样我们只需判断两个节点是否在一颗树上，即根节点是否相等，就可以知道它们是不是在同一连通集中。</p><p>令id[p]为节点p的父节点，若id[p] == p，则p为根节点：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">while</span> (i != id[i])        i = id[i];    <span class="hljs-keyword">return</span> i;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">return</span> root(p) == root(q);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = root(p);    <span class="hljs-keyword">int</span> j = root(q);    id[i] = j;&#125;</code></pre><p>这样一来，在已求出两节点的根节点时，合并操作是O(1)的。但是如果表示连通集的树退化成链表，求根节点的操作还会是O(N)的，因此我们需要寻找办法来降低树的高度。</p><h3 id="优化2：weighted-quick-union"><a href="#优化2：weighted-quick-union" class="headerlink" title="优化2：weighted quick-union"></a>优化2：weighted quick-union</h3><p>方法一就是对树赋权值（表示大小），在每次合并操作中，将小树的根连接到大树的根上，以此达到平衡树高度的目的，如下图所示。</p><p><img src="/img/posts/week1_union-find_1.png" srcset="/img/loading.gif" alt=""></p><p>实现的方法也很简单，只需像维护id数组一样维护一个表示连通集大小的sz数组即可（这里只给出union的实现，其他基本不变）：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123; <span class="hljs-keyword">int</span> i  = root(p);    <span class="hljs-keyword">int</span> j = root(q);    <span class="hljs-keyword">if</span> (i == j)         <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (sz[i] &lt; sz[j]) &#123;        id[i] = j;        sz[j] += sz[i];    &#125; <span class="hljs-keyword">else</span> &#123;        id[j] = i;        sz[i] += sz[j];    &#125;&#125;</code></pre><p>经过这样的加权平衡操作，我们求根节点的操作仅需O(lg N)了，证明如下：</p><p>对于一个节点x，<strong>它所在的深度</strong>仅会在它所在的连通集作为子树连到另一连通集上时<strong>加一</strong>，如下图，x的深度仅会在它所在的连通集T1作为子树连到T2上时会加一。在合并操作后，T1和T2会作为一个新的连通集T继续以后的操作，它的大小至少是原来T1大小的两倍。总共有N个节点，翻倍的次数最多为lg N次，因此求根节点操作为O(lg N)。</p><p><img src="/img/posts/week1_union-find_2.png" srcset="/img/loading.gif" alt=""></p><h3 id="优化3：path-compression"><a href="#优化3：path-compression" class="headerlink" title="优化3：path compression"></a>优化3：path compression</h3><p>在求根节点的过程中，我们可以顺便进行路径的压缩以达到降低树高度的目的。由于我们之前定义过：“若id[p] == p，则p为根节点”，因此我们可以让路径上的每个点指向其祖父节点，即id[p] = id[id[p]]，这样可以使寻根的路径减半，也不会影响根节点。在不断的合并操作下，树的高度可以趋近于1。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">while</span> (i != id[i]) &#123;        id[i] = id[id[i]];        i = id[i];    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre><p>综合运用weighted quick-union和path compression的情况下，摊还分析表示判断连通性与合并操作都为常数时间。</p><h1 id="Assignment-Percolation"><a href="#Assignment-Percolation" class="headerlink" title="Assignment: Percolation"></a>Assignment: Percolation</h1><p>这周的大作业是判断一个正方形渗透模型的动态连通性，代码见<a href="https://github.com/seineo/Algorithms/blob/master/Part1/week1/README.md" target="_blank" rel="noopener">这里</a>。在这主要说明下完成作业的两个关键点：</p><ol><li><strong>二维转一维</strong>。对于这样一个N x N的正方形渗透模型，其本质是判断第一行与最后一行是否有元素在一个连通集中，因此也就是一个并查集问题。我们需要将二维的坐标对应到一维的、大小为N x N + 2的数组坐标上。（2是用于减少计算量的上下两个虚拟节点）</li><li><strong>解决backwash</strong>。完成任务的朋友可能会发现，测试<code>input10.txt</code>时显示的图像与参考答案不符，与最后一行相连的open的块集合均变为了蓝色，其实这就是所谓的backwash。这是因为渗透时，上面的虚拟节点与下面的虚拟节点在同一连通集中，最后一行与下面的虚拟节点也在同一连通集中，这就导致与最后一行相连的open块集合就会直接与上面的虚拟节点在同一连通集中，因此对这些块<code>isFull</code>函数都判断为true，它们也就显示为蓝色了。解决方法有两个：<ol><li><strong>去掉下面的虚拟节点</strong>。这样最后一行就不会与下面的虚拟节点在同一连通集中，模型渗透时也就不会直接与上面的虚拟节点在同一连通集了。但这样判断模型是否渗透时就需要上面的虚拟节点与最后一行的元素进行一一判断，时间复杂度为O(N)。</li><li><strong>增加一个并查集</strong>。新的并查集与原来的并查集差别只在于新的并查集没有虚拟节点。在平时的操作中，需要对两个并查集都进行操作，而判断模型是否渗透时，只判断新的并查集。这一方法就是用空间换时间了，时间复杂度仅为O(1)。</li></ol></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u010665051/article/details/35334157" target="_blank" rel="noopener">动态连通性问题的并查集算法（上）</a></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>Algorithms, Part 1</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论：最大流最小割详解</title>
    <link href="/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E8%AF%A6%E8%A7%A3.html"/>
    <url>/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E8%AF%A6%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>想象这样的情形：水厂（图中的消防栓）通过流向、容量各不相同的水管供水到你所在的小区（图中的水桶），每次供水最多可以供多少呢？如果想切断到你所在小区的供水，我们最少该切断哪几根水管呢（如果切断成本与水管容量成正比）？</p><p><img src="/img/posts/waterflow.png" srcset="/img/loading.gif" alt=""></p><center>图源自https://brilliant.org/wiki/max-flow-min-cut-algorithm/</center><p>其实这就是图论中的最大流-最小割问题，本文用“水流”与“水管”类比，先讨论最大流问题，然后再说明最大流与最小割的特殊关系，我们还将讨论一些实际中会使用的相关算法及其实现。</p><h1 id="直觉"><a href="#直觉" class="headerlink" title="直觉"></a>直觉</h1><p>每次供水量的最大值显然取决于传输路径中各根水管容量的最小值（类似<a href="https://baike.baidu.com/item/%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94/870962" target="_blank" rel="noopener">木桶效应</a>），不然当通过那根水管时，水管有可能会破裂。因此我们可以很快地想出这样的方法：每次寻找一条从出发点到目的地的可行路径，累加每条路径中水管容量的最小值，最后便是供水量的最大值。（<strong>注意：这并不完全正确</strong>）</p><p>我们可以找几个简单的例子试一试：</p><p><img src="/img/posts/max_flow_example1.png" srcset="/img/loading.gif" alt=""></p><p>这只有一条路径，而其路径中最小值为2，那么我们每次供水量的最大值就是2，这显然是正确的。</p><p>再来看一个复杂些的例子：</p><p><img src="/img/posts/max_flow_example2.png" srcset="/img/loading.gif" alt=""></p><p>假如我们先找到的是s-&gt;u-&gt;v-&gt;t这一路径，那么其中最小值即为2，更新供水量为2，而后该图就变成了这样:</p><p><img src="/img/posts/max_flow_example3.png" srcset="/img/loading.gif" alt=""></p><p>这里我们定义<code>x/y</code>表示容量最大值为y，我们已经用了x。由更新后的图，我们可以发现，已经没有可行的路径了，所以最后得出的供水量最大值即为2。但这是正确的吗？如果你仔细观察，你会发现，其实供水量的最大值应该是3，上方流量为2的水流一个走s-&gt;u-&gt;t，一个走s-&gt;u-&gt;v-&gt;t，下方流量为1的水流走s-&gt;v-&gt;t，如下图所示：</p><p><img src="/img/posts/max_flow_example4.png" srcset="/img/loading.gif" alt=""></p><p>由此可见，我们单纯地寻找路径然后叠加不一定能得到正确的最大流，因为我们在流向选择时很可能是做出了错误的决定，比如上个例子，我们流量为2的水流本应分流但我们没有，这时我们就需要<strong>残留网络</strong>（residual graph）来让我们可以<strong>撤销</strong>（undo）错误的决定。</p><h1 id="残留网络（residual-graph）"><a href="#残留网络（residual-graph）" class="headerlink" title="残留网络（residual graph）"></a>残留网络（residual graph）</h1><p>残留网络是解决问题的关键，也是最让人疑惑的地方，在这里我尽量用易懂的语言和图示来说明。</p><p>个人认为，残留网络的<strong>关键思想</strong>在于：为了可以撤销（undo）先前的流向决定，我们就需要减小原先路径的可流量并对应地增加反向路径的可流量。为什么还可以增加反向路径的可流量？<strong>因为在残留网络中，反向路径的流量并不是说明我们真的可以倒着流，而只是说明我们可以撤销（undo）先前在这条路径过来的这么多流量，让它流向其他路径</strong>。下面我们再用上一个例子来讲解利用残留网络是如何成功地找到最大流的。</p><p>在第一次寻找路径时，我们找到了s-&gt;u-&gt;v-&gt;t，其最小值为2，那么我们就将路径中各根水管的可流量（最初就是容量）减2，对应反向路径加2。</p><p>我们在这给个图（注意：为了清晰美观，对于残留网络中的权值，我们不再使用<code>x/y</code>这种形式，而换用可流量表示，且可流量为0的边直接删去）：</p><p><img src="/img/posts/max_flow_example5.png" srcset="/img/loading.gif" alt=""></p><p>这张图是怎么来的呢？我们按边来一一解释。在路径s-&gt;u-&gt;v-&gt;t中的每条边可流量都减2，那么s-&gt;u的可流量便从2降为0，我们将其删去，并加上可流量为2的反向路径，这一反向路径是说明，我们之前在这通入了<code>2</code>的水流，那么以后我们最多可以撤销<code>2</code>的水流。u-&gt;v的可流量从3降为1，反向路径也是2，最后v-&gt;t与s-&gt;u情形一样。</p><p>我们再尝试寻找一条路径，可以找到s-&gt;v-&gt;u-&gt;t，其最小值为1，那么我们就将路径中各根水管的可流量减1，对应反向路径加1，得到下面这个图：</p><p><img src="/img/posts/max_flow_example6.png" srcset="/img/loading.gif" alt=""></p><p>在这里着重说下v&lt;-&gt;u路径，本来是u-&gt;v可流量为1，可撤回流量为2，现在我们撤回了流量为1的u-&gt;v水流并让其走u-&gt;t路径，所以u-&gt;v可流量变为2，可撤回流量为1，即最初我们到u的<code>2</code>水流，现在<code>1</code>走u-&gt;v，<code>1</code>走u-&gt;t。</p><p>再次寻找路径，发现没有可行的路径，结束。因此最终最大流为2+1=3。</p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p>其实前面我们求解最大流的方法就是Ford-Fulkerson方法。 这一方法只需重复以下步骤：</p><ol><li>寻找一条从出发点到目的地的可行路径，称为<strong>增广路径</strong>（argumenting path），没有则结束</li><li>找出该路径中权值的最小值</li><li>用这一最小值更新该路径中的前向边与反向边</li><li>将这一最小值累加到<code>max_flow</code>上（<code>max_flow</code>初始为0）</li></ol><p>最终得到的<code>max_flow</code>就是最大流。</p><p>Ford-Fulkerson为什么是称为方法而不是算法呢？因为它并没有指定如何寻找一条增广路径。一般而言有两种实现方法:</p><ol><li>DFS，总时间复杂度为$O(EC)$，$E$为图的边数，$C$为出发点$s$邻接边的权值之和$C:=\sum\limits_{e\,leaving\,s}C_e$。</li><li>BFS，总时间复杂度为$O(VE^2)$，$V$为图的顶点个数，是较优的算法，称为<strong>Edmonds-Karp算法</strong>。</li></ol><h2 id="为什么BFS优于DFS？"><a href="#为什么BFS优于DFS？" class="headerlink" title="为什么BFS优于DFS？"></a>为什么BFS优于DFS？</h2><p>我们可以看这样一个例子，显然最大流为20000：</p><p><img src="/img/posts/max_flow_example7.png" srcset="/img/loading.gif" alt=""></p><p>DFS寻找路径是不稳定的，我们在这里讨论最坏情况。假如我们第一次寻找到的路径为s-&gt;u-&gt;v-&gt;t，那么更新<code>max_flow</code>为1，得到下图：</p><p><img src="/img/posts/max_flow_example8.png" srcset="/img/loading.gif" alt=""></p><p>此时如果再寻找到的路径为s-&gt;v-&gt;u-&gt;t，那么更新<code>max_flow</code>为2，又会得到下图:</p><p><img src="/img/posts/max_flow_example9.png" srcset="/img/loading.gif" alt=""></p><p>我们可以发现，若如此反复，我们需要20000次迭代寻找路径，才能达到最大流。这就是使用DFS的弊端，由于寻找路径的不稳定，当出发点邻接边权值之和很大时，效率有可能极低。</p><p>而如果我们使用BFS，<strong>将流图当成无权图</strong>，那么我们每次都可以确定地找到<strong>最短路径</strong>，这样时间复杂度也就仅与顶点数、边数有关了，没有潜在的低效率风险。</p><h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><p>在这里我们给出伪代码（若需要多语言版本的实现，可参见<a href="https://www.programiz.com/dsa/ford-fulkerson-algorithm" target="_blank" rel="noopener">这里</a>）：</p><pre><code class="hljs cpp">rGraph = graph   <span class="hljs-comment">// 用原图初始化残留网络</span>max_flow = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> finding a path p from s to t in rGraph with DFS <span class="hljs-keyword">or</span> BFS &#123;    min_edge = min&#123;e(u, v) <span class="hljs-keyword">for</span> all e（u, v) in p&#125;;    <span class="hljs-function"><span class="hljs-keyword">for</span> each edge <span class="hljs-title">e</span><span class="hljs-params">(u, v)</span> in p </span>&#123;        rGraph[u][v] -= min_edge;   <span class="hljs-comment">// 更新前向边</span>        rGraph[v][u] += min_edge;   <span class="hljs-comment">// 更新后向边</span>    &#125;    max_flow += min_edge;&#125;<span class="hljs-keyword">return</span> max_flow;</code></pre><h1 id="最大流与最小割的关系"><a href="#最大流与最小割的关系" class="headerlink" title="最大流与最小割的关系"></a>最大流与最小割的关系</h1><p>最大流最小割定理：最大流=最小割。为了彻底理解这一定理，我们这里不得不涉及一些数学证明。</p><p>什么是割？简单来说，割就是将一个图切割为互不相连的子图。最小割是s-t割，是将一个图分为两个子集$S$和$T$，它们满足以下关系：</p><ol><li>$S \cup T = V$</li><li>$S \cap T = \varnothing$</li><li>$s \in S \, and \, t \in T$</li></ol><p>我们还需要知道什么是s-t割的容量，即从$S$集合指向$T$集合的边的权值之和（$T$集合指向$S$集合的不算），可以表示为</p><script type="math/tex;mode=display">c(S,T)=\sum\limits_{u \in S} \sum\limits_{v \in T}e(u,v)</script><p>最小割的目的就是让s-t割的容量最小。</p><p>对于一个s-t流，多少是从$S$集合<strong>真正</strong>流到$T$集合的呢？显然是它从$S$集合流到$T$集合的量减去从$T$集合流到$S$集合的量，即</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}f(S,T) &= \sum\limits_{u \in S} \sum\limits_{v \in T} f(u,v) -  \sum\limits_{v \in T} \sum\limits_{u \in S} f(v,u) \\    &= f^{out}(S) - f^{in}(S)\end{aligned}\end{equation}</script><p>有了以上这些定义的铺垫，我们可以很容易地写出以下关系式：</p><script type="math/tex;mode=display">\begin{equation}\begin{aligned}f(S,T) &= f^{out}(S) - f^{in}(S) \\       &\leq f^{out}(S) \\       &= \sum\limits_{e \, leaving \, S}f(e) \\       &\leq \sum\limits_{e\, leaving\, s} c(e)  \\       &= C(S,T)\end{aligned}\end{equation}</script><p>也就是当没有从$T$集合流入$S$集合的流量时，s-t流达到了最大值，而一条边的流量最大就是等于其容量，那么我们就得到了最大流=最小割。</p><h1 id="如何寻找最小割对应边？"><a href="#如何寻找最小割对应边？" class="headerlink" title="如何寻找最小割对应边？"></a>如何寻找最小割对应边？</h1><p>我们找到了最大流，根据最大流最小割定理，它的值也就是最小割，因此当我们找到了最大流，也就是没有s-&gt;t的增广路径时，剩下的残留网络刚好将$S$集合与$T$集合分割开来，这就是最小割。寻找最小割对应边也就十分简单了：</p><ol><li>找到最大流<code>max_flow</code></li><li>对最后的残留网络进行DFS/BFS遍历，可达的点集合为$S$，不可达的为$T$</li><li>从$S$集合到$T$集合的边，即$\forall e(u,v),\,u \in S, v \in T$就是最小割对应边</li></ol><h1 id="参考与推荐"><a href="#参考与推荐" class="headerlink" title="参考与推荐"></a>参考与推荐</h1><ul><li><p><a href="https://www.youtube.com/watch?v=oHy3ddI9X3o" target="_blank" rel="noopener">Network Flows: Max-Flow Min-Cut Theorem (&amp; Ford-Fulkerson Algorithm)</a> 如果还没理解的朋友，我强烈推荐观看这一个视频</p></li><li><p><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/netflow.pdf" target="_blank" rel="noopener">CMSC 451: Network Flows</a>、<a href="https://brilliant.org/wiki/edmonds-karp-algorithm/#complexity-proof" target="_blank" rel="noopener">Complexity Proof of Edmonds-Karp Algorithm</a> 规范的数学表述与证明</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论：常用的最短路算法详解</title>
    <link href="/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <url>/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文将讨论最常用的几个最短路算法，它们的用处各不相同，我们将探讨它们的原理，并给出伪代码实现。如果你通过这篇文章彻底理解了这些算法，那么将伪代码转换为可运行的源代码应该也不成问题:)</p><p>伪代码的规定：</p><ol><li>出发点：s</li><li>目的地(如果只有一个目的地）：d</li></ol><h1 id="Breath-first-Search"><a href="#Breath-first-Search" class="headerlink" title="Breath-first Search"></a>Breath-first Search</h1><p>Breath First Search（BFS），即广度优先搜索，刚学图论算法的朋友可能只用它进行图的遍历，但其实它也可以用来查找无权图的最短路径，只需加个<code>parent</code>数组记录前驱节点即可。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>广度优先搜索的原理十分简单，它从出发点一圈一圈地向外探索，直到遍历完所有点或遇到目的地。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了实现这一算法，我们只需重复以下步骤：</p><ol><li>从探索的前沿<code>frontier</code>中取出一个点<code>cur</code>，如果<code>cur</code>就是目的地，结束探索。</li><li>查看<code>cur</code>的各个邻接点，若该邻接点尚未访问过，则将其加入<code>frontier</code>，并将其标记为访问过。（对于未访问过的节点i，<code>parent[i]</code>恰好为-1，因此我们可以不需要多余的<code>visit</code>数组判断访问过与否）</li></ol><p>了解了实现的大致步骤，我们便可以写下如下伪代码：</p><pre><code class="hljs cpp">parent[s] = sparent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; sfrontier = an empty <span class="hljs-built_in">queue</span>frontier.enqueue(s)<span class="hljs-keyword">while</span> !frontier.isEmpty() &#123;    cur = frontier.dequeue()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> parent[next] == <span class="hljs-number">-1</span> &#123;            parent[next] = cur            frontier.enqueue(next)        &#125;    &#125;&#125;</code></pre><h1 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h1><p>BFS只能处理无权图，但在很多时候，各条路径所需的开销是不同的，当开销不为负时，我们就可以使用Dijkstra算法了。（为什么开销一定不能为负呢？下面原理有解释）</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Dijkstra是贪心算法（每次都想取目前的最优），从出发点开始，它每次从不在最短路径树上的点集合中寻找最近的点，将其加入最短路径树，并从该点<strong>松弛</strong>它的邻接边，直到遍历完所有点或遇到目的地。</p><h3 id="松弛（relaxation）"><a href="#松弛（relaxation）" class="headerlink" title="松弛（relaxation）"></a>松弛（relaxation）</h3><p>本文讨论的对于有权图的最短路算法均用到了松弛。所以，到底什么是松弛？我们可以看一个简单的例子。</p><p><img src="/img/posts/relaxation.png" srcset="/img/loading.gif" alt="relaxation"></p><p>如图，当前从s到d的已知开销还是无穷大（即暂时不可达），但如果我们走经过x点的路径，<code>4 + 5 = 9 &lt; inf</code>,因此我们就可以更新s到d的开销为9，这一过程就称为松弛。我们可以由这个例子写出如下典型的代码：</p><pre><code class="hljs cpp"><span class="hljs-comment">// dist[n]存储的是从出发点到点n已知的开销, l(x, y)是x点到y点边所带的权</span><span class="hljs-keyword">if</span> (dist[d] &gt; dist[x] + l(x, d))    dist[d] = dist[x] + l(x, d);<span class="hljs-comment">// 也可以再简化下：</span>dist[d] = min(dist[d], dist[x] + l(x, d));</code></pre><h3 id="为什么不能有负权边？"><a href="#为什么不能有负权边？" class="headerlink" title="为什么不能有负权边？"></a>为什么不能有负权边？</h3><p>前面我们说到，若一个图要用Dijkstra算法，这个图必须没有负权边。这是由该算法的原理决定的，当我们从不在最短路径树上的点集合中找到一个最近的点时，我们会将其加入最短路径树，不再更改它的值。这样对没有负权值的图是合理的，但是若有负权值，这样最后的结果可能不是最短路径。我们可以考虑这样的情况：</p><p><img src="/img/posts/whycantnegative.png" srcset="/img/loading.gif" alt="why can&#39;t have negative edges"></p><p>y点已经在最短路径树上了，开销为3，按照算法，我们不会再修改它的值，但由于x点到y点是负权值，<code>4 - 2 = 2 &lt; 3</code>，实际的最短路径应该是s-&gt;x-&gt;y，距离为2，而不是3，这是Dijkstra算法无法处理的情况。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>其实Dijkstra和BFS是类似的，只不过因为边是有权值的，所以Dijkstra需要每次找到最近的点然后松弛它的邻接边。</p><p>这里我们使用优先队列这一数据结构来帮我们寻找不在最短路径树中最近的点，伪代码如下：</p><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; spriority_queue.insert(s)<span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;    cur = priority_queue.deletemin()    <span class="hljs-keyword">for</span> all neighbors next of cur &#123;        <span class="hljs-keyword">if</span> dist[next] &gt; dist[cur] + l(cur, next) &#123;            parent[next] = cur            dist[next] = dist[cur] + l(cur, next)            priority_queue.insert(next)        &#125;    &#125;&#125;</code></pre><h1 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h1><p>BFS和Dijkstra算法是向四周一圈一圈地往外探索，当用于求解到其他多个点的最短路径时，这是合理的，但如果我们只是想求两个点之间的最短路径，这样就会做许多无用功，这时候我们就可以使用A*算法。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>A*算法较于Dijkstra算法就是多了一个<strong>启发函数</strong>（heuristic），它在计算时提供了一个目的地的导向，使我们能往那个方向探索。</p><h3 id="启发函数"><a href="#启发函数" class="headerlink" title="启发函数"></a>启发函数</h3><p>启发函数<strong>计算了当前解决问题的大概开销</strong>，在最短路径问题中，也就是当前点到目的地的距离。将到目的地的距离纳入考虑可以使我们更好地确定前往目的地的方向。</p><p>启发函数必须是可以简单快速计算出来的，否则会十分影响性能。关于启发函数，更多的内容可见：<a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" target="_blank" rel="noopener">Heuristics</a>。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>正如前面所说，A*算法与Dijkstra算法几乎一致，只是在优先队列排序中不仅仅考虑该点到出发点的距离，还要考虑到目的地的距离（启发函数）。因此我们可以很快地写出如下伪代码：</p><pre><code class="hljs cpp">heuristic(cur, d):    <span class="hljs-keyword">return</span> distance from cur to dmain:    dist[s] = <span class="hljs-number">0</span>    dist[v] = INF, parent[v] = <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> all v &lt;&gt; s    priority_queue.insert(s)    <span class="hljs-keyword">while</span> (!priority_queue.isEmpty()) &#123;        cur = priority_queue.deletemin()         <span class="hljs-keyword">if</span> (cur == d)             <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span> all neighbors next of cur &#123;            new_cost = dist[cur] + l(cur, next)            <span class="hljs-keyword">if</span> dist[next] &gt; new_cost &#123;                parent[next] = cur                dist[next] = new_cost                priority = new_cost + heuristic(next, d)                priority_queue.insert(next)            &#125;        &#125;    &#125;</code></pre><h1 id="Bellman-Ford-Algorithm"><a href="#Bellman-Ford-Algorithm" class="headerlink" title="Bellman-Ford Algorithm"></a>Bellman-Ford Algorithm</h1><p>Dijkstra算法和A*算法可以处理无负权值的最短路径问题，如果有负权值，我们就需要使用Bellman-Ford算法了，它还可以检测<strong>负权回路</strong>。</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>对于一个顶点数为n的图，从一点到另一点的最短路径长度不会大于n-1，因此我们只要进行n-1次的遍历操作，对所有的边都尝试松弛，如果没有负权回路，我们就能得到出发点到其余各点的最短路径。</p><p>或许与Dijkstra算法对比更好理解：Dijkstra算法是从出发点开始向外扩张，依次处理邻接边，并且如果一个点加入了最短路径树，它就不会再修改这个点的值了；而Bellman-Ford算法每次都是从出发点重新开始依次进行”松弛”更新操作，<strong>可能修改各点的值，这样也就能应对负权边了</strong>(可以回看下<a href="https://seineo.github.io/%E5%9B%BE%E8%AE%BA%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9C%89%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%9F">这里</a>)。所以其实Bellman-Ford算法就是比Dijkstra算法多做了一些松弛操作，正常情况是肯定可以得到最短路径的。</p><p>Bellman-Ford是动态规划算法，为了处理<strong>从出发点到其余各点的最短路</strong>这一大问题，先解决<strong>从出发点到一目的地最多用了k条边的最短路</strong>这一小的子问题。</p><p>定义：$f(d,k)$=从$s$点到$d$点最多用了$k$条边的最短路径长度</p><p>那么对于基准情况——不使用一条边：</p><script type="math/tex;mode=display">\begin{equation}f(d,k) = \left\{    \begin{array}{l}    0 &d=s \\    \infty &d \neq s    \end{array}\right.\end{equation}</script><p>根据松弛操作，我们可以写出以下递推式：</p><script type="math/tex;mode=display">f(d,k) = \min \left\{    f(d,k-1), \min\limits_{w:(w,d)\in E} \left\{ f(w,k-1)+l(w,d) \right\}\right\}</script><p>由此我们便可以递推得出到其余各点$v$的最短路径$f(d,n-1)$。</p><h3 id="负权回路"><a href="#负权回路" class="headerlink" title="负权回路"></a>负权回路</h3><p>负权回路并不是含有负权边的回路，而是权值之和为负的回路。</p><p>为什么有负权回路就不能求解正确的最短路径呢？可以看下面这个例子，我们只关注b点：</p><p><img src="/img/posts/negativecycle.png" srcset="/img/loading.gif" alt="negetive cycle"></p><p>这个图中有4个顶点，因此我们需要遍历3次。在第一次的遍历中，到b的最短距离一开始是3，后面经过d点的松弛后变为了2，在以后的遍历中，每次遍历结束，到b的最短距离都减一，因此我们可以发现，如果存在负权回路，相关点的“最短路径”就可以一直减小下去（这也是我们检验是否存在负权回路的方法）。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>大致步骤：</p><ol><li>遍历vertex_num - 1次，对所有边都尝试松弛操作</li><li>再遍历一次，如果某些点还能更新最短路径，则说明有负权回路，该图不存在最短路径</li></ol><pre><code class="hljs cpp">dist[s] = <span class="hljs-number">0</span>dist[v] = INF <span class="hljs-keyword">for</span> all v &lt;&gt; s<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;    <span class="hljs-keyword">for</span> all edge (v, w) &#123;        dist[w] = min(dist[w], dist[v] + l(v, w))    &#125;&#125;<span class="hljs-keyword">for</span> all edge (v, w) &#123;    <span class="hljs-keyword">if</span> dist[w] &gt; dist[v] + l(v, w)        output <span class="hljs-string">"negative cycle found"</span>&#125;</code></pre><h1 id="Floyd-Warshall-Algorithm"><a href="#Floyd-Warshall-Algorithm" class="headerlink" title="Floyd-Warshall Algorithm"></a>Floyd-Warshall Algorithm</h1><p>上述算法都是单源最短路算法，即从给定一点到另一点或其余各点，如果要求从任意一点到其余各点的最短路呢？当然，我们可以对每一个点调用上述算法，但Floyd-Warshall算法更为简洁优雅。</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>和Bellman-Ford算法一样，Floyd-Warshall算法也是动态规划算法，只不过前者是与边相关，而后者与点相关。因此如果你理解了上一算法的动态规划思想，那么这一算法你也就能很快的理解了，我们在这里就不过多解释了。</p><p>定义：$f(i,j,k)$ = 从点$i$到点$j$中途最多经过了$1,…,k$这些点的最短路径长度</p><p>基准情况——不经过任何点：</p><script type="math/tex;mode=display">\begin{equation}f(i,j,0) =\left\{             \begin{array}{l}             0 &i=j \\             l(i,j) &(i,j) \in E\\             \infty, &otherwise             \end{array}\right.\end{equation}</script><p>由松弛操作，我们可以得出以下递推式：</p><script type="math/tex;mode=display">f(i,j,k) = \min \left\{f(i,j,k-1),f(i,k,k-1)+f(k,j,k-1)\right\}</script><p>由此我们便可以递推出从任意点$i$到任意点$j$的最短路径$f(i,j,k)$。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>算法的核心代码其实就五行，十分简洁，思想就是对任意两点尝试经过各个点松弛。</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>;j &lt;= n;j++)             dist[i,j] = min(dist[i, j], dist[i, k] + dist[k, j])&#125;&#125;</code></pre><h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><div class="table-container"><table><thead><tr><th>算法</th><th>用处</th></tr></thead><tbody><tr><td>BFS</td><td>无权图，1-&gt;all</td></tr><tr><td>Dijkstra’s Algorithm</td><td>有权图，无负权边，1-&gt;all</td></tr><tr><td>A* Algorithm</td><td>有权图，无负权边，1-&gt;1</td></tr><tr><td>Bellman-Ford Algorithm</td><td>有权图，无负权回路，1-&gt;all</td></tr><tr><td>Floyd-Warshall Algorithm</td><td>有权图，all-&gt;all</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Introduction to the A* Algorithm</a></li><li><a href="https://stackoverflow.com/questions/26137239/what-is-a-heuristic-function" target="_blank" rel="noopener">What is a Heuristic Function</a></li><li><a href="https://downey.io/notes/omscs/cs6515/dynamic-programming-shortests-paths/" target="_blank" rel="noopener">dynamic programming - bellman-ford algorithm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms and Data Structures</title>
    <link href="/Algorithms-and-Data-Structures.html"/>
    <url>/Algorithms-and-Data-Structures.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>算法和数据结构是程序的基石，几乎每一个程序都需要它们，但绝大多数程序都不需要发明新的算法和数据结构。</p><p>为了方便后面的讨论，我们先在这里给出HTML中<code>name-value</code>键值对的定义：<br><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> <span class="hljs-title">Nameval</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Nameval</span> &#123;</span>    <span class="hljs-keyword">char</span> *name;    <span class="hljs-keyword">int</span> value;&#125;;</code></pre></p><h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><p>这里我们讨论一个现被广泛使用的排序算法：快排（quicksort）。</p><h2 id="快排的递归实现"><a href="#快排的递归实现" class="headerlink" title="快排的递归实现"></a>快排的递归实现</h2><p>快排的核心思想就是分治，它每次选出一个枢轴点（pivot），然后将数组中比这一点值小的数放在它左边，比它大的数放在它右边，再递归处理左边的数组和右边的数组。由此我们可以轻松地写出以下优雅的递归代码（枢轴点随机）：<br><pre><code class="hljs c"><span class="hljs-comment">/* swap - swap arr[i] and arr[j] */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp;    temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;<span class="hljs-comment">/* quicksort - sort the array into increasing order recursively */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n_arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (n_arr &lt;= <span class="hljs-number">1</span>)    <span class="hljs-comment">/* if array size &lt; 1, then no need for sorting */</span>        <span class="hljs-keyword">return</span>;    swap(arr, <span class="hljs-number">0</span>, rand() % n_arr); <span class="hljs-comment">/* generate pivot and move it to v[0] */</span>    <span class="hljs-comment">/* move the elements smaller than pivot */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n_arr; ++i) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[<span class="hljs-number">0</span>])            swap(arr, ++last, i);    &#125;    <span class="hljs-comment">/* restore povit */</span>    swap(arr, <span class="hljs-number">0</span>, last);    <span class="hljs-comment">/* recursively sort each part */</span>    quicksort(arr, last);    quicksort(arr + last + <span class="hljs-number">1</span>, n_arr - last - <span class="hljs-number">1</span>);&#125;</code></pre></p><h2 id="快排的迭代实现"><a href="#快排的迭代实现" class="headerlink" title="快排的迭代实现"></a>快排的迭代实现</h2><p>快排一般都是用递归形式写的，那么它如何用迭代的方式来写呢？</p><p>对于可以用分治解决的问题，我们一般都可以用辅助栈来将递归转换为迭代。这里我使用C++来实现，这样可以让我们更专注于算法思想而非语言的细枝末节。<br><pre><code class="hljs cpp"><span class="hljs-comment">// keep the range being sorted</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SortRange</span> &#123;</span>    <span class="hljs-comment">// constructor</span>    SortRange(<span class="hljs-keyword">size_t</span> s, <span class="hljs-keyword">size_t</span> e) : start(s), end(e) &#123;&#125;    <span class="hljs-keyword">size_t</span> start;    <span class="hljs-keyword">size_t</span> end;  <span class="hljs-comment">// exclude index end</span>&#125;;<span class="hljs-comment">// quicksort_iter - sort the array into increasing order iteratively</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort_iter</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;    <span class="hljs-built_in">stack</span>&lt;SortRange&gt; helper;    <span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-literal">nullptr</span>))</span></span>;    helper.push(&#123;<span class="hljs-number">0</span>, arr.size()&#125;);    <span class="hljs-comment">// sort until the stack is empty</span>    <span class="hljs-keyword">while</span> (!helper.empty()) &#123;        <span class="hljs-keyword">size_t</span> last, start, end;        start = helper.top().start;        end = helper.top().end;        last = start;        <span class="hljs-comment">// generate uniform distribution random numbers from [start, end-1]</span>        <span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-keyword">size_t</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(start, end - <span class="hljs-number">1</span>)</span></span>;        helper.pop();        <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">// if array size &lt;= 1, no need for sorting</span>            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// generate pivot and move it to arr[start]</span>        swap(arr[start], arr[u(e)]);        <span class="hljs-comment">// move the elements smaller than pivot</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = start + <span class="hljs-number">1</span>; i != end; ++i)            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[start])                swap(arr[++last], arr[i]);        <span class="hljs-comment">// restore pivot</span>        swap(arr[start], arr[last]);        <span class="hljs-comment">// put each part into stack for next loop</span>        helper.push(&#123;start, last&#125;);        helper.push(&#123;last + <span class="hljs-number">1</span>, end&#125;);    &#125;&#125;</code></pre><br>那么是不是我们应该避免用递归实现快排呢？毕竟“迭代快于递归”嘛。其实，快排可以说是递归优于迭代的典例了，既优雅又高效，可以放心地用递归版本。两者效率的讨论详见：<a href="https://stackoverflow.com/questions/12553238/quicksort-iterative-or-recursive" target="_blank" rel="noopener">Quicksort:Iterative or Recursive</a></p><h2 id="快排的性能"><a href="#快排的性能" class="headerlink" title="快排的性能"></a>快排的性能</h2><p>显然快排是效率较高的排序算法，因为它不需要接连地与每一个其他数组元素比较，而每次只需与枢轴点的值比较，比它小就放左边，比它大就放右边。这一点就使得快排优于插入排序和冒泡排序。</p><p>若每轮都能较为平均地分为两部分，那么当整个数组共有n个元素时，n + 2 <em>n / 2 + 3 </em>n / 3 + ……共有logn轮，因此时间复杂度为O(nlogn)。但现实中是会有一些特殊的输入序列会使快排的划分完全不均匀，致使较差的性能表现，主要有以下三种：</p><ol><li>已经接近顺序</li><li>已经接近逆序</li><li>所有元素都相等（其实是前两种的特殊情况）</li></ol><p>在这些时候，若枢轴点选择不当，可以达到最差时间复杂度O(n<sup>2</sup>)。</p><h1 id="Growing-Arrays"><a href="#Growing-Arrays" class="headerlink" title="Growing Arrays"></a>Growing Arrays</h1><p>这一节主要是讨论如何用C实现一个动态数组（类似C++中的vector），相比于实现的算法思路，我认为书中的一个设计细节更为引人注目。</p><p>当数组元素的个数要超出现有已分配的数组大小时，我们需要再分配更多的内存来容纳元素，在C语言中也就需要<code>realloc</code>函数。若实现动态数组的数据结构如下：<br><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NVtab</span> &#123;</span>    <span class="hljs-keyword">int</span> nval;   <span class="hljs-comment">/* current number of values */</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">/* allocated number of values */</span>    Nameval *nameval;    <span class="hljs-comment">/* array of name-value pairs */</span>&#125;nvtab;</code></pre><br>那么在增添数组元素的函数中，我们很可能写出这样的代码：<br><pre><code class="hljs c">...<span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    nvtab.nameval = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    ...&#125;</code></pre><br>当分配内存成功时，这段代码是没问题的。但如果分配失败的话，<code>nvtab.namval</code>所指向的数组就会丢失了。因此，我们应该用一个局部变量来暂存分配的结果，若分配成功了，再由<code>nvtab.nameval</code>接管分配好的数组。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (nvtab.nameval == <span class="hljs-literal">NULL</span>) &#123;   <span class="hljs-comment">/* first time */</span>   ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nvtab.nval &gt; nvtab.<span class="hljs-built_in">max</span>) &#123;  <span class="hljs-comment">/* grow */</span>    Nameval *tmp = (Nameval *)<span class="hljs-built_in">realloc</span>(nvtab.nameval, (NVGROW * nvtab.<span class="hljs-built_in">max</span>) * <span class="hljs-keyword">sizeof</span>(Nameval));    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    nvtab.nameval = tmp;    ...&#125;</code></pre></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><blockquote><p><strong>Exercise 2-8.</strong> Write recursive and iterative versions of <code>reverse</code>, which reverses a list. Do not create new list items; re-use the existing ones.</p></blockquote><p>这是一个很典型的数据结构题。我们在稍加思索后可以很容易地想出迭代的解法：遍历链表，将每一个节点指向它的前一个节点，第一个节点指向<code>NULL</code>。转换为代码：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_iter - reverse the whole list iteratively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_iter</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *next;    Nameval *prev = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> (listp != <span class="hljs-literal">NULL</span>) &#123;        next = listp-&gt;next;        listp-&gt;next = prev;        prev = listp;        listp = next;    &#125;    <span class="hljs-keyword">return</span> prev; &#125;</code></pre><br>那么如何递归地求解呢？写递归，最关键就是要牢记两条基本准则：</p><blockquote><ol><li><strong>基准情形</strong>。必须要有某些基准情形，它无须递归就能解出。</li><li><strong>不断推进</strong>。对于需要递归求解的情形，每一次递归调用都必须朝着接近基准情形的方向推进。</li></ol><p>摘录自《数据结构与算法分析——C语言描述》</p></blockquote><p>在这一道题目中，基准情况就是链表的第一个节点和最后一个节点。</p><ol><li>若链表为空，则返回空。</li><li>若链表只有一个节点或到达了最后一个节点，这个节点就是头结点，它应指向前一个节点或<code>NULL</code>。</li></ol><p>链表是单向的，它无法在顺序遍历时不记住前一个节点的情况下，指向前一个节点，因此我们应该在递归回溯时从后往前修改指针以达到指向前一个节点的目的。如：<br><pre><code class="hljs c">node-&gt;next-&gt;next = node;</code></pre><br>这样便实现了让后一个节点指向前一个节点。</p><p>综上，我们便可以写出递归的解法：<br><pre><code class="hljs c"><span class="hljs-comment">/* reverse_recur_helper - help to reverse the list recursively and get the head node */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse_recur_helper</span><span class="hljs-params">(Nameval *listp, Nameval **head)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (listp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (listp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;        *head = listp;        <span class="hljs-keyword">return</span>;    &#125;    reverse_recur_helper(listp-&gt;next, head);    listp-&gt;next-&gt;next = listp;    listp-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">/* reverse_recur - reverse the list recursively */</span><span class="hljs-function">Nameval *<span class="hljs-title">reverse_recur</span><span class="hljs-params">(Nameval *listp)</span></span><span class="hljs-function"></span>&#123;    Nameval *head;    reverse_recur_helper(listp, &amp;head);    <span class="hljs-keyword">return</span> head;&#125;</code></pre></p><h1 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h1><p>在实现哈希表的查找时，我们很容易想到这样实现：<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name)</span></span>;</code></pre><br>但这样的实现会使得如下的操作进行两次<code>hash</code>计算：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (lookup(<span class="hljs-string">"name"</span>) == <span class="hljs-literal">NULL</span>)    additem(newitem(<span class="hljs-string">"name"</span>, value));</code></pre><br>因此，将查找和插入选项结合起来是一个更好的选择。<br><pre><code class="hljs c"><span class="hljs-function">Nameval *<span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> create, <span class="hljs-keyword">int</span> value)</span></span>;</code></pre></p><h1 id="将整型转换为字符串"><a href="#将整型转换为字符串" class="headerlink" title="将整型转换为字符串"></a>将整型转换为字符串</h1><p>在创建HTML<code>name-value</code>键值对时，为了方便，我想将<code>name</code>直接表示为<code>value</code>的字符串形式。在C++中，这是十分容易实现的：<br><pre><code class="hljs cpp">name = to_string(value);</code></pre><br>在C语言当中，我以前一直都是使用<code>itoa</code>函数的，但最近才发现该函数并不属于C语言标准，标准的写法应为：<br><pre><code class="hljs c"><span class="hljs-comment">/* to_string - convert an int to string */</span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">char</span> *buf;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;    <span class="hljs-built_in">size</span> = <span class="hljs-built_in">snprintf</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"%d"</span>, value);  <span class="hljs-comment">/* get length of string */</span>    buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">/* allocate one character more for null-terminator */</span>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>, <span class="hljs-string">"%d"</span>, value);    <span class="hljs-keyword">return</span> buf;&#125;name = to_string(value);</code></pre></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bamsoftware.com/computers/tpop-answers.html" target="_blank" rel="noopener">Answers to the exercises in tpop</a></li><li><a href="https://www.youtube.com/watch?reload=9&amp;v=MRe3UsRadKw" target="_blank" rel="noopener">Reverse a Linked List Recursively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style</title>
    <link href="/Style.html"/>
    <url>/Style.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>代码风格是十分重要的，一个好的代码风格可以帮助读者更好地理解代码，也能帮助自己在写程序时及时排错。</p><h1 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h1><blockquote><p>Use descriptive names for globals, short names for locals.</p></blockquote><p>学习第一门程序语言时，我们总被教导道：要使用足够长的变量命名，这样读者才好理解这个变量的用途。其实这样是不对的。</p><p>全局变量的名字是需要足够长、足够具体的，因为他们可能出现在程序的各个地方，这样的名字可以帮助作者和读者回想起这个变量的用途。而局部变量简短些即可，比如要表示学生的人数，<code>n</code>也许就够了，<code>n_stu</code>也不错，但是<code>number_of_stu</code>就没必要，会显得代码冗长。</p><blockquote><p>Use active names for functions.</p></blockquote><p>函数名应该是动态的。比如要打印数组，<code>print_arr</code>就很好，而单独一个<code>arr</code>就让人不知道该函数的用途。名字中的动词也需要足够直白，比如返回布尔值的函数，<code>check_even</code>是模棱两可的，因为它并没有说明如果是偶数返回真还是假，而<code>is_even</code>就让人清楚地知道如果是偶数，该函数返回真。</p><h1 id="Expressions-and-Statements"><a href="#Expressions-and-Statements" class="headerlink" title="Expressions and Statements"></a>Expressions and Statements</h1><blockquote><p>Parenthesize to reslove ambiguity.</p></blockquote><p>括号可以清晰的划分结构与优先级，即使不需要的时候我们也可以加上以避免不必要的错误和增加可读性。</p><p>比如<code>if (x&amp;MASK == BITS)</code>，显然其本意是想判断<code>x</code>和掩码进行与运算后是否等于<code>BITS</code>，但由于位操作符的优先级低于等于号，这段代码实际上等价于<code>if (x &amp; (MASK == BITS))</code>，这也就发生了意料之外的错误，因此这个表达式需要加上括号，即<code>if ((x&amp;MASK) == BITS)</code>。</p><p>又如这样一个表达式：<br><pre><code class="hljs c">leap_year = y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != || y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;</code></pre><br>这当然是没错的，但第一眼看去，我们难以把握结构，若按如下修改会清晰得多：<br><pre><code class="hljs c">leap_year = ((y%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (y%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (y%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>));</code></pre><br>注意到，我们移去了一些空格，使高优先级的操作符更紧凑，这样可以帮助读者更快地把握结构。</p><blockquote><p>Be careful with side effects.</p></blockquote><p>不了解序列点(sequence point)、副作用(side effect)和未定义行为(undefined behavior)的朋友可先参见：<a href="https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points" target="_blank" rel="noopener">Undefined behavior and sequence points</a></p><p>在C和C++中，一个序列点前副作用的执行顺序是未定义的。如：<br><pre><code class="hljs c">str[i++] = str[i++] = <span class="hljs-string">' '</span>;</code></pre><br>在这里，<code>;</code>就是一个序列点，而我们知道，<code>++</code>操作符是有副作用的，它不仅返回一个值，还会修改该变量的值。所以在这一语句中对同一个变量多次<code>++</code>操作导致了未定义行为。因为虽然我们心里想的是<code>i</code>增加两次，但编译器不知道到底<code>i</code>是增加一次还是两次，也不知道是左边的<code>i</code>是使用右边的<code>i</code>递增后的值还是原来的值，这就导致了<code>warning: multiple unsequenced modification to i</code>。</p><p>再看一个我从书本Exercise 1-5改编的例子，以下代码片段有什么问题呢？<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ip)</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, ip);    <span class="hljs-keyword">return</span> *ip;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, a, b); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">read</span>(&amp;a), <span class="hljs-built_in">read</span>(&amp;b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><br>我们可以先看看当输入为<code>2 3</code>时，不同编译器下的输出结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">编译器</th><th style="text-align:left">输出结果</th></tr></thead><tbody><tr><td style="text-align:left">gcc</td><td style="text-align:left">3 2</td></tr><tr><td style="text-align:left">clang</td><td style="text-align:left">2 3</td></tr></tbody></table></div><p><code>scanf</code>函数不是分别运行的吗？为什么会产生这样的奇怪的结果呢？原因是<em>函数调用计算完所有参数后且执行被调用函数前</em>也是一个序列点，而我们这里的函数参数计算里含有I/O操作，I/O操作也有副作用，所以这里函数参数的计算顺序也是未定义的，因此如果先计算第一个参数，那么<code>2</code>就会被写入参数<code>a</code>中，<code>3</code>就会被写入<code>b</code>中，输出结果同clang；但如果先计算第二个参数，<code>2</code>和<code>3</code>就会被分别写入<code>b</code>和<code>a</code>中，输出结果同gcc。</p><h1 id="Consistency-and-Idioms"><a href="#Consistency-and-Idioms" class="headerlink" title="Consistency and Idioms"></a>Consistency and Idioms</h1><p>在这一节中，基本都是熟知的准则，不再赘述。但下面这个代码示例告诉了我们一种优雅处理嵌套的<code>if else</code>错误判断语句的方式。</p><p>我们很可能写出类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>)     <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)                putc(c,fout);            fclose(fin);            fclose(fout);        &#125; <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);</code></pre></p><p>使用递进的<code>if</code>判断，最终是前期准备无错误的处理代码，然后再用多个<code>else</code>分别处理各种错误情况。这段代码并不优雅，并且有资源泄露的可能——如果<code>fout</code>打开文件失败，那么<code>fin</code>打开的文件就不会显式关闭，未显式关闭文件可能导致的问题可参见：<a href="https://www.quora.com/Why-do-we-need-to-close-files-in-programming-after-performing-a-read-or-write-operation" target="_blank" rel="noopener">Why do we need to close files?</a><br>那么如何改进呢？我们可以使用<code>if, else if</code>来推进，先处理错误情况，最终才是正常情况下的代码。<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    fclose(fin); <span class="hljs-comment">/* release the resource fin occupied */</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)        putc(c,fout);    fclose(fin);    fclose(fout);&#125;</code></pre></p><h1 id="Function-Macros"><a href="#Function-Macros" class="headerlink" title="Function Macros"></a>Function Macros</h1><blockquote><p>Avoid function macros.</p></blockquote><p>宏是进行文本的替换，因此如果函数宏定义中参数出现了多次，那么它就会被计算多次，这在大多数时候都不是我们想要的。如：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isupper(c) ((c) &gt;= <span class="hljs-meta-string">'A'</span> &amp;&amp; (c) &lt;= <span class="hljs-meta-string">'Z'</span>)</span>...<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(c = getchar()))    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c is uppercase\n"</span>, c);</code></pre><br>那么实际<code>if</code>的判断语句等价于<br><pre><code class="hljs c"><span class="hljs-keyword">if</span> (((c = getchar()) &gt;= <span class="hljs-string">'A'</span> &amp;&amp; (c = getchar()) &lt;= <span class="hljs-string">'Z'</span>))</code></pre><br>这显然是错误的，假定我们输入一个字符然后回车，那么只要这个字符的ASCII码值大于等于A的码值就会有输出，因为逻辑与表达式的第二部分程序又读了一个字符，这个字符就是留在缓冲区的<code>\n</code>字符，其ASCII码值为<code>0xa</code>，小于<code>Z</code>的码值。</p><p>很多人习惯使用宏来管理幻数/魔数(Magic Numbers)，其实尽量不要用C预处理器来做这件事，让语言本身来处理是更好的。在C++中可以用<code>const</code>来声明常量：<br><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ARR_SIZE = <span class="hljs-number">5</span>;</code></pre><br>C中当然也有<code>const</code>，值得注意的是，用<code>const</code>修饰的值是无法作为<code>静态数组</code>的边界的（因为这是<code>运行时常量</code>），但<code>enum</code>可以实现这一点：<br><pre><code class="hljs c"><span class="hljs-keyword">enum</span> &#123;ARR_SIZE = <span class="hljs-number">5</span>&#125;;</code></pre></p><p>那这是不是意味着我们永远不能使用宏呢？并不是，我们应该让宏做函数做不了的事情。典型的例子就是仅由声明计算数组的长度：<br><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NELEMS(array) (sizeof(array) / sizeof(array[0]))</span></code></pre><br>在这里，<code>sizeof(array)</code>计算的就是数组本身的长度，而在函数中，数组参数退化为指针，<code>sizeof(array)</code>就只能计算出指针的大小了。对数组和指针关系不太明确的朋友可参考：<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">is an array name a pointer?</a></p><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><blockquote><p>Comment functions and global data.</p></blockquote><p>给每个函数和全局变量写适当的注释是一个好习惯。在我接触的好的代码风格中，也有的还在文件开头写一个文件的注释，告诉读者这一个文件的主要用途以及注意事项等，个人认为这也值得学习。</p><blockquote><p>Don’t comment bad code, rewrite it.</p></blockquote><p>这一准则给出了一个有意思的判断，即当注释的字数多过于要注释的代码段时，这段代码可能就是<code>bad code</code>。这时应该看看是否需要改善代码而不是坚持注释。</p><p>至此，第一章就结束了，希望我们都能形成一个好的代码风格。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int ch = getchar()?</title>
    <link href="/int-ch-getchar.html"/>
    <url>/int-ch-getchar.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>也许你看过/写过类似这样的代码：<br><pre><code class="hljs c"><span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这段代码看起来没什么问题，但实际上代码中的循环有可能永不终止，也有可能提前结束。</p><h1 id="函数与EOF介绍"><a href="#函数与EOF介绍" class="headerlink" title="函数与EOF介绍"></a>函数与EOF介绍</h1><p>在解释之前，我们先了解下相关内容。C语言常用的字符读取函数如下：<br><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getchar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre><br>这三个函数都是从文件流中读取一个字符，正常情况下把该字符从<code>unsigned char</code>转换为<code>int</code>类型返回，若出错或读到文件结尾则返回<code>EOF</code>。</p><p><code>EOF</code>又是什么呢？<code>EOF</code>只是一个宏定义的负整数而已，一般为<code>-1</code>(hex:0xffffffff)。</p><p>由于上述函数区别不大，此文便只用最常见的<code>getchar</code>函数来讨论。</p><h1 id="char-ch-getchar-错在哪里？"><a href="#char-ch-getchar-错在哪里？" class="headerlink" title="char ch = getchar()错在哪里？"></a>char ch = getchar()错在哪里？</h1><p>看到这，你可能会说：既然<code>EOF</code>只是值为<code>-1</code>的负整数，这不是在<code>char</code>的表示范围-128~127内吗？用<code>char</code>保存返回值有何不可？</p><p><code>-1</code>真的一定在<code>char</code>的表示范围内吗？我们可以在头文件<code>limits.h</code>中看到如下定义：<br><pre><code class="hljs c"><span class="hljs-comment">/* Minimum and maximum values a `signed char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MIN(-128)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MAX127</span><span class="hljs-comment">/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UCHAR_MAX255</span><span class="hljs-comment">/* Minimum and maximum values a `char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CHAR_UNSIGNED__</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MIN0</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXUCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MINSCHAR_MIN</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXSCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br>由此可见，标准并未规定<code>char</code>是有符号的，而是留给各个编译器自己实现。</p><p>所以当<code>char</code>默认为无符号时，<code>-1</code>就不在其表示范围内，这时使用<code>char</code>保存返回值也就有问题了。实际上即使你所用的编译器默认定义<code>char</code>是有符号的，文章开头的那段代码依然有潜在的bug。下面我们分为<code>char</code>默认无符号和有符号两种情况讨论，利用计算机组成原理的知识来详细解释为什么不应该用<code>char</code>保存<code>getchar</code>的返回值。</p><h2 id="1-char默认是无符号的"><a href="#1-char默认是无符号的" class="headerlink" title="1. char默认是无符号的"></a>1. char默认是无符号的</h2><p><strong>这种情况会导致循环无法终止。</strong>假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，这时由于<code>ch</code>是<code>char</code>类型，只有一个字节，而<code>EOF</code>是<code>int</code>类型，有四个字节却要保存在一个字节中，<code>EOF</code>的值会被截断，<code>ch</code>也就等于<code>0xff</code>，又因为<code>ch</code>要与<code>EOF</code>比较，<code>ch</code>符号扩展得<code>0x000000ff</code>（因为<code>ch</code>是无符号的，也就是0扩展），永远不可能等于<code>EOF</code>，循环也就永远不会终止。</p><h2 id="2-char默认是有符号的"><a href="#2-char默认是有符号的" class="headerlink" title="2. char默认是有符号的"></a>2. char默认是有符号的</h2><p><strong>这种情况可能导致循环提前终止。</strong>同样假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，前面都一样，但是在符号扩展的时候，由于<code>ch</code>是有符号的，其扩展得<code>0xffffffff</code>，等于<code>EOF</code>。因此循环是可以终止的，但是如果我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，循环就会同碰到<code>EOF</code>一样终止。</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>那么如何修改代码才是正确的呢？其实只需要用<code>int</code>来保存返回值即可。<br><pre><code class="hljs c"><span class="hljs-keyword">int</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><br>这种情况就不会有问题。即使我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，由于<code>ch</code>是<code>int</code>类型，而<code>getchar</code>是将读到的字符由<code>unsigned char</code>转为<code>int</code>作返回值，则该字节的值经符号扩展再赋值给<code>ch</code>，<code>ch</code>就等于<code>0x000000ff</code>，不会等于<code>EOF</code>，也就不会提前终止了。</p><p>综上，这就是为什么要用<code>int</code>类型而不是<code>char</code>类型来保存C语言字符读取函数的返回值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default" target="_blank" rel="noopener">is char signed or unsigned by default?</a></li><li><a href="https://stackoverflow.com/questions/13694394/while-c-getcfile-eof-loop-wont-stop-executing" target="_blank" rel="noopener">why the loop won’t stop executing?</a></li><li><a href="https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284351&amp;answer=1048865140" target="_blank" rel="noopener">Definition of EOF and how to use it effectively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
