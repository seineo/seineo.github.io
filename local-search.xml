<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Style</title>
    <link href="/Style.html"/>
    <url>/Style.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文是《The Practice of Programming》一书中Chapter 1: Style的笔记。</p><p>代码风格是十分重要的，一个好的代码风格可以帮助读者更好地理解代码，也能帮助自己在写程序时及时排错。</p><p>本章系统地讨论了代码风格，包括命名、语句、宏、幻数和注释等，但本文仅讨论章节中部分有趣的内容。</p><h1 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h1><blockquote><p>Use descriptive names for globals, short names for locals.</p></blockquote><p>学习第一门程序语言时，我们总被教导道：要使用足够长的变量命名，这样读者才好理解这个变量的用途。其实这样是不对的。</p><p>全局变量的名字是需要足够长、足够具体的，因为他们可能出现在程序的各个地方，这样的名字可以帮助作者和读者回想起这个变量的用途。而局部变量简短些即可，比如要表示学生的人数，<code>n</code>也许就够了，<code>n_stu</code>也不错，但是<code>number_of_stu</code>就没必要，会显得代码冗长。</p><blockquote><p>Use active names for functions.</p></blockquote><p>函数名应该是动态的。比如要打印数组，<code>print_arr</code>就很好，而单独一个<code>arr</code>就让人不知道该函数的用途。名字中的动词也需要足够直白，比如返回布尔值的函数，<code>check_even</code>是模棱两可的，因为它并没有说明如果是偶数返回真还是假，而<code>is_even</code>就让人清楚地知道如果是偶数，该函数返回真。</p><h1 id="Expressions-and-Statements"><a href="#Expressions-and-Statements" class="headerlink" title="Expressions and Statements"></a>Expressions and Statements</h1><blockquote><p>Parenthesize to reslove ambiguity.</p></blockquote><p>括号可以清晰的划分结构与优先级，即使不需要的时候我们也可以加上以避免不必要的错误和增加可读性。</p><p>比如<code>if (x&amp;MASK == BITS)</code>，显然其本意是想判断<code>x</code>和掩码进行与运算后是否等于<code>BITS</code>，但由于位操作符的优先级低于等于号，这段代码实际上等价于<code>if (x &amp; (MASK == BITS))</code>，这也就发生了意料之外的错误，因此这个表达式需要加上括号，即<code>if ((x&amp;MASK) == BITS)</code>。</p><p>又如这样一个表达式：</p><pre><code class="hljs c">leap_year = y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != || y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;</code></pre><p>这当然是没错的，但第一眼看去，我们难以把握结构，若按如下修改会清晰得多：</p><pre><code class="hljs c">leap_year = ((y%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (y%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (y%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>));</code></pre><p>注意到，我们移去了一些空格，使高优先级的操作符更紧凑，这样可以帮助读者更快地把握结构。</p><blockquote><p>Be careful with side effects.</p></blockquote><p>不了解序列点(sequence point)、副作用(side effect)和未定义行为(undefined behavior)的朋友可先参见：<a href="https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points" target="_blank" rel="noopener">Undefined behavior and sequence points</a></p><p>在C和C++中，一个序列点前副作用的执行顺序是未定义的。如：</p><pre><code class="hljs c">str[i++] = str[i++] = <span class="hljs-string">' '</span>;</code></pre><p>在这里，<code>;</code>就是一个序列点，而我们知道，<code>++</code>操作符是有副作用的，它不仅返回一个值，还会修改该变量的值。那么当一个语句中对同一个变量做多次<code>++</code>操作会导致未定义行为，因为虽然我们心里想的是<code>i</code>增加两次，但编译器不知道到底<code>i</code>是增加一次还是两次，也不知道是将右边的<code>i</code>递增后的值还是原来的值赋给左边的<code>i</code>，这就导致了<code>warning: multiple unsequenced modification to i</code>。</p><p>再看一个我从书本Exercise 1-5改编的例子，以下代码片段有什么问题呢？</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ip)</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, ip);    <span class="hljs-keyword">return</span> *ip;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, a, b); &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">read</span>(&amp;a), <span class="hljs-built_in">read</span>(&amp;b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>我们可以先看看当输入为<code>2 3</code>时，不同编译器下的输出结果：</p><table><thead><tr><th align="left">编译器</th><th align="left">输出结果</th></tr></thead><tbody><tr><td align="left">gcc</td><td align="left">3 2</td></tr><tr><td align="left">clang</td><td align="left">2 3</td></tr></tbody></table><p><code>scanf</code>函数不是分别运行的吗？为什么会产生这样的奇怪的结果呢？原因是<em>函数调用计算完所有参数后且执行被调用函数前</em>也是一个序列点，而我们这里的函数参数计算里含有I/O操作，I/O操作也有副作用，所以这里函数参数的计算顺序也是未定义的，因此如果先计算第一个参数，那么<code>2</code>就会被写入参数<code>a</code>中，<code>3</code>就会被写入<code>b</code>中，输出结果同clang；但如果先计算第二个参数，<code>2</code>和<code>3</code>就会被分别写入<code>b</code>和<code>a</code>中，输出结果同gcc。</p><h1 id="Consistency-and-Idioms"><a href="#Consistency-and-Idioms" class="headerlink" title="Consistency and Idioms"></a>Consistency and Idioms</h1><p>在这一节中，基本都是熟知的准则，不再赘述。但下面这个代码示例告诉了我们一种优雅处理嵌套的<code>if else</code>错误判断语句的方式。</p><p>我们很可能写出类似这样的代码：</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>)     <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)                putc(c,fout);            fclose(fin);            fclose(fout);        &#125; <span class="hljs-keyword">else</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);</code></pre><p>使用递进的<code>if</code>判断，最终是前期准备无错误的处理代码，然后再用多个<code>else</code>分别处理各种错误情况。这段代码并不优雅，并且有资源泄露的可能——如果<code>fout</code>打开文件失败，那么<code>fin</code>打开的文件就不会显式关闭，未显式关闭文件可能导致的问题可参见：<a href="https://www.quora.com/Why-do-we-need-to-close-files-in-programming-after-performing-a-read-or-write-operation" target="_blank" rel="noopener">Why do we need to close files?</a><br>那么如何改进呢？我们可以使用<code>if, else if</code>来推进，先处理错误情况，最终才是正常情况下的代码。</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage: cp inputfile outputfile\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fin = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>)) != <span class="hljs-literal">NULL</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fout = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"w"</span>)) != <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can't open input file %s\n"</span>, argv[<span class="hljs-number">2</span>]);    fclose(fin); <span class="hljs-comment">/* release the resource fin occupied */</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span> ((c = getc(fin)) != EOF)        putc(c,fout);    fclose(fin);    fclose(fout);&#125;</code></pre><h1 id="Function-Macros"><a href="#Function-Macros" class="headerlink" title="Function Macros"></a>Function Macros</h1><blockquote><p>Avoid function macros.</p></blockquote><p>宏是进行文本的替换，因此如果函数宏定义中参数出现了多次，那么它就会被计算多次，这在大多数时候都不是我们想要的。如：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isupper(c) ((c) &gt;= <span class="hljs-meta-string">'A'</span> &amp;&amp; (c) &lt;= <span class="hljs-meta-string">'Z'</span>)</span>...<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(c = getchar()))    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c is uppercase\n"</span>, c);</code></pre><p>那么实际<code>if</code>的判断语句等价于</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (((c = getchar()) &gt;= <span class="hljs-string">'A'</span> &amp;&amp; (c = getchar()) &lt;= <span class="hljs-string">'Z'</span>))</code></pre><p>这显然是错误的，假定我们输入一个字符然后回车，那么只要这个字符的ASCII码值大于等于A的码值就会有输出，因为逻辑与表达式的第二部分程序又读了一个字符，这个字符就是留在缓冲区的<code>\n</code>字符，其ASCII码值为<code>0xa</code>，小于<code>Z</code>的码值。</p><p>很多人习惯使用宏来管理幻数/魔数(Magic Numbers)，其实尽量不要用C预处理器来做这件事，让语言本身来处理是更好的。在C++中可以用<code>const</code>来声明常量：</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ARR_SIZE = <span class="hljs-number">5</span>;</code></pre><p>C中当然也有<code>const</code>，值得注意的是，用<code>const</code>修饰的值是无法作为<code>静态数组</code>的边界的（因为这是<code>运行时常量</code>），但<code>enum</code>可以实现这一点：</p><pre><code class="hljs c"><span class="hljs-keyword">enum</span> &#123;ARR_SIZE = <span class="hljs-number">5</span>&#125;;</code></pre><p>那这是不是意味着我们永远不能使用宏呢？并不是，我们应该让宏做函数做不了的事情。典型的例子就是仅由声明计算数组的长度：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NELEMS(array) (sizeof(array) / sizeof(array[0]))</span></code></pre><p>在这里，<code>sizeof(array)</code>计算的就是数组本身的长度，而在函数中，数组参数退化为指针，<code>sizeof(array)</code>就只能计算出指针的大小了。对数组和指针关系不太明确的朋友可参考：<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">is an array name a pointer?</a></p><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><blockquote><p>Comment functions and global data.</p></blockquote><p>给每个函数和全局变量写适当的注释是一个好习惯。在我接触的好的代码风格中，也有的还在文件开头写一个文件的注释，告诉读者这一个文件的主要用途以及注意事项等，个人认为这也值得学习。</p><blockquote><p>Don’t comment bad code, rewrite it.</p></blockquote><p>这一准则给出了一个有意思的判断，即当注释的字数多过于要注释的代码段时，这段代码可能就是<code>bad code</code>。这时应该看看是否需要改善代码而不是坚持注释。</p><p>至此，第一章就结束了，希望我们都能形成一个好的代码风格。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>The Practice of Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int ch = getchar()?</title>
    <link href="/int-ch-getchar.html"/>
    <url>/int-ch-getchar.html</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>也许你看过/写过类似这样的代码：</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><p>这段代码看起来没什么问题，但实际上代码中的循环有可能永不终止，也有可能提前结束。</p><h1 id="函数与EOF介绍"><a href="#函数与EOF介绍" class="headerlink" title="函数与EOF介绍"></a>函数与EOF介绍</h1><p>在解释之前，我们先了解下相关内容。C语言常用的字符读取函数如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getchar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre><p>这三个函数都是从文件流中读取一个字符，正常情况下把该字符从<code>unsigned char</code>转换为<code>int</code>类型返回，若出错或读到文件结尾则返回<code>EOF</code>。</p><p><code>EOF</code>又是什么呢？<code>EOF</code>只是一个宏定义的负整数而已，一般为<code>-1</code>(hex:0xffffffff)。</p><p>由于上述函数区别不大，此文便只用最常见的<code>getchar</code>函数来讨论。</p><h1 id="char-ch-getchar-错在哪里？"><a href="#char-ch-getchar-错在哪里？" class="headerlink" title="char ch = getchar()错在哪里？"></a>char ch = getchar()错在哪里？</h1><p>看到这，你可能会说：既然<code>EOF</code>只是值为<code>-1</code>的负整数，这不是在<code>char</code>的表示范围-128~127内吗？用<code>char</code>保存返回值有何不可？</p><p><code>-1</code>真的一定在<code>char</code>的表示范围内吗？我们可以在头文件<code>limits.h</code>中看到如下定义：</p><pre><code class="hljs c"><span class="hljs-comment">/* Minimum and maximum values a `signed char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MIN(-128)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCHAR_MAX127</span><span class="hljs-comment">/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UCHAR_MAX255</span><span class="hljs-comment">/* Minimum and maximum values a `char' can hold.  */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CHAR_UNSIGNED__</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MIN0</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXUCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MINSCHAR_MIN</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_MAXSCHAR_MAX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>由此可见，标准并未规定<code>char</code>是有符号的，而是留给各个编译器自己实现。</p><p>所以当<code>char</code>默认为无符号时，<code>-1</code>就不在其表示范围内，这时使用<code>char</code>保存返回值也就有问题了。实际上即使你所用的编译器默认定义<code>char</code>是有符号的，文章开头的那段代码依然有潜在的bug。下面我们分为<code>char</code>默认无符号和有符号两种情况讨论，利用计算机组成原理的知识来详细解释为什么不应该用<code>char</code>保存<code>getchar</code>的返回值。</p><h2 id="1-char默认是无符号的"><a href="#1-char默认是无符号的" class="headerlink" title="1. char默认是无符号的"></a>1. char默认是无符号的</h2><p><strong>这种情况会导致循环无法终止。</strong>假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，这时由于<code>ch</code>是<code>char</code>类型，只有一个字节，而<code>EOF</code>是<code>int</code>类型，有四个字节却要保存在一个字节中，<code>EOF</code>的值会被截断，<code>ch</code>也就等于<code>0xff</code>，又因为<code>ch</code>要与<code>EOF</code>比较，<code>ch</code>符号扩展得<code>0x000000ff</code>（因为<code>ch</code>是无符号的，也就是0扩展），永远不可能等于<code>EOF</code>，循环也就永远不会终止。</p><h2 id="2-char默认是有符号的"><a href="#2-char默认是有符号的" class="headerlink" title="2. char默认是有符号的"></a>2. char默认是有符号的</h2><p><strong>这种情况可能导致循环提前终止。</strong>同样假定我们遇到错误/读到文件末尾，<code>getchar</code>函数返回<code>EOF</code>，前面都一样，但是在符号扩展的时候，由于<code>ch</code>是有符号的，其扩展得<code>0xffffffff</code>，等于<code>EOF</code>。因此循环是可以终止的，但是如果我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，循环就会同碰到<code>EOF</code>一样终止。</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>那么如何修改代码才是正确的呢？其实只需要用<code>int</code>来保存返回值即可。</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> ch;<span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)    <span class="hljs-built_in">putchar</span>(ch);</code></pre><p>这种情况就不会有问题。即使我们在遇到错误/读到文件末尾之前读到了一个值为<code>0xff</code>的字节，由于<code>ch</code>是<code>int</code>类型，而<code>getchar</code>是将读到的字符由<code>unsigned char</code>转为<code>int</code>作返回值，则该字节的值经符号扩展再赋值给<code>ch</code>，<code>ch</code>就等于<code>0x000000ff</code>，不会等于<code>EOF</code>，也就不会提前终止了。</p><p>综上，这就是为什么要用<code>int</code>类型而不是<code>char</code>类型来保存C语言字符读取函数的返回值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default" target="_blank" rel="noopener">is char signed or unsigned by default?</a></li><li><a href="https://stackoverflow.com/questions/13694394/while-c-getcfile-eof-loop-wont-stop-executing" target="_blank" rel="noopener">why the loop won’t stop executing?</a></li><li><a href="https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284351&answer=1048865140" target="_blank" rel="noopener">Definition of EOF and how to use it effectively</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术闲谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
