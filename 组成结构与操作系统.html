<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>组成结构与操作系统 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-07 21:26" pubdate>2021年3月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 26 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">组成结构与操作系统</h1><div class="markdown-body" id="post-body"><p>最近在进行计算机组成结构与操作系统的查漏补缺，部分知识点纪录在此。</p><h1 id="位级表示"><a href="#位级表示" class="headerlink" title="位级表示"></a>位级表示</h1><h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h2><p>无符号数就是纯二进制表示，而有符号数有多种表示方法：原码、反码和补码，现大多使用补码。正是因为有符号数有多种表示方法，C++中如果对一个有符号数赋予超出表示范围的值，其结果是未定义的，因为不知道如何解释这个值。</p><p>原码和反码都是需要考虑符号的，而且0有正0和负0之分，因此不方便计算也不统一。反码英文是one’s complement，即1的补码，也就是取反，而补码的英文是two’s complement，但不是2的补码，而是2\^w的补码，其中w是该数二进制表示的位数，也就是说一个负数-x，它的补码表示是2\^w - x，计算方法简记为<code>取反加一</code>。以-1的补码为例，也就是求正数1对2\^w的补码：</p><pre><code class="hljs shell">  1 0 0 0 0
-   0 0 0 1
-------------
  0 1 1 1 1</code></pre><p>而取反加一也刚好是这个结果，所以一般教的计算方法都是取反加一。</p><h2 id="二进制与十进制的转换"><a href="#二进制与十进制的转换" class="headerlink" title="二进制与十进制的转换"></a>二进制与十进制的转换</h2><ol><li><p>正整数转二进制：</p><p>除二取余，倒序排列</p></li><li><p>小数转二进制</p><p>对小数点后的数乘以2，取结果的整数部分，以此类推，直到小数部分为0或精度足够</p></li><li><p>二进制转十进制</p><p>位上的值与对应权值（基数为2）相乘并累加</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="浮点数与整数直接类型转换"><a href="#浮点数与整数直接类型转换" class="headerlink" title="浮点数与整数直接类型转换"></a>浮点数与整数直接类型转换</h3><p>旧C++、C语言中：(type)val</p><p>现代C++中：static_cast\<type \>(val)</type></p><p><strong>（以下知识在深入理解计算机系统中有涉及）</strong></p><p>整数存储在通用寄存器中，浮点数存储在xmm寄存器（是ymm寄存器的低16字节）中。它们之间的强制类型转换有对应的机器指令。</p><p>浮点数转成整数是直接截断，向0舍入；而整数转成浮点数便是根据IEEE的浮点数位表示标准进行转换。</p><h3 id="用指针进行类型转换"><a href="#用指针进行类型转换" class="headerlink" title="用指针进行类型转换"></a>用指针进行类型转换</h3><p>旧C++、C语言中：(type*)&amp;val</p><p>现代C++中：reinterpret_cast\<type *\>(&amp;val)</type></p><p>不是直接对值的类型转换，那样也许会改变底层的位表示。而是不改变底层的位表示，而是用另一种类型的方法去解释底层的位表示：<a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">例子</a></p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在进程模型中，计算机上所有可运行的软件，包括操作系统，都称为进程。</p><p>进程是一个正在执行的程序的实例，包括程序计数器、寄存器等程序运行需要的资源。</p><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>具体区别 1 2 3?</p><p>例子：</p><p>我正在根据参考答案用红笔修改做过的作业，这里参考答案就是程序，红笔和我做过的作业就是相关的资源，我就是CPU，那么进程就是我阅读参考答案，比照我写的答案，用红笔进行修改的这一系列动作的总和。</p><p>而如果现在面试官打电话叫我面试，那我就记录下我改到的位置（保存进程当前状态），然后接电话根据我以前学习的知识回答面试官的问题。这里处理机就是从一个进程切换到了一个高优先级的进程，每个进程都拥有各自的程序（参考答案和我学习过的知识）。面试完后，我又回来继续改作业，从刚才改到的位置继续下去。</p><p>值得注意的是：<strong>一个程序运行两遍，算作两个进程</strong>。比如我们可以运行两次自己写的代码，其中用<code>getpid</code>获得当前进程的pid，我们会发现每次运行输出的pid不同。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>unix系统中只有一个系统调用可以用来创建新进程：fork，创建出来的子进程通常还会接着执行execve来修改其内存映像并运行一个新程序。之所以要安排两步来建立进程，是为了在fork之后但在execve之前允许该子进程修改其文件描述符，这样可以完成输入输出的重定向。</p><p>具体原因其实还是历史遗留，当时fork和execve刚设计时还没有进程和线程的概念，execve就是会直接把shell的内存修改以执行新的程序，但这样要每次重新加载shell，于是fork就出现了，复制一份shell的内存映像、文件描述符等，用execve执行新任务而对shell本身没有影响。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>如：</p><pre><code class="hljs shell">ps aux &gt; 1.txt</code></pre><p>shell会先fork出一个自身的进程，然后将文件描述符1从标准输出改为输出到1.txt，再使用execve执行ps这个命令，ps直接输出即可，结果就是输出到1.txt中了。</p><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在unix中，进程和他的所有子进程以及后裔共同组成一个进程组。</p><p>init进程会出现在启动映像中，当它开始运行时，读入一个说明终端数量的文件，接着为每个终端创建一个新的进程。这些进城等待用户登录，登陆成功后，登录进程就会执行shell准备接受命令，接受的这些命令又会启动更多的进程。这样，所有进程都属于以init为根的一棵进程树。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程有三个状态：</p><ol><li>运行态（占用cpu）</li><li>就绪态（可运行，但是由于其他进程占用cpu而暂时停止）</li><li>阻塞态（不能运行，等待某些事件发生才可运行，如等待用户输入）</li></ol><p>unix中当一个进程从管道或其他设备读取数据时，如果暂时没有有效的输入，进程会被自动阻塞（为什么会暂时没有有效输入？这是由命令的执行时间以及分配到的cpu时间决定的）。</p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>进程表</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>进程是资源分配的最小单位，而线程是资源调度的最小单位。<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><p>主要原因：许多应用中同时存在着多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解为可以和所有准并行运行的多个线程，程序设计、用户体验和性能会变得更好。</p><ol><li>多个线程拥有共享同一地址空间和所有可用数据的能力</li><li>线程比进程更轻量级，创建一个线程比创建一个进程要快10~100倍</li><li>如果存在大量的计算和大量的IO处理，多线程允许这些活动彼此重叠进行，从而加快执行速度</li></ol><p>例子：</p><p>一个字处理程序，需要与用户交互，当用户修改后还需要重新格式化文件。如果是单线程程序，用户修改后，程序马上去格式化，如果是大文件，则时间较长无法响应用户的其他需求。但如果我们程序有两个线程，一个线程与用户交互，另一个在后台格式化处理。当用户修改后，交互的线程通知后台线程进行格式化处理，期间交互线程仍可以响应用户的一些简单命令，也许当用户请求查看格式化好的文件时已经格式化好了，用户的体验也就更好。我们还可以再添加一个线程用于文件的备份，该线程周期性地保存文件内容。</p><h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>在unix中，有一个通用的线程包pthread，以下是其中常用的函数调用：</p><div class="table-container"><table><thead><tr><th>pthread_create</th><th>创建新线程</th></tr></thead><tbody><tr><td>pthread_exit</td><td>结束调用的线程</td></tr><tr><td>pthread_join</td><td>等待一个特定线程退出</td></tr><tr><td>pthread_yield</td><td>让出cpu来运行另一线程</td></tr></tbody></table></div><h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>有三个问题：</p><ol><li>信息传递</li><li>互斥</li><li>同步</li></ol><p>第一个问题对线程来说比较容易，因为它们共享同一个地址空间，但另外两个问题和对应的解决方法同样适用于线程。</p><h3 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h3><p>竞争条件：多个进程读写共享数据，其最后的结果取决于进程运行的精确时序。</p><p>互斥（mutual exclusion）：以某种手段确保当一个进程在读写一个共享数据时，其他进程不能做同样的操作。</p><p>临界区：对共享内存进行访问的<strong>程序片段</strong>。</p><p>如果能使两个进程不可能同时处在临界区，那么就能避免竞争条件。</p><p><strong>典型问题</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者-消费者问题</a>（仔细阅读，有错误实例、伪代码与解析）</p><p><a href="https://shivammitra.com/c/producer-consumer-problem-in-c/" target="_blank" rel="noopener">使用信号量与互斥量的C代码</a></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>用于解决进程同步或互斥问题而引入的整型变量。</p><p>对于生产者-消费者问题而言，信号量mutex用于互斥，fill和empty用于同步。</p><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>如果不需要信号量的<strong>计数能力</strong>，有时候可以使用信号量的简化版本，即互斥量（其实就是二进制信号量）。对于生产者-消费者问题，这只能用于解决缓冲区大小为1的情况。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>任意时刻管程中只会有一个活跃进程，这一特性使得管程能有效地完成互斥，这是编译器的任务。由于无需考虑互斥问题，我们只需关心如何让进程在无法继续时阻塞，方法仍然是上述的条件变量。</p><p>管程是编程语言的组成部分，java中便有管程，但是c和c++没有，因此这里不做过多的探讨。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_ 1"><sup>1</sup>. <a href="zhihu.com/question/66902460">为什么Linux下要把创建进程分为fork()和exec()(一系列函数)两个函数来处理?</a><a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup>2</sup>. <a href="https://www.zhihu.com/question/274550824" target="_blank" rel="noopener">操作系统中到底是谁分配的资源?</a><a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">现代操作系统</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><span class="hidden-mobile">C++Primer读书笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","组成结构与操作系统&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>