<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;light&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>组成结构与操作系统 - seineo&#39;s blog</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>seineo</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/post_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-07 21:26" pubdate>2021年3月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 71 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">组成结构与操作系统</h1><div class="markdown-body" id="post-body"><p>最近在进行计算机组成结构与操作系统的查漏补缺，部分知识点纪录在此。</p><h1 id="位级表示"><a href="#位级表示" class="headerlink" title="位级表示"></a>位级表示</h1><h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h2><p>无符号数就是纯二进制表示，而有符号数有多种表示方法：原码、反码和补码，现大多使用补码。正是因为有符号数有多种表示方法，C++中如果对一个有符号数赋予超出表示范围的值，其结果是未定义的，因为不知道如何解释这个值。</p><p>原码和反码都是需要考虑符号的，而且0有正0和负0之分，因此不方便计算也不统一。反码英文是one’s complement，即1的补码，也就是取反，而补码的英文是two’s complement，但不是2的补码，而是2^w^的补码，其中w是该数二进制表示的位数，也就是说一个负数-x，它的补码表示是2^w^ - x，计算方法简记为<code>取反加一</code>。以-1的补码为例，也就是求正数1对2^w^的补码：</p><pre><code class="hljs shell">  1 0 0 0 0
-   0 0 0 1
-------------
  0 1 1 1 1</code></pre><p>而取反加一也刚好是这个结果，所以一般教的计算方法都是取反加一。</p><h2 id="二进制与十进制的转换"><a href="#二进制与十进制的转换" class="headerlink" title="二进制与十进制的转换"></a>二进制与十进制的转换</h2><ol><li><p>正整数转二进制：</p><p>除二取余，倒序排列</p></li><li><p>小数转二进制</p><p>对小数点后的数乘以2，取结果的整数部分，以此类推，直到小数部分为0或精度足够</p></li><li><p>二进制转十进制</p><p>位上的值与对应权值（基数为2）相乘并累加</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="浮点数与整数直接类型转换"><a href="#浮点数与整数直接类型转换" class="headerlink" title="浮点数与整数直接类型转换"></a>浮点数与整数直接类型转换</h3><p>旧C++、C语言中：(type)val</p><p>现代C++中：static_cast\<type \>(val)</type></p><p><strong>（以下知识在深入理解计算机系统中有涉及）</strong></p><p>整数存储在通用寄存器中，浮点数存储在xmm寄存器（是ymm寄存器的低16字节）中。它们之间的强制类型转换有对应的机器指令。</p><p>浮点数转成整数是直接截断，向0舍入；而整数转成浮点数便是根据IEEE的浮点数位表示标准进行转换。</p><h3 id="用指针进行类型转换"><a href="#用指针进行类型转换" class="headerlink" title="用指针进行类型转换"></a>用指针进行类型转换</h3><p>旧C++、C语言中：(type*)&amp;val</p><p>现代C++中：reinterpret_cast\<type *\>(&amp;val)</type></p><p>不是直接对值的类型转换，那样也许会改变底层的位表示。而是不改变底层的位表示，而是用另一种类型的方法去解释底层的位表示：<a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">例子</a></p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在进程模型中，计算机上所有可运行的软件，包括操作系统，都称为进程。</p><p>进程是一个正在执行的程序的实例，包括程序计数器、寄存器等程序运行需要的资源。</p><h3 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h3><p>具体区别 1 2 3?</p><p>例子：</p><p>我正在根据参考答案用红笔修改做过的作业，这里参考答案就是程序，红笔和我做过的作业就是相关的资源，我就是CPU，那么进程就是我阅读参考答案，比照我写的答案，用红笔进行修改的这一系列动作的总和。</p><p>而如果现在面试官打电话叫我面试，那我就记录下我改到的位置（保存进程当前状态），然后接电话根据我以前学习的知识回答面试官的问题。这里处理机就是从一个进程切换到了一个高优先级的进程，每个进程都拥有各自的程序（参考答案和我学习过的知识）。面试完后，我又回来继续改作业，从刚才改到的位置继续下去。</p><p>值得注意的是：<strong>一个程序运行两遍，算作两个进程</strong>。比如我们可以运行两次自己写的代码，其中用<code>getpid</code>获得当前进程的pid，我们会发现每次运行输出的pid不同。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>unix系统中只有一个系统调用可以用来创建新进程：fork，创建出来的子进程通常还会接着执行execve来修改其内存映像并运行一个新程序。之所以要安排两步来建立进程，是为了在fork之后但在execve之前允许该子进程修改其文件描述符，这样可以完成输入输出的重定向。</p><p>具体原因其实还是历史遗留，当时fork和execve刚设计时还没有进程和线程的概念，execve就是会直接把shell的内存修改以执行新的程序，但这样要每次重新加载shell，于是fork就出现了，复制一份shell的内存映像、文件描述符等，用execve执行新任务而对shell本身没有影响。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>如：</p><pre><code class="hljs shell">ps aux &gt; 1.txt</code></pre><p>shell会先fork出一个自身的进程，然后将文件描述符1从标准输出改为输出到1.txt，再使用execve执行ps这个命令，ps直接输出即可，结果就是输出到1.txt中了。</p><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在unix中，进程和他的所有子进程以及后裔共同组成一个进程组。</p><p>init进程会出现在启动映像中，当它开始运行时，读入一个说明终端数量的文件，接着为每个终端创建一个新的进程。这些进城等待用户登录，登录成功后，登录进程就会执行shell准备接受命令，接受的这些命令又会启动更多的进程。这样，所有进程都属于以init为根的一棵进程树。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程有三个状态：</p><ol><li>运行态（占用cpu）</li><li>就绪态（可运行，但是由于其他进程占用cpu而暂时停止）</li><li>阻塞态（不能运行，等待某些事件发生才可运行，如等待用户输入）</li></ol><p>unix中当一个进程从管道或其他设备读取数据时，如果暂时没有有效的输入，进程会被自动阻塞（为什么会暂时没有有效输入？这是由命令的执行时间以及分配到的cpu时间决定的）。</p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为每个进程维护一个表格，即进程表，包含程序计数器、寄存器、堆栈指针、文件描述符、用户和调度信息等，这些信息可以保证该进程能在状态切换或中断后能再次启动，像什么也没发生一样。</p><h3 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h3><p>采用多道程序设计可以提高CPU的利用率。</p><p>我们使用概率的角度来看CPU的利用率。假设一个进程等待IO操作的时间与其停留在内存中的时间的比为p，那么当内存中同时有n个进程时，所有n个进程都在等待IO（即CPU空转）的概率是p^n^，CPU的利用率=1-p^n^。n称为多道程序设计的道数。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>进程是资源分配的最小单位，而线程是资源调度的最小单位。<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><p>线程</p><h3 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h3><p>主要原因：许多应用中同时存在着多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解为可以和所有准并行运行的多个线程，程序设计、用户体验和性能会变得更好。</p><ol><li>多个线程拥有共享同一地址空间和所有可用数据的能力</li><li>线程比进程更轻量级，创建一个线程比创建一个进程要快10~100倍</li><li>如果存在大量的计算和大量的IO处理，多线程允许这些活动彼此重叠进行，从而加快执行速度</li></ol><p>例子：</p><p>一个字处理程序，需要与用户交互，当用户修改后还需要重新格式化文件。如果是单线程程序，用户修改后，程序马上去格式化，如果是大文件，则时间较长无法响应用户的其他需求。但如果我们程序有两个线程，一个线程与用户交互，另一个在后台格式化处理。当用户修改后，交互的线程通知后台线程进行格式化处理，期间交互线程仍可以响应用户的一些简单命令，也许当用户请求查看格式化好的文件时已经格式化好了，用户的体验也就更好。我们还可以再添加一个线程用于文件的备份，该线程周期性地保存文件内容。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>每个线程都有自己的堆栈，因为通常每个线程都会各自调用不同的过程，从而有一个不同的执行历史。</p><p>在多线程的情况下，进程通常会从当前的单个线程开始，这个线程有能力创建新的线程，新线程自动在创建线程的地址空间运行。通常线程没有层次关系，所有线程都是平等的（有时候会具有父子关系）。</p><h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>在unix中，有一个通用的线程包pthread，以下是其中常用的函数调用：</p><div class="table-container"><table><thead><tr><th>pthread_create</th><th>创建新线程</th></tr></thead><tbody><tr><td>pthread_exit</td><td>结束调用的线程</td></tr><tr><td>pthread_join</td><td>等待一个特定线程退出</td></tr><tr><td>pthread_yield</td><td>让出cpu来运行另一线程</td></tr></tbody></table></div><h3 id="用户级线程与内核级线程"><a href="#用户级线程与内核级线程" class="headerlink" title="用户级线程与内核级线程"></a>用户级线程与内核级线程</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>将线程包放在用户空间中，内核对线程包一无所知。从内核角度看，就是按正常的单线程进程管理。在用户控件管理线程，每个进程都需要有一张线程表，用来跟踪与记录各线程的属性，如程序计数器，堆栈指针等，以便后续线程状态切换的复原。</p><p>用户级线程的切换可以在几条指令内完成，比内核级至少快一个数量级。</p><p>用户级线程的一个问题是实现阻塞系统调用，如果线程实际进行会阻塞的系统调用，则所有线程会停止（因为用户级线程是进程内线程调度）。因此，有许多方法被提出，如使用非阻塞的系统调用，或阻塞前通知替换等。</p><p>还有一个问题就是，由于在一个单独的进程内部是没有时钟中断（因为时钟中断是硬中断，进入内核态后因为系统按单线程进程管理，所以对内部的线程是无法处理的）的，所以用户级线程包中一旦一个线程开始执行，那么该进程中其他线程就不能运行，除非第一个线程主动放弃CPU或运行结束。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>每个进程不再有线程表，相反，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建或撤销一个线程时，它进行一个系统调用，这个系统调用是通过更新线程表来完成的。</p><p>所有阻塞线程的调用都以系统调用的形式实现，不需要任何新的非阻塞系统调用，缺点就是系统调用的代价比较大。</p><h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>有三个问题：</p><ol><li>信息传递</li><li>互斥</li><li>同步</li></ol><p>第一个问题对线程来说比较容易，因为它们共享同一个地址空间，但另外两个问题和对应的解决方法同样适用于线程。</p><h3 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h3><p>竞争条件：多个进程读写共享数据，其最后的结果取决于进程运行的精确时序。</p><p>互斥（mutual exclusion）：以某种手段确保当一个进程在读写一个共享数据时，其他进程不能做同样的操作。</p><p>临界区：对共享内存进行访问的<strong>程序片段</strong>。</p><p>如果能使两个进程不可能同时处在临界区，那么就能避免竞争条件。</p><p><strong>典型问题</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者-消费者问题</a>（仔细阅读，有错误实例、伪代码与解析）</p><p><a href="https://shivammitra.com/c/producer-consumer-problem-in-c/" target="_blank" rel="noopener">使用信号量与互斥量的C代码</a></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>用于解决进程同步或互斥问题而引入的整型变量。</p><p>对于生产者-消费者问题而言，信号量mutex用于互斥，fill和empty用于同步。</p><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>如果不需要信号量的<strong>计数能力</strong>，有时候可以使用信号量的简化版本，即互斥量（其实就是二进制信号量）。对于生产者-消费者问题，这只能用于解决缓冲区大小为1的情况。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>任意时刻管程中只会有一个活跃进程，这一特性使得管程能有效地完成互斥，这是编译器的任务。由于无需考虑互斥问题，我们只需关心如何让进程在无法继续时阻塞，方法仍然是上述的条件变量。</p><p>管程是编程语言的组成部分，java中便有管程，但是c和c++没有，因此这里不做过多的探讨。</p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>是系统调用，而不属于具体语言。</p><p>通常会在并行程序设计系统中使用消息传递，这里不做过多的探讨。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h3><ol><li>创建新进程后，需要决定先运行父进程还是子进程</li><li>一个进程退出时，一般会选择一个就绪的进程，如果没有，则运行系统提供的一个空闲进程。</li><li>一个进程被阻塞后，需要选择另一个进程运行</li><li>IO中断发生时，一般这时候某些被阻塞的进程就会称为可运行的就绪进程了。</li></ol><p>如果硬件时钟提供周期性的中断，可以在每k个时钟中断时做出调度决策。</p><p>根据如何处理时钟中断，可将调度算法分为两类：抢占式与非抢占式。</p><p>非抢占式调度算法调度一个进程，然后让该进程运行直至被阻塞或自动释放CPU，它不会被强制挂起，因此在时钟中断时不会发生进程调度，在处理完时钟中断后，如果没有更高优先级的进程到达，被中断的进程会继续运行。</p><p>而抢占式调度算法会让进程运行某个固定时段的最大值，到时间后如果该进程还在运行则将其挂起，挑选另一个进程运行。要进行抢占式调度，就需要在该时段的末端发生时钟中断，以便把CPU控制返回给调度程序。</p><p>当然，如果没有可用的时钟，则只能使用非抢占式算法。</p><h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><p>在不同的系统中，调度程序的优化目标是不同的。通常分为三种系统环境：</p><ol><li>批处理</li><li>交互式（分时）</li><li>实时（这里不探讨该系统的调度算法，不常用）</li></ol><p><a href="https://www.douban.com/note/311010077/" target="_blank" rel="noopener">三种系统的介绍以及各自常用的调度算法</a></p><p><a href="https://blog.csdn.net/u010889616/article/details/48424501" target="_blank" rel="noopener">三种系统的区别</a></p><p>批处理系统中，不会有用户在一旁等待快捷响应，因此非抢占式算法或每个进程都有长时间周期的抢占式算法都可以，这样减少了进程切换从而改善了性能。</p><p>交互式系统中，为了用户的体验抢占是必需的。</p><h3 id="调度算法的目标和指标"><a href="#调度算法的目标和指标" class="headerlink" title="调度算法的目标和指标"></a>调度算法的目标和指标</h3><ul><li>所有系统（目标）：<ul><li>公平：给每个进程公平的CPU份额</li><li>策略强制执行：保证规定的策略被执行</li><li>平衡：保持系统所有部分都忙碌</li></ul></li><li>批处理系统：<ul><li>吞吐量：每小时完成的作业数</li><li>周转时间：从提交作业到完成作业的平均时间</li><li>CPU利用率（不是个好的指标）</li></ul></li><li>交互式系统<ul><li>响应时间：快速响应请求</li><li>均衡性：满足用户的期望</li></ul></li></ul><h3 id="具体的调度算法"><a href="#具体的调度算法" class="headerlink" title="具体的调度算法"></a>具体的调度算法</h3><h4 id="批处理系统中"><a href="#批处理系统中" class="headerlink" title="批处理系统中"></a>批处理系统中</h4><ol><li>先来先服务：对短作业不友好</li><li>最短作业优先：在所有作业都可同时运行的情况下，最短作业优先算法是最优的</li><li>最短剩余时间优先：是最短作业优先的抢占式版本</li><li>最高响应比优先：？书上可能有</li></ol><p>1，2非抢占式，3抢占式</p><h4 id="交互式系统中"><a href="#交互式系统中" class="headerlink" title="交互式系统中"></a>交互式系统中</h4><ol><li>轮转调度：</li><li>优先级调度</li><li>多级队列</li><li>最短进程优先</li><li>彩票调度</li><li>保证调度（每个进程公平，一般来说是均分）</li><li>公平分享调度（每个用户公平，一般来说是均分）</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。这样的调度取决于是用户级线程还是内核级线程。</p><p>若是用户级线程，由于内核并不知道线程的存在，所以内核和以前一样操作，选取一个进程A，给予时间片控制，A中的线程调度程序选择运行那个线程由于进程内不存在时钟中断，所以该线程可以任意运行多少时间。从实用角度考虑，一般调度算法使用的是轮转调度和优先级调度。</p><p>若是内核调度，则内核选择特定的线程运行，给其赋予一个时间片，时间片结束后挂起该线程。</p><p>两者的差别主要在于性能，用户级线程切换只需要少量指令，而内核级线程却需要完整的上下文切换（因为它不考虑属于哪个进程，也就没有共同的地址空间了），修改内存映像，这导致若干的延迟。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件的存储实现"><a href="#文件的存储实现" class="headerlink" title="文件的存储实现"></a>文件的存储实现</h2><p><strong>扇区是对硬盘而言，块是对文件系统而言</strong>。文件系统不是一个扇 区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，block才是文件存取的最小单位。一般是4KB一块。</p><h3 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1. 连续分配"></a>1. 连续分配</h3><p>是最简单的分配方案，即将每个文件连续存储在磁盘上。</p><p>这一方法有两大优势：</p><ol><li>实现简单，记录每个文件的磁盘块只需要记住第一块的磁盘地址和文件块数即可</li><li>读操作性能好，只需要找到初始位置，不需要再寻道、旋转等，连续读即可。</li></ol><p>但是随着时间的推移，文件的不断添加与释放会使磁盘产生很多碎片，后期要想存储一个新文件很难找到位置。</p><p>但是这一方法也不是没有用处，比如DVD这种一次性写的介质，就很适合使用连续分配这一方法。</p><h3 id="2-链表分配"><a href="#2-链表分配" class="headerlink" title="2. 链表分配"></a>2. 链表分配</h3><p>为每个文件构造磁盘块链表。每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。</p><p>这一方法可以充分利用磁盘块，无需担心因为碎片而浪费空间。而且同样只需要存放第一块的磁盘地址，就可以访问到其他块。</p><p>另一方面，链式存储的随机访问相当缓慢，尤其这还是磁盘IO访问。而且，由于指针占去了一些字节，所以要完整读出文件内容，就需要获取各个块的数据部分然后拼接起来，这其中会涉及复制而引发额外的开销。</p><h3 id="3-用内存中的表进行链表分配"><a href="#3-用内存中的表进行链表分配" class="headerlink" title="3. 用内存中的表进行链表分配"></a>3. 用内存中的表进行链表分配</h3><p>如果取出每个磁盘块中的指针字段，将他们放在内存的表中，就可以解决上述的两个问题。</p><p>每个表项存储着下一磁盘块的块号，顺着这一链就可以找到该文件的所有磁盘块。内存中这样的一个表格称为<strong>文件分配表</strong>（File Allocation Table, FAT），现在各个版本Windows仍然支持这一管理方式。</p><p>但这一方法有一个缺点就是必须把整个表都放在内存中，对于比较大的磁盘来说，表会十分大，占用很多内存，这是不实际的。</p><h3 id="4-i节点"><a href="#4-i节点" class="headerlink" title="4. i节点"></a>4. i节点</h3><p>给每个节点都赋予一个称为i节点（index-node）的数据结构，其中列出的文件属性与文件块的磁盘地址。</p><p>这种机制有很大的优势，因为只有当对应文件打开时，其i节点才会在内存中，这通常比FAT所占据的空间要小。</p><h2 id="目录的存储实现"><a href="#目录的存储实现" class="headerlink" title="目录的存储实现"></a>目录的存储实现</h2><p>打开文件时，操作系统利用给出的路径名找到相应的目录项，目录项提供了查找文件磁盘块需要的信息，这因系统而异，可能是磁盘块的初始地址、第一个块的编号或者是i节点号。总之，目录系统 的主要功能就是把文件名映射为定位文件数据所需的信息。</p><p>对于使用i节点的系统，文件属性是存放在i节点中而不是目录项中的，这样目录项会更短，只有文件名和i节点号。</p><p>现代操作系统都支持可变长度的长文件名，这是如何实现的呢？</p><p>我们可以使目录项本身是固定长度的，而将文件名放置在目录后面的堆中（目录项中的指针指向堆中的文件名）。这一当一个文件目录项被移走后，另一个文件的目录项总可以适合这个空隙。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最近未使用"><a href="#最近未使用" class="headerlink" title="最近未使用"></a>最近未使用</h3><p>大部分支持虚拟内存的计算机中，系统为每个页面都设置了两个状态位，页面被读取设置R位，被修改设置M位。</p><p>利用R位和M位可以将页面分为4类</p><ul><li>第0类：没有访问，没有修改</li><li>第1类：没有访问，已被修改</li><li>第2类：已被访问，没有修改</li><li>第3类：已被访问，且被修改</li></ul><p>NRU（Not Recently Used）算法是当启动一个进程时，将所有页面的两个位由操作系统置为0，R位被时钟中断定期清零，以区分最近没有被访问的页面和被访问的页面（其实就是降低各个类的编号）。</p><p>看起来第1类是不可能出现的，其实第3类如果被时钟中断R位清零就得到了第1类。</p><p>缺页中断时，该算法会随机地从编号最小的页面中挑选一个淘汰。</p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>操作系统维护一个页面链表，最新进入的页面在表尾，最早的在表头，缺页中断时就淘汰表头页面，并把新页调入的页面插入表尾。</p><h3 id="第二次机会"><a href="#第二次机会" class="headerlink" title="第二次机会"></a>第二次机会</h3><p>FIFO可能会把经常使用的算法置换出去，为了避免这一问题，可以检查最老页面的R位，如果是0，则立刻置换，如果是1，则将R位清零，并将该页面放到链表的尾端，装入时间就像刚装入一样，这就是给了第二次的机会。</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>第二次机会是比较合理的置换算法，但是经常要在链表中移动页面，降低了效率。</p><p>我们可以把所有的页面放入一个环形链表，指针指向最老的页面。</p><p>每当发生缺页中断，检查指针所指页面的R位是否为0，是则淘汰，并将新的页面插入该位置，然后把指针向前移动一位；否则清除R位，并把指针向前移动一位。</p><h3 id="最近最少使用"><a href="#最近最少使用" class="headerlink" title="最近最少使用"></a>最近最少使用</h3><p>LRU（Least Recently Used）算法：在发生缺页中断时，置换未使用时间最长的页面。</p><p>一种实现是用一个特殊链表，将最近最多使用的放在表头，最近最少使用的放在表尾，每次使用到的页面如果在链表中，就把它取出并放到表头。不过这个实现一方面很耗时，并且实际上是“最近最久未使用”。</p><p>一种硬件实现是使用一个计数器，每次执行指令自增1，每个页表项中提供一位来容纳这个值，每次访问时就把计数器的值存到访问的页表项中。淘汰页面时选择最小的即可。虽然很符合“最近最少使用”的含义，缺点是消耗了很多存储空间；另外，计数器的溢出也是个问题。同样是“最近最久未使用”。</p><p>硬件的实现较为复杂，但我们可以用软件近似实现。一种软件实现被称为NFU(Not Frequently Used，最不常用)，每个页面使用一个计数器，每次时钟中断时，将页面的R位（是否被引用，0或1）加到计数器上。缺页中断时置换计数器值最小的。这种实现的坏处是它“从不忘记任何事情”，简单地说就是在之前计数器值比较高的页面，即使不再访问，仍然会保持这个值；而别的页面在后续始终无法超过。</p><p>对NFU做一个小修改，就可以很好的模拟LRU：将R位增加前先计数器右移、R位增加到计数器左边的最高位而不是右边的最低位。修改后的算法称为<strong>老化(aging)算法</strong>。其蕴含的特征是：越高位越新，最近的使用权重最大；早期的使用记录会随着右移而舍弃。</p><p>老化算法就不需要担心溢出问题，但同样由于计数器位数有限（比如8位），会限制对以往页面的记录。比如如果两个页面的计数器都是0，那我们只能随机选择一个，但其实有可能其中一个页面在9个时钟前是被访问了的，但我们看不到这些。 在实践中，如果时钟是20ms，那么8位其实是够用的，毕竟一个页面160ms没有被访问说明它很可能不那么重要。</p><h2 id="分页系统的设计"><a href="#分页系统的设计" class="headerlink" title="分页系统的设计"></a>分页系统的设计</h2><h3 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h3><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>（是共享内存通信方式的实现原理）</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h3 id="分段-1"><a href="#分段-1" class="headerlink" title="分段"></a>分段</h3><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h3 id="x86的实现"><a href="#x86的实现" class="headerlink" title="x86的实现"></a>x86的实现</h3><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按请求顺序完成请求，一般来说寻道时间会很长</p><h3 id="最短寻道优先"><a href="#最短寻道优先" class="headerlink" title="最短寻道优先"></a>最短寻道优先</h3><p>下一次总是处理与刺头最近的请求以使得寻道时间最小化。</p><p>这样响应时间确实是最优的，但是很容易使得磁盘臂停留在磁盘的中部区域，而两端的极端地区的请求等待时间很长，即 获得最小响应时间的目标与公平性存在冲突。</p><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>保持一个方向移动，知道在那个方向上没有请求为止，然后改变方向。</p><p>软件会维护一个二进制位表示方向UP和DOWN。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_ 1"><sup>1</sup>. <a href="zhihu.com/question/66902460">为什么Linux下要把创建进程分为fork()和exec()(一系列函数)两个函数来处理?</a><a href="#reffn_ 1" title="Jump back to footnote [ 1] in the text."> &#8617;</a></blockquote><blockquote id="fn_ 2"><sup>2</sup>. <a href="https://www.zhihu.com/question/274550824" target="_blank" rel="noopener">操作系统中到底是谁分配的资源?</a><a href="#reffn_ 2" title="Jump back to footnote [ 2] in the text."> &#8617;</a></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="hover-with-bg" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">现代操作系统</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext row"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><span class="hidden-mobile">C++Primer读书笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","组成结构与操作系统&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>